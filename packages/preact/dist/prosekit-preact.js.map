{"version":3,"file":"prosekit-preact.js","names":[],"sources":["../src/hooks/use-editor-extension.ts","../src/hooks/use-priority-extension.ts","../src/hooks/use-extension.ts","../src/extensions/preact-mark-view.ts","../src/extensions/preact-node-view.ts","../src/components/prosekit.ts","../src/hooks/use-event-callback.ts","../src/hooks/use-doc-change.ts","../src/hooks/use-editor.ts","../src/hooks/use-editor-derived-value.ts","../src/hooks/use-keymap.ts","../src/hooks/use-state-update.ts"],"sourcesContent":["import {\n  EditorNotFoundError,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport { queueExtension } from '@prosekit/web'\nimport { useEffect } from 'preact/hooks'\n\n/**\n * @internal\n */\nexport function useEditorExtension(\n  editor: Editor | null | undefined,\n  extension: Extension | null,\n): void {\n  if (!editor) {\n    throw new EditorNotFoundError()\n  }\n\n  useEffect(() => {\n    if (extension) {\n      return queueExtension(editor, extension)\n    }\n  }, [editor, extension])\n}\n","import {\n  withPriority,\n  type Extension,\n  type Priority,\n} from '@prosekit/core'\nimport { useMemo } from 'preact/hooks'\n\n/**\n * @internal\n */\nexport function usePriorityExtension<T extends Extension = Extension>(\n  extension: T | null,\n  priority?: Priority | null,\n): T | null {\n  return useMemo(() => {\n    return extension && priority ? withPriority(extension, priority) : extension\n  }, [extension, priority])\n}\n","import type {\n  Editor,\n  Extension,\n  Priority,\n} from '@prosekit/core'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\nimport { useEditorExtension } from './use-editor-extension'\nimport { usePriorityExtension } from './use-priority-extension'\n\nexport interface UseExtensionOptions {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `<ProseKit>` component.\n   */\n  editor?: Editor\n\n  /**\n   * Optional priority to add the extension with.\n   */\n  priority?: Priority\n}\n\n/**\n * Add an extension to the editor.\n */\nexport function useExtension(\n  /**\n   * The extension to add to the editor. If it changes, the previous\n   * extension will be removed and the new one (if not null) will be added.\n   */\n  extension: Extension | null,\n  options?: UseExtensionOptions,\n): void {\n  const editorContext = useEditorContext()\n  useEditorExtension(\n    options?.editor || editorContext,\n    usePriorityExtension(extension, options?.priority),\n  )\n}\n","import {\n  defineMarkViewComponent,\n  defineMarkViewFactory,\n  type Extension,\n} from '@prosekit/core'\nimport type { MarkViewConstructor } from '@prosekit/pm/view'\nimport type { CoreMarkViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useMarkViewContext,\n  useMarkViewFactory,\n  type MarkViewContext,\n  type PreactMarkViewUserOptions,\n} from '@prosemirror-adapter/preact'\nimport {\n  h,\n  type ComponentType,\n  type FunctionComponent,\n} from 'preact'\nimport { useMemo } from 'preact/hooks'\n\nimport { useExtension } from '../hooks/use-extension'\n\n/**\n * @public\n */\nexport interface PreactMarkViewProps extends MarkViewContext {}\n\n/**\n * @public\n */\nexport type PreactMarkViewComponent = ComponentType<PreactMarkViewProps>\n\n/**\n * Options for {@link definePreactMarkView}.\n *\n * @public\n */\nexport interface PreactMarkViewOptions extends CoreMarkViewUserOptions<PreactMarkViewComponent> {\n  /**\n   * The name of the mark type.\n   */\n  name: string\n}\n\nfunction withMarkViewProps(component: PreactMarkViewComponent) {\n  return function MarkViewPropsWrapper() {\n    const props: PreactMarkViewProps = useMarkViewContext()\n    return h(component, props)\n  }\n}\n\n/**\n * @internal\n */\nexport const PreactMarkViewConsumer: FunctionComponent = () => {\n  const markViewFactory = useMarkViewFactory()\n  const extension = useMemo(\n    () => definePreactMarkViewFactory(markViewFactory),\n    [markViewFactory],\n  )\n  useExtension(extension)\n\n  return null\n}\n\n/**\n * Defines a mark view using a Preact component.\n *\n * @public\n */\nexport function definePreactMarkView(options: PreactMarkViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: PreactMarkViewUserOptions = {\n    ...userOptions,\n    component: withMarkViewProps(component),\n  }\n\n  return defineMarkViewComponent<PreactMarkViewUserOptions>({\n    group: 'preact',\n    name,\n    args,\n  })\n}\n\nfunction definePreactMarkViewFactory(\n  factory: (options: PreactMarkViewUserOptions) => MarkViewConstructor,\n) {\n  return defineMarkViewFactory<PreactMarkViewUserOptions>({\n    group: 'preact',\n    factory,\n  })\n}\n","import {\n  defineNodeViewComponent,\n  defineNodeViewFactory,\n  type Extension,\n} from '@prosekit/core'\nimport type { NodeViewConstructor } from '@prosekit/pm/view'\nimport type { CoreNodeViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useNodeViewContext,\n  useNodeViewFactory,\n  type NodeViewContext,\n  type PreactNodeViewUserOptions,\n} from '@prosemirror-adapter/preact'\nimport {\n  h,\n  type ComponentType,\n  type FunctionComponent,\n} from 'preact'\nimport { useMemo } from 'preact/hooks'\n\nimport { useExtension } from '../hooks/use-extension'\n\n/**\n * @public\n */\nexport interface PreactNodeViewProps extends NodeViewContext {}\n\n/**\n * @public\n */\nexport type PreactNodeViewComponent = ComponentType<PreactNodeViewProps>\n\n/**\n * Options for {@link definePreactNodeView}.\n *\n * @public\n */\nexport interface PreactNodeViewOptions extends CoreNodeViewUserOptions<PreactNodeViewComponent> {\n  /**\n   * The name of the node type.\n   */\n  name: string\n}\n\nfunction withNodeViewProps(component: PreactNodeViewComponent) {\n  return function NodeViewPropsWrapper() {\n    const props: PreactNodeViewProps = useNodeViewContext()\n    return h(component, props)\n  }\n}\n\n/**\n * @internal\n */\nexport const PreactNodeViewConsumer: FunctionComponent = () => {\n  const nodeViewFactory = useNodeViewFactory()\n  const extension = useMemo(\n    () => definePreactNodeViewFactory(nodeViewFactory),\n    [nodeViewFactory],\n  )\n  useExtension(extension)\n\n  return null\n}\n\n/**\n * Defines a node view using a Preact component.\n *\n * @public\n */\nexport function definePreactNodeView(options: PreactNodeViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: PreactNodeViewUserOptions = {\n    ...userOptions,\n    component: withNodeViewProps(component),\n  }\n\n  return defineNodeViewComponent<PreactNodeViewUserOptions>({\n    group: 'preact',\n    name,\n    args,\n  })\n}\n\nfunction definePreactNodeViewFactory(\n  factory: (options: PreactNodeViewUserOptions) => NodeViewConstructor,\n) {\n  return defineNodeViewFactory<PreactNodeViewUserOptions>({\n    group: 'preact',\n    factory,\n  })\n}\n","import type { Editor } from '@prosekit/core'\nimport { ProsemirrorAdapterProvider } from '@prosemirror-adapter/preact'\nimport {\n  h,\n  type ComponentChildren,\n  type ComponentType,\n} from 'preact'\n\nimport { EditorContextProvider } from '../contexts/editor-context'\nimport { PreactMarkViewConsumer } from '../extensions/preact-mark-view'\nimport { PreactNodeViewConsumer } from '../extensions/preact-node-view'\n\nexport interface ProseKitProps {\n  editor: Editor\n  children?: ComponentChildren\n}\n\n/**\n * The root component for a ProseKit editor.\n *\n * @public\n */\nexport const ProseKit: ComponentType<ProseKitProps> = (props) => {\n  const { editor, children } = props\n\n  return h(\n    EditorContextProvider,\n    { value: editor },\n    h(\n      ProsemirrorAdapterProvider,\n      null,\n      h(PreactNodeViewConsumer, null),\n      h(PreactMarkViewConsumer, null),\n      children,\n    ),\n  )\n}\n","import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n} from 'preact/hooks'\n\n/**\n * @internal\n */\nexport function useEventCallback<Args extends unknown[], Return>(\n  callback: (...args: Args) => Return,\n): (...args: Args) => Return {\n  const callbackRef = useRef(callback)\n  useLayoutEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n  return useCallback((...args: Args) => callbackRef.current(...args), [])\n}\n","import { defineDocChangeHandler } from '@prosekit/core'\nimport type { ProseMirrorNode } from '@prosekit/pm/model'\nimport { useMemo } from 'preact/hooks'\n\nimport { useEventCallback } from './use-event-callback'\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\n/**\n * Calls the given handler whenever the editor document changes.\n *\n * @public\n */\nexport function useDocChange(\n  handler: (doc: ProseMirrorNode) => void,\n  options?: UseExtensionOptions,\n): void {\n  const memoizedHandler = useEventCallback(handler)\n  const extension = useMemo(\n    () => defineDocChangeHandler((view) => memoizedHandler(view.state.doc)),\n    [memoizedHandler],\n  )\n  useExtension(extension, options)\n}\n","import {\n  defineMountHandler,\n  defineUpdateHandler,\n  ProseKitError,\n  union,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport {\n  useEffect,\n  useReducer,\n} from 'preact/hooks'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\n/**\n * Retrieves the editor instance from the nearest ProseKit component.\n *\n * @public\n */\nexport function useEditor<E extends Extension = any>(options?: {\n  /**\n   * Whether to update the component when the editor is mounted or editor state\n   * is updated.\n   *\n   * @default false\n   */\n  update?: boolean\n}): Editor<E> {\n  const update = options?.update ?? false\n\n  const editor = useEditorContext<E>()\n  if (!editor) {\n    throw new ProseKitError(\n      'useEditor must be used within the ProseKit component',\n    )\n  }\n\n  const forceUpdate = useForceUpdate()\n\n  useEffect(() => {\n    if (update) {\n      const extension = union(\n        defineMountHandler(forceUpdate),\n        defineUpdateHandler(forceUpdate),\n      )\n      return editor.use(extension)\n    }\n  }, [editor, update, forceUpdate])\n\n  return editor\n}\n\nfunction useForceUpdate() {\n  const [, dispatch] = useReducer((x: number) => x + 1, 0)\n  return dispatch\n}\n","import {\n  defineMountHandler,\n  defineUpdateHandler,\n  EditorNotFoundError,\n  union,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport { useSyncExternalStore } from 'preact/compat'\nimport { useMemo } from 'preact/hooks'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\nexport interface UseEditorDerivedOptions<E extends Extension = any> {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `<ProseKit>` component.\n   */\n  editor?: Editor<E>\n}\n\n/**\n * Runs a function to derive a value from the editor instance after editor state\n * changes.\n *\n * This is useful when you need to render something based on the editor state,\n * for example, whether the selected text is wrapped in an italic mark.\n *\n * It returns the derived value that updates whenever the editor state changes.\n *\n * @public\n */\nexport function useEditorDerivedValue<E extends Extension, Derived>(\n  /**\n   * A function that receives the editor instance and returns a derived value.\n   *\n   * It will be called whenever the editor's document state changes, or when it\n   * mounts.\n   *\n   * This function should be memoized.\n   */\n  derive: (editor: Editor<E>) => Derived,\n  options?: UseEditorDerivedOptions<E>,\n): Derived {\n  const editorContext = useEditorContext<E>()\n  const editor = options?.editor ?? editorContext\n  if (!editor) {\n    throw new EditorNotFoundError()\n  }\n\n  const [subscribe, getSnapshot] = useMemo(() => {\n    return createEditorStore(editor, derive)\n  }, [editor, derive])\n\n  return useSyncExternalStore(subscribe, getSnapshot)\n}\n\nfunction createEditorStore<Derived, E extends Extension = any>(editor: Editor<E>, derive: (editor: Editor<E>) => Derived) {\n  let dirty = true\n  let derived: Derived\n\n  const subscribe = (onChange: VoidFunction): VoidFunction => {\n    const handleChange = () => {\n      dirty = true\n      onChange()\n    }\n    const extension = union(\n      defineUpdateHandler(handleChange),\n      defineMountHandler(handleChange),\n    )\n    return editor.use(extension)\n  }\n\n  const getSnapshot = () => {\n    if (dirty) {\n      dirty = false\n      derived = derive(editor)\n    }\n    return derived\n  }\n\n  return [subscribe, getSnapshot] as const\n}\n","import {\n  defineKeymap,\n  type Keymap,\n} from '@prosekit/core'\nimport { useMemo } from 'preact/hooks'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\nexport function useKeymap(keymap: Keymap, options?: UseExtensionOptions): void {\n  const extension = useMemo(() => defineKeymap(keymap), [keymap])\n  useExtension(extension, options)\n}\n","import { defineUpdateHandler } from '@prosekit/core'\nimport type { EditorState } from '@prosekit/pm/state'\nimport { useMemo } from 'preact/hooks'\n\nimport { useEventCallback } from './use-event-callback'\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\n/**\n * Calls the given handler whenever the editor state changes.\n *\n * @public\n */\nexport function useStateUpdate(\n  handler: (state: EditorState) => void,\n  options?: UseExtensionOptions,\n): void {\n  const memoizedHandler = useEventCallback(handler)\n  const extension = useMemo(\n    () => defineUpdateHandler((view) => memoizedHandler(view.state)),\n    [memoizedHandler],\n  )\n  useExtension(extension, options)\n}\n"],"mappings":"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"}