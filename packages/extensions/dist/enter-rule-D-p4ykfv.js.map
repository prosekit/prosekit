{"version":3,"file":"enter-rule-D-p4ykfv.js","names":["regex: RegExp","handler: EnterRuleHandler","stop: boolean","rules: EnterRule[]","command: Command"],"sources":["../src/enter-rule/index.ts"],"sourcesContent":["import {\n  defineFacet,\n  defineFacetPayload,\n  getNodeType,\n  isTextSelection,\n  maybeRun,\n  OBJECT_REPLACEMENT_CHARACTER,\n  pluginFacet,\n  type PlainExtension,\n  type PluginPayload,\n} from '@prosekit/core'\nimport { keydownHandler } from '@prosekit/pm/keymap'\nimport type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport {\n  PluginKey,\n  ProseMirrorPlugin,\n  type Command,\n  type EditorState,\n  type Transaction,\n} from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\n\n/**\n * @public\n *\n * Options for {@link EnterRuleHandler}.\n */\nexport interface EnterRuleHandlerOptions {\n  /**\n   * The current editor state.\n   */\n  state: EditorState\n\n  /**\n   * The start position of the matched text.\n   */\n  from: number\n\n  /**\n   * The end position of the matched text.\n   */\n  to: number\n\n  /**\n   * The matched result from the regular expression.\n   */\n  match: RegExpExecArray\n}\n\n/**\n * @public\n */\nexport type EnterRuleHandler = (options: EnterRuleHandlerOptions) => Transaction | null\n\n/**\n * Options for {@link defineEnterRule}.\n *\n * @public\n */\nexport type EnterRuleOptions = {\n  /**\n   * The regular expression to match against. It should end with `$`.\n   */\n  regex: RegExp\n\n  /**\n   * A function to be called when an enter rule is triggered.\n   */\n  handler: EnterRuleHandler\n\n  /**\n   * Whether to stop further handlers from being called if this rule is triggered.\n   *\n   * @default false\n   */\n  stop?: boolean\n}\n\n/**\n * Options for {@link defineTextBlockEnterRule}.\n *\n * @public\n */\nexport interface TextBlockEnterRuleOptions {\n  /**\n   * The regular expression to match against. It should end with `$`.\n   */\n  regex: RegExp\n\n  /**\n   * The node type to replace the matched text with.\n   */\n  type: string | NodeType\n\n  /**\n   * Attributes to set on the node. If a function is provided, it will be called\n   * with the matched result from the regular expression.\n   */\n  attrs?: Attrs | null | ((match: RegExpMatchArray) => Attrs | null)\n\n  /**\n   * Whether to stop further handlers from being called if this rule is triggered.\n   *\n   * @default true\n   */\n  stop?: boolean\n}\n\n/**\n * Defines an enter rule. An enter rule applies when the text directly in front of\n * the cursor matches `regex` and user presses Enter. The `regex` should end\n * with `$`.\n *\n * @param options\n *\n * @public\n */\nexport function defineEnterRule({\n  regex,\n  handler,\n  stop = false,\n}: EnterRuleOptions): PlainExtension {\n  const rule: EnterRule = new EnterRule(regex, handler, stop)\n  return defineFacetPayload(enterRule, [rule]) as PlainExtension\n}\n\n/**\n * Defines an enter rule that replaces the matched text with a block node.\n *\n * See also {@link defineEnterRule}.\n *\n * @param options\n *\n * @public\n */\nexport function defineTextBlockEnterRule({\n  regex,\n  type,\n  attrs,\n  stop = true,\n}: TextBlockEnterRuleOptions): PlainExtension {\n  return defineEnterRule({\n    regex,\n    handler: ({ state, from, to, match }) => {\n      const nodeType = getNodeType(state.schema, type)\n      const $start = state.doc.resolve(from)\n\n      if (\n        !$start\n          .node(-1)\n          .canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)\n      ) {\n        return null\n      }\n\n      const nodeAttrs = maybeRun(attrs, match)\n      return state.tr\n        .delete(from, to)\n        .setBlockType(from, from, nodeType, nodeAttrs)\n    },\n    stop,\n  })\n}\n\n/**\n * @internal\n */\nclass EnterRule {\n  constructor(\n    readonly regex: RegExp,\n    readonly handler: EnterRuleHandler,\n    readonly stop: boolean,\n  ) {}\n}\n\nconst enterRule = defineFacet<EnterRule, PluginPayload>({\n  reduce: () => {\n    let rules: EnterRule[] = []\n\n    const command: Command = (state, dispatch, view) => {\n      if (!view) return false\n      return execRules(view, rules, dispatch)\n    }\n    const handler = keydownHandler({ Enter: command })\n    const plugin = new ProseMirrorPlugin({\n      key: new PluginKey('prosekit-enter-rule'),\n      props: { handleKeyDown: handler },\n    })\n\n    return function reducer(inputs) {\n      rules = inputs\n      return plugin\n    }\n  },\n\n  parent: pluginFacet,\n})\n\nfunction execRules(\n  view: EditorView,\n  rules: readonly EnterRule[],\n  dispatch?: (tr: Transaction) => void,\n): boolean {\n  if (view.composing) return false\n  const state = view.state\n  const selection = state.selection\n  if (!isTextSelection(selection)) return false\n  const $cursor = selection.$cursor\n  if (!$cursor || $cursor.parent.type.spec.code) return false\n\n  const textBefore = $cursor.parent.textBetween(\n    Math.max(0, $cursor.parentOffset - MAX_MATCH),\n    $cursor.parentOffset,\n    null,\n    OBJECT_REPLACEMENT_CHARACTER,\n  )\n\n  for (const rule of rules) {\n    rule.regex.lastIndex = 0\n    const match = rule.regex.exec(textBefore)\n    const tr = match\n      && rule.handler({\n        state,\n        from: $cursor.pos - match[0].length,\n        to: $cursor.pos,\n        match,\n      })\n    if (!tr) continue\n    dispatch?.(tr)\n\n    if (rule.stop) {\n      return true\n    }\n  }\n  return false\n}\n\nconst MAX_MATCH = 200\n"],"mappings":";;;;;;;;;;;;;;AAwHA,SAAgB,gBAAgB,EAC9B,OACA,SACA,OAAO,SAC4B;AAEnC,QAAO,mBAAmB,WAAW,CADb,IAAI,UAAU,OAAO,SAAS,KAAK,CAChB,CAAC;;;;;;;;;;;AAY9C,SAAgB,yBAAyB,EACvC,OACA,MACA,OACA,OAAO,QACqC;AAC5C,QAAO,gBAAgB;EACrB;EACA,UAAU,EAAE,OAAO,MAAM,IAAI,YAAY;GACvC,MAAM,WAAW,YAAY,MAAM,QAAQ,KAAK;GAChD,MAAM,SAAS,MAAM,IAAI,QAAQ,KAAK;AAEtC,OACE,CAAC,OACE,KAAK,GAAG,CACR,eAAe,OAAO,MAAM,GAAG,EAAE,OAAO,WAAW,GAAG,EAAE,SAAS,CAEpE,QAAO;GAGT,MAAM,YAAY,SAAS,OAAO,MAAM;AACxC,UAAO,MAAM,GACV,OAAO,MAAM,GAAG,CAChB,aAAa,MAAM,MAAM,UAAU,UAAU;;EAElD;EACD,CAAC;;;;;AAMJ,IAAM,YAAN,MAAgB;CACd,YACE,AAASA,OACT,AAASC,SACT,AAASC,MACT;EAHS;EACA;EACA;;;AAIb,MAAM,YAAY,YAAsC;CACtD,cAAc;EACZ,IAAIC,QAAqB,EAAE;EAE3B,MAAMC,WAAoB,OAAO,UAAU,SAAS;AAClD,OAAI,CAAC,KAAM,QAAO;AAClB,UAAO,UAAU,MAAM,OAAO,SAAS;;EAEzC,MAAM,UAAU,eAAe,EAAE,OAAO,SAAS,CAAC;EAClD,MAAM,SAAS,IAAI,kBAAkB;GACnC,KAAK,IAAI,UAAU,sBAAsB;GACzC,OAAO,EAAE,eAAe,SAAS;GAClC,CAAC;AAEF,SAAO,SAAS,QAAQ,QAAQ;AAC9B,WAAQ;AACR,UAAO;;;CAIX,QAAQ;CACT,CAAC;AAEF,SAAS,UACP,MACA,OACA,UACS;AACT,KAAI,KAAK,UAAW,QAAO;CAC3B,MAAM,QAAQ,KAAK;CACnB,MAAM,YAAY,MAAM;AACxB,KAAI,CAAC,gBAAgB,UAAU,CAAE,QAAO;CACxC,MAAM,UAAU,UAAU;AAC1B,KAAI,CAAC,WAAW,QAAQ,OAAO,KAAK,KAAK,KAAM,QAAO;CAEtD,MAAM,aAAa,QAAQ,OAAO,YAChC,KAAK,IAAI,GAAG,QAAQ,eAAe,UAAU,EAC7C,QAAQ,cACR,MACA,6BACD;AAED,MAAK,MAAM,QAAQ,OAAO;AACxB,OAAK,MAAM,YAAY;EACvB,MAAM,QAAQ,KAAK,MAAM,KAAK,WAAW;EACzC,MAAM,KAAK,SACN,KAAK,QAAQ;GACd;GACA,MAAM,QAAQ,MAAM,MAAM,GAAG;GAC7B,IAAI,QAAQ;GACZ;GACD,CAAC;AACJ,MAAI,CAAC,GAAI;AACT,aAAW,GAAG;AAEd,MAAI,KAAK,KACP,QAAO;;AAGX,QAAO;;AAGT,MAAM,YAAY"}