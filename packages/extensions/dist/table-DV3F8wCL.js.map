{"version":3,"file":"table-DV3F8wCL.js","names":["exitTable: Command","onDrag: DragEventHandler","match: boolean"],"sources":["../src/table/table-commands/exit-table.ts","../src/table/table-commands/insert-table.ts","../src/table/table-utils.ts","../src/table/table-commands/select-table.ts","../src/table/table-commands/select-table-cell.ts","../src/table/table-commands/select-table-column.ts","../src/table/table-commands/select-table-row.ts","../src/table/table-commands.ts","../src/table/table-drop-indicator.ts","../src/table/table-plugins.ts","../src/table/table-spec.ts","../src/table/table.ts"],"sourcesContent":["import { defaultBlockAt } from '@prosekit/core'\nimport { TextSelection } from '@prosekit/pm/state'\nimport type { Command } from '@prosekit/pm/state'\nimport type { TableRole } from 'prosemirror-tables'\n\n/**\n * When the selection is in a table node, create a default block after the table\n * table, and move the cursor there.\n *\n * @public\n */\nexport const exitTable: Command = (state, dispatch) => {\n  const { $head, $anchor } = state.selection\n\n  if (!$head.sameParent($anchor)) {\n    return false\n  }\n\n  let tableStart = -1\n  let tableDepth = -1\n  for (let depth = $head.depth; depth >= 0; depth--) {\n    const node = $head.node(depth)\n    if ((node.type.spec.tableRole as TableRole) === 'table') {\n      tableStart = $head.before(depth)\n      tableDepth = depth\n    }\n  }\n\n  if (tableStart < 0 || tableDepth <= 0) {\n    return false\n  }\n\n  const above = $head.node(tableDepth - 1)\n  const after = $head.indexAfter(tableDepth - 1)\n  const type = defaultBlockAt(above.contentMatchAt(after))\n  const node = type?.createAndFill()\n\n  if (!type || !node || !above.canReplaceWith(after, after, type)) {\n    return false\n  }\n\n  if (dispatch) {\n    const pos = $head.after(tableDepth)\n    const tr = state.tr.replaceWith(pos, pos, node)\n    tr.setSelection(TextSelection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n","import {\n  getNodeType,\n  insertNode,\n} from '@prosekit/core'\nimport type { Schema } from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nfunction createEmptyTable(\n  schema: Schema,\n  row: number,\n  col: number,\n  header: boolean,\n) {\n  const tableType = getNodeType(schema, 'table')\n  const tableRowType = getNodeType(schema, 'tableRow')\n  const tableCellType = getNodeType(schema, 'tableCell')\n  const tableHeaderCellType = getNodeType(schema, 'tableHeaderCell')\n\n  if (header) {\n    const headerCell = tableHeaderCellType.createAndFill()!\n    const headerCells = repeat(headerCell, col)\n    const headerRow = tableRowType.createAndFill(null, headerCells)!\n\n    const bodyCell = tableCellType.createAndFill()!\n    const bodyCells = repeat(bodyCell, col)\n    const bodyRow = tableRowType.createAndFill(null, bodyCells)!\n    const bodyRows = repeat(bodyRow, row - 1)\n\n    return tableType.createAndFill(null, [headerRow, ...bodyRows])!\n  } else {\n    const bodyCell = tableCellType.createAndFill()!\n    const bodyCells = repeat(bodyCell, col)\n    const bodyRow = tableRowType.createAndFill(null, bodyCells)!\n    const bodyRows = repeat(bodyRow, row)\n\n    return tableType.createAndFill(null, bodyRows)!\n  }\n}\n\nfunction repeat<T>(node: T, length: number): T[] {\n  return Array<T>(length).fill(node)\n}\n\n/**\n * @public\n */\nexport interface InsertTableOptions {\n  /**\n   * The number of rows in the table.\n   */\n  row: number\n\n  /**\n   * The number of columns in the table.\n   */\n  col: number\n\n  /**\n   * Whether the table has a header row.\n   *\n   * @default false\n   */\n  header?: boolean\n}\n\n/**\n * Insert a table node with the given number of rows and columns, and optionally\n * a header row.\n *\n * @param options\n *\n * @public\n */\nexport function insertTable(options: InsertTableOptions): Command {\n  return (state, dispatch, view) => {\n    const { row, col, header = false } = options\n    const table = createEmptyTable(state.schema, row, col, header)\n    return insertNode({ node: table })(state, dispatch, view)\n  }\n}\n","import { CellSelection } from 'prosemirror-tables'\n\nexport {\n  findCellPos,\n  findCellRange,\n  findTable,\n} from 'prosemirror-tables'\n\n/**\n * Checks if the given object is a `CellSelection` instance.\n *\n * @public\n */\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n","import type { Command } from '@prosekit/pm/state'\nimport {\n  CellSelection,\n  TableMap,\n} from 'prosemirror-tables'\n\nimport { findTable } from '../table-utils'\n\n/**\n * @public\n */\nexport interface SelectTableOptions {\n  /**\n   * A hit position of the table to select from. By default, the selection\n   * anchor will be used.\n   */\n  pos?: number\n}\n\n/**\n * @public\n */\nexport function selectTable(options?: SelectTableOptions): Command {\n  return (state, dispatch) => {\n    const $pos = options?.pos\n      ? state.doc.resolve(options.pos)\n      : state.selection.$anchor\n    const table = findTable($pos)\n    if (!table) {\n      return false\n    }\n    const map = TableMap.get(table.node)\n    if (map.map.length === 0) {\n      return false\n    }\n    if (dispatch) {\n      let tr = state.tr\n      const firstCellPosInTable = map.map[0]\n      const lastCellPosInTable = map.map[map.map.length - 1]\n      const firstCellPos = table.pos + firstCellPosInTable + 1\n      const lastCellPos = table.pos + lastCellPosInTable + 1\n      const $firstCellPos = tr.doc.resolve(firstCellPos)\n      const $lastCellPos = tr.doc.resolve(lastCellPos)\n      const selection = new CellSelection($firstCellPos, $lastCellPos)\n      tr = tr.setSelection(selection)\n      dispatch?.(tr)\n    }\n    return true\n  }\n}\n","import type { Command } from '@prosekit/pm/state'\nimport { CellSelection } from 'prosemirror-tables'\n\nimport { findCellPos } from '../table-utils'\n\n/**\n * @public\n */\nexport interface SelectTableCellOptions {\n  /**\n   * A hit position of the table cell to select from. By default, the selection\n   * anchor will be used.\n   */\n  pos?: number\n}\n\n/**\n * @public\n */\nexport function selectTableCell(options?: SelectTableCellOptions): Command {\n  return (state, dispatch) => {\n    const $cellPos = findCellPos(\n      state.doc,\n      options?.pos ?? state.selection.anchor,\n    )\n    if (!$cellPos) {\n      return false\n    }\n    if (dispatch) {\n      const selection = new CellSelection($cellPos)\n      dispatch(state.tr.setSelection(selection))\n    }\n    return true\n  }\n}\n","import type { Command } from '@prosekit/pm/state'\nimport { CellSelection } from 'prosemirror-tables'\n\nimport { findCellRange } from '../table-utils'\n\n/**\n * @public\n */\nexport interface SelectTableColumnOptions {\n  /**\n   * A hit position of the table cell to select from. By default, the selection\n   * anchor will be used.\n   */\n  anchor?: number\n\n  /**\n   * A hit position of the table cell to select to. By default, the selection\n   * head will be used.\n   */\n  head?: number\n}\n\n/**\n * @public\n */\nexport function selectTableColumn(options?: SelectTableColumnOptions): Command {\n  return (state, dispatch) => {\n    const range = findCellRange(state.selection, options?.anchor, options?.head)\n    if (!range) {\n      return false\n    }\n    if (dispatch) {\n      const [$anchorCell, $headCell] = range\n      const selection = CellSelection.colSelection($anchorCell, $headCell)\n      dispatch(state.tr.setSelection(selection))\n    }\n    return true\n  }\n}\n","import type { Command } from '@prosekit/pm/state'\nimport { CellSelection } from 'prosemirror-tables'\n\nimport { findCellRange } from '../table-utils'\n\n/**\n * @public\n */\nexport interface SelectTableRowOptions {\n  /**\n   * A hit position of the table cell to select from. By default, the selection\n   * anchor will be used.\n   */\n  anchor?: number\n\n  /**\n   * A hit position of the table cell to select to. By default, the selection\n   * head will be used.\n   */\n  head?: number\n}\n\n/**\n * @public\n */\nexport function selectTableRow(options?: SelectTableRowOptions): Command {\n  return (state, dispatch) => {\n    const range = findCellRange(state.selection, options?.anchor, options?.head)\n    if (!range) {\n      return false\n    }\n    if (dispatch) {\n      const [$anchorCell, $headCell] = range\n      const selection = CellSelection.rowSelection($anchorCell, $headCell)\n      dispatch(state.tr.setSelection(selection))\n    }\n    return true\n  }\n}\n","import {\n  defineCommands,\n  type Extension,\n} from '@prosekit/core'\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  mergeCells,\n  splitCell,\n} from 'prosemirror-tables'\n\nimport { deleteCellSelection } from './table-commands/delete-cell-selection'\nimport { exitTable } from './table-commands/exit-table'\nimport {\n  insertTable,\n  type InsertTableOptions,\n} from './table-commands/insert-table'\nimport {\n  moveTableColumn,\n  type MoveTableColumnOptions,\n} from './table-commands/move-table-column'\nimport {\n  moveTableRow,\n  type MoveTableRowOptions,\n} from './table-commands/move-table-row'\nimport {\n  selectTable,\n  type SelectTableOptions,\n} from './table-commands/select-table'\nimport {\n  selectTableCell,\n  type SelectTableCellOptions,\n} from './table-commands/select-table-cell'\nimport {\n  selectTableColumn,\n  type SelectTableColumnOptions,\n} from './table-commands/select-table-column'\nimport {\n  selectTableRow,\n  type SelectTableRowOptions,\n} from './table-commands/select-table-row'\n\n/**\n * @internal\n */\nexport type TableCommandsExtension = Extension<{\n  Commands: {\n    insertTable: [options: InsertTableOptions]\n    exitTable: []\n\n    selectTable: [options?: SelectTableOptions]\n    selectTableCell: [options?: SelectTableCellOptions]\n    selectTableColumn: [options?: SelectTableColumnOptions]\n    selectTableRow: [options?: SelectTableRowOptions]\n\n    addTableColumnBefore: []\n    addTableColumnAfter: []\n    addTableRowAbove: []\n    addTableRowBelow: []\n\n    deleteTable: []\n    deleteTableColumn: []\n    deleteTableRow: []\n    deleteCellSelection: []\n\n    mergeTableCells: []\n    splitTableCell: []\n\n    moveTableRow: [options: MoveTableRowOptions]\n    moveTableColumn: [options: MoveTableColumnOptions]\n  }\n}>\n\n/**\n * Adds commands for working with `table` nodes.\n *\n * @public\n */\nexport function defineTableCommands(): TableCommandsExtension {\n  return defineCommands({\n    insertTable,\n    exitTable: () => exitTable,\n\n    selectTable,\n    selectTableCell,\n    selectTableColumn,\n    selectTableRow,\n\n    addTableColumnBefore: () => addColumnBefore,\n    addTableColumnAfter: () => addColumnAfter,\n    addTableRowAbove: () => addRowBefore,\n    addTableRowBelow: () => addRowAfter,\n\n    deleteTable: () => deleteTable,\n    deleteTableColumn: () => deleteColumn,\n    deleteTableRow: () => deleteRow,\n    deleteCellSelection: () => deleteCellSelection,\n\n    mergeTableCells: () => mergeCells,\n    splitTableCell: () => splitCell,\n\n    moveTableRow,\n    moveTableColumn,\n  })\n}\n","import type { PlainExtension } from '@prosekit/core'\n\nimport type { DragEventHandler } from '../drop-indicator'\nimport { defineDropIndicator } from '../drop-indicator'\n\n/**\n * Hides the drop indicator when dragging a table column or row by using the\n * table handle.\n *\n * @internal\n */\nexport function defineTableDropIndicator(): PlainExtension {\n  return defineDropIndicator({\n    onDrag,\n  })\n}\n\nconst matchMap = new WeakMap<DataTransfer, boolean>()\n\nconst onDrag: DragEventHandler = ({ event }): boolean => {\n  const dataTransfer = event.dataTransfer\n  if (!dataTransfer) return true\n\n  let match: boolean\n\n  if (matchMap.has(dataTransfer)) {\n    match = matchMap.get(dataTransfer)!\n  } else {\n    // On Safari, accessing `dataTransfer.types` is more than 10x slower than in\n    // Chrome. This becomes a bottleneck when `onDrag` is called frequently, so\n    // we cache the result in a WeakMap.\n    const types = dataTransfer.types\n    match = types.includes('application/x-prosekit-table-handle-drag')\n    matchMap.set(dataTransfer, match)\n  }\n\n  // Don't show the drop indicator when the drag event has\n  // \"application/x-prosekit-table-handle-drag\" type.\n  return !match\n}\n","import {\n  definePlugin,\n  type PlainExtension,\n} from '@prosekit/core'\nimport {\n  columnResizing,\n  tableEditing,\n} from 'prosemirror-tables'\n\n/**\n * @public\n */\nexport function defineTablePlugins(): PlainExtension {\n  return definePlugin([tableEditing(), columnResizing()])\n}\n","import {\n  defineNodeSpec,\n  type Extension,\n} from '@prosekit/core'\nimport type {\n  AttributeSpec,\n  Attrs,\n} from '@prosekit/pm/model'\nimport { tableNodes } from 'prosemirror-tables'\n\nconst cellContent = 'block+'\n\n/**\n * @public\n */\nexport interface CellAttrs {\n  colspan?: number\n  rowspan?: number\n  colwidth?: number[] | null\n}\n\nconst cellAttrs = {\n  colspan: { default: 1 },\n  rowspan: { default: 1 },\n  colwidth: { default: null },\n} satisfies Record<string, AttributeSpec>\n\n/**\n * @internal\n */\nexport type TableSpecExtension = Extension<{\n  Nodes: {\n    table: Attrs\n  }\n}>\n\nconst specs = tableNodes({\n  tableGroup: 'block',\n  cellContent,\n  cellAttributes: {},\n})\n\n/**\n * @internal\n */\nexport function defineTableSpec(): TableSpecExtension {\n  return defineNodeSpec({\n    ...specs['table'],\n    content: 'tableRow+',\n    name: 'table',\n  })\n}\n\n/**\n * @internal\n */\nexport type TableRowSpecExtension = Extension<{\n  Nodes: {\n    tableRow: Attrs\n  }\n}>\n\n/**\n * @internal\n */\nexport function defineTableRowSpec(): TableRowSpecExtension {\n  return defineNodeSpec({\n    ...specs['table_row'],\n    content: '(tableCell | tableHeaderCell)*',\n    name: 'tableRow',\n  })\n}\n\n/**\n * @internal\n */\nexport type TableCellSpecExtension = Extension<{\n  Nodes: {\n    tableCell: CellAttrs\n  }\n}>\n\n/**\n * @internal\n */\nexport function defineTableCellSpec(): TableCellSpecExtension {\n  return defineNodeSpec({\n    ...specs['table_cell'],\n    name: 'tableCell',\n    attrs: cellAttrs,\n  })\n}\n\n/**\n * @internal\n */\nexport type TableHeaderCellSpecExtension = Extension<{\n  Nodes: {\n    tableHeaderCell: CellAttrs\n  }\n}>\n\nexport function defineTableHeaderCellSpec(): TableHeaderCellSpecExtension {\n  return defineNodeSpec({\n    ...specs['table_header'],\n    name: 'tableHeaderCell',\n    attrs: cellAttrs,\n  })\n}\n","import {\n  union,\n  type Union,\n} from '@prosekit/core'\n\nimport {\n  defineTableCommands,\n  type TableCommandsExtension,\n} from './table-commands'\nimport { defineTableDropIndicator } from './table-drop-indicator'\nimport { defineTablePlugins } from './table-plugins'\nimport {\n  defineTableCellSpec,\n  defineTableHeaderCellSpec,\n  defineTableRowSpec,\n  defineTableSpec,\n  type TableCellSpecExtension,\n  type TableHeaderCellSpecExtension,\n  type TableRowSpecExtension,\n  type TableSpecExtension,\n} from './table-spec'\n\n/**\n * @internal\n */\nexport type TableExtension = Union<\n  [\n    TableSpecExtension,\n    TableRowSpecExtension,\n    TableCellSpecExtension,\n    TableHeaderCellSpecExtension,\n    TableCommandsExtension,\n  ]\n>\n\n/**\n * @public\n */\nexport function defineTable(): TableExtension {\n  return union(\n    defineTableSpec(),\n    defineTableRowSpec(),\n    defineTableCellSpec(),\n    defineTableHeaderCellSpec(),\n    defineTablePlugins(),\n    defineTableCommands(),\n    defineTableDropIndicator(),\n  )\n}\n"],"mappings":"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"}