{"version":3,"file":"prosekit-extensions-file.js","names":["getFiles","facet","getFiles","dropHandler: DropHandler","pasteHandler: PasteHandler"],"sources":["../src/file/helpers.ts","../src/file/file-drop-handler.ts","../src/file/file-paste-handler.ts","../src/file/file-upload.ts"],"sourcesContent":["import type { EditorView } from '@prosekit/pm/view'\n\ntype FileHandler<E extends Event> = (options: {\n  view: EditorView\n  event: E\n  file: File\n}) => boolean | void\n\nfunction handleFile<E extends Event>(\n  view: EditorView,\n  event: E,\n  file: File,\n  handlers: FileHandler<E>[],\n) {\n  // The last item in `handlers` should has the highest priority.\n  for (let i = handlers.length - 1; i >= 0; i--) {\n    const handler = handlers[i]\n    if (handler({ view, event, file })) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function handleEvent<E extends Event>(\n  view: EditorView,\n  event: E,\n  handlers: FileHandler<E>[],\n  getFiles: (event: E) => File[],\n): boolean {\n  const files = getFiles(event)\n  let handled = false\n  for (const file of files) {\n    if (handleFile(view, event, file, handlers)) {\n      handled = true\n    }\n  }\n  return handled\n}\n","import {\n  defineFacet,\n  defineFacetPayload,\n  editorEventFacet,\n  type DropHandler,\n  type EditorEventPayload,\n  type PlainExtension,\n} from '@prosekit/core'\nimport type { EditorView } from '@prosekit/pm/view'\n\nimport { handleEvent } from './helpers'\n\nexport interface FileDropHandlerOptions {\n  /**\n   * The editor view.\n   */\n  view: EditorView\n\n  /**\n   * The event that triggered the drop.\n   */\n  event: DragEvent\n\n  /**\n   * The file that was dropped.\n   */\n  file: File\n\n  /**\n   * The position of the document where the file was dropped.\n   */\n  pos: number\n}\n\n/**\n * A function that handles one of the files in a drop event.\n *\n * Returns `true` if the file was handled and thus should not be handled by\n * other handlers.\n */\nexport type FileDropHandler = (\n  options: FileDropHandlerOptions,\n) => boolean | void\n\nexport function defineFileDropHandler(\n  handler: FileDropHandler,\n): PlainExtension {\n  return defineFacetPayload(facet, [handler]) as PlainExtension\n}\n\nfunction getFiles(event: DragEvent) {\n  return Array.from(event.dataTransfer?.files ?? [])\n}\n\nconst facet = defineFacet<FileDropHandler, EditorEventPayload>({\n  parent: editorEventFacet,\n  singleton: true,\n  reducer: (handlers: FileDropHandler[]): EditorEventPayload => {\n    const dropHandler: DropHandler = (view, event): boolean => {\n      const position = view.posAtCoords({ left: event.x, top: event.y })\n      if (!position) {\n        return false\n      }\n      const pos = position.inside > 0 ? position.inside : position.pos\n\n      return handleEvent<DragEvent>(\n        view,\n        event,\n        handlers.map((handler) => (options) => handler({ ...options, pos })),\n        getFiles,\n      )\n    }\n    return ['drop', dropHandler]\n  },\n})\n","import {\n  defineFacet,\n  defineFacetPayload,\n  editorEventFacet,\n  type EditorEventPayload,\n  type PasteHandler,\n  type PlainExtension,\n} from '@prosekit/core'\nimport type { EditorView } from '@prosekit/pm/view'\n\nimport { handleEvent } from './helpers'\n\nexport interface FilePasteHandlerOptions {\n  /**\n   * The editor view.\n   */\n  view: EditorView\n\n  /**\n   * The event that triggered the paste.\n   */\n  event: ClipboardEvent\n\n  /**\n   * The file that was pasted.\n   */\n  file: File\n}\n\n/**\n * A function that handles one of the files in a paste event.\n *\n * Returns `true` if the file was handled and thus should not be handled by\n * other handlers.\n */\nexport type FilePasteHandler = (\n  options: FilePasteHandlerOptions,\n) => boolean | void\n\nexport function defineFilePasteHandler(\n  handler: FilePasteHandler,\n): PlainExtension {\n  return defineFacetPayload(facet, [handler]) as PlainExtension\n}\n\nfunction getFiles(event: ClipboardEvent) {\n  return Array.from(event.clipboardData?.files ?? [])\n}\n\nconst facet = defineFacet<FilePasteHandler, EditorEventPayload>({\n  parent: editorEventFacet,\n  singleton: true,\n  reducer: (handlers: FilePasteHandler[]): EditorEventPayload => {\n    const pasteHandler: PasteHandler = (view, event): boolean => {\n      return handleEvent<ClipboardEvent>(view, event, handlers, getFiles)\n    }\n    return ['paste', pasteHandler]\n  },\n})\n","/**\n * An interface representing the upload progress.\n */\nexport interface UploadProgress {\n  // A number representing the amount of work already performed by the\n  // underlying process.\n  loaded: number\n  // A number representing the total amount of work that the underlying\n  // process is in the progress of performing.\n  total: number\n}\n\nexport interface UploaderOptions {\n  /**\n   * The file to be uploaded.\n   */\n  file: File\n\n  /**\n   * A callback function that should be called with the upload progress updates.\n   */\n  onProgress: (progress: UploadProgress) => void\n}\n\n/**\n * The implementation of the actual upload function. You need to implement this\n * function to upload files to your desired destination.\n */\nexport type Uploader<Result> = (options: UploaderOptions) => Promise<Result>\n\n/**\n * A class that represents a upload task.\n */\nexport class UploadTask<Result> {\n  /**\n   * An [object URL](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL)\n   * representing the file to be uploaded. This URL will be revoked once the\n   * upload is complete successfully.\n   */\n  readonly objectURL: string\n\n  /**\n   * A boolean indicating whether the upload is complete (either successfully or with an error).\n   */\n  protected done = false\n\n  /**\n   * A promise that fulfills once the upload is complete, or rejects if an error occurs.\n   */\n  readonly finished: Promise<Result>\n\n  private subscribers: ((progress: UploadProgress) => void)[] = []\n\n  /**\n   * Creates a new upload task. You can find the upload task by its object URL\n   * later using `UploadTask.get()`.\n   *\n   * @param options - The options for the upload task.\n   */\n  constructor({ file, uploader }: { file: File; uploader: Uploader<Result> }) {\n    this.objectURL = URL.createObjectURL(file)\n    this.finished = new Promise((resolve, reject) => {\n      const maybePromise = uploader({\n        file,\n        onProgress: (progress) => {\n          for (const subscriber of this.subscribers) {\n            subscriber(progress)\n          }\n        },\n      })\n      Promise.resolve(maybePromise).then(\n        (result) => {\n          this.done = true\n          URL.revokeObjectURL(this.objectURL)\n          resolve(result)\n        },\n        (error) => {\n          this.done = true\n          reject(\n            new Error('[prosekit] Failed to upload file', { cause: error }),\n          )\n        },\n      )\n    })\n    store.set(this.objectURL, this)\n  }\n\n  /**\n   * Subscribes to progress updates. Returns a function to unsubscribe.\n   */\n  public subscribeProgress(\n    callback: (progress: UploadProgress) => void,\n  ): VoidFunction {\n    this.subscribers.push(callback)\n    return () => {\n      this.subscribers = this.subscribers.filter(\n        (subscriber) => subscriber !== callback,\n      )\n    }\n  }\n\n  /**\n   * Finds an upload task by its object URL.\n   */\n  static get<Result = unknown>(\n    objectURL: string,\n  ): UploadTask<Result> | undefined {\n    return store.get(objectURL) as UploadTask<Result> | undefined\n  }\n\n  /**\n   * Deletes an upload task by its object URL.\n   */\n  static delete(objectURL: string): void {\n    store.delete(objectURL)\n  }\n}\n\nconst store = new Map<string, UploadTask<unknown>>()\n"],"mappings":";;;AAQA,SAAS,WACP,MACA,OACA,MACA,UACA;AAEA,MAAK,IAAI,IAAI,SAAS,SAAS,GAAG,KAAK,GAAG,KAAK;EAC7C,MAAM,UAAU,SAAS;AACzB,MAAI,QAAQ;GAAE;GAAM;GAAO;GAAM,CAAC,CAChC,QAAO;;AAGX,QAAO;;AAGT,SAAgB,YACd,MACA,OACA,UACA,YACS;CACT,MAAM,QAAQA,WAAS,MAAM;CAC7B,IAAI,UAAU;AACd,MAAK,MAAM,QAAQ,MACjB,KAAI,WAAW,MAAM,OAAO,MAAM,SAAS,CACzC,WAAU;AAGd,QAAO;;;;;ACOT,SAAgB,sBACd,SACgB;AAChB,QAAO,mBAAmBC,SAAO,CAAC,QAAQ,CAAC;;AAG7C,SAASC,WAAS,OAAkB;AAClC,QAAO,MAAM,KAAK,MAAM,cAAc,SAAS,EAAE,CAAC;;AAGpD,MAAMD,UAAQ,YAAiD;CAC7D,QAAQ;CACR,WAAW;CACX,UAAU,aAAoD;EAC5D,MAAME,eAA4B,MAAM,UAAmB;GACzD,MAAM,WAAW,KAAK,YAAY;IAAE,MAAM,MAAM;IAAG,KAAK,MAAM;IAAG,CAAC;AAClE,OAAI,CAAC,SACH,QAAO;GAET,MAAM,MAAM,SAAS,SAAS,IAAI,SAAS,SAAS,SAAS;AAE7D,UAAO,YACL,MACA,OACA,SAAS,KAAK,aAAa,YAAY,QAAQ;IAAE,GAAG;IAAS;IAAK,CAAC,CAAC,EACpED,WACD;;AAEH,SAAO,CAAC,QAAQ,YAAY;;CAE/B,CAAC;;;;ACnCF,SAAgB,uBACd,SACgB;AAChB,QAAO,mBAAmB,OAAO,CAAC,QAAQ,CAAC;;AAG7C,SAAS,SAAS,OAAuB;AACvC,QAAO,MAAM,KAAK,MAAM,eAAe,SAAS,EAAE,CAAC;;AAGrD,MAAM,QAAQ,YAAkD;CAC9D,QAAQ;CACR,WAAW;CACX,UAAU,aAAqD;EAC7D,MAAME,gBAA8B,MAAM,UAAmB;AAC3D,UAAO,YAA4B,MAAM,OAAO,UAAU,SAAS;;AAErE,SAAO,CAAC,SAAS,aAAa;;CAEjC,CAAC;;;;;;;ACzBF,IAAa,aAAb,MAAgC;;;;;;;CA0B9B,YAAY,EAAE,MAAM,YAAwD;cAf3D;qBAO6C,EAAE;AAS9D,OAAK,YAAY,IAAI,gBAAgB,KAAK;AAC1C,OAAK,WAAW,IAAI,SAAS,SAAS,WAAW;GAC/C,MAAM,eAAe,SAAS;IAC5B;IACA,aAAa,aAAa;AACxB,UAAK,MAAM,cAAc,KAAK,YAC5B,YAAW,SAAS;;IAGzB,CAAC;AACF,WAAQ,QAAQ,aAAa,CAAC,MAC3B,WAAW;AACV,SAAK,OAAO;AACZ,QAAI,gBAAgB,KAAK,UAAU;AACnC,YAAQ,OAAO;OAEhB,UAAU;AACT,SAAK,OAAO;AACZ,WACE,IAAI,MAAM,oCAAoC,EAAE,OAAO,OAAO,CAAC,CAChE;KAEJ;IACD;AACF,QAAM,IAAI,KAAK,WAAW,KAAK;;;;;CAMjC,AAAO,kBACL,UACc;AACd,OAAK,YAAY,KAAK,SAAS;AAC/B,eAAa;AACX,QAAK,cAAc,KAAK,YAAY,QACjC,eAAe,eAAe,SAChC;;;;;;CAOL,OAAO,IACL,WACgC;AAChC,SAAO,MAAM,IAAI,UAAU;;;;;CAM7B,OAAO,OAAO,WAAyB;AACrC,QAAM,OAAO,UAAU;;;AAI3B,MAAM,wBAAQ,IAAI,KAAkC"}