{"version":3,"file":"prosekit-solid.js","names":["props: Accessor<SolidMarkViewProps>","args: SolidMarkViewUserOptions","props: Accessor<SolidNodeViewProps>","args: SolidNodeViewUserOptions","ProseKit: Component<ProseKitProps>"],"sources":["../src/utils/to-value.ts","../src/hooks/use-editor-extension.ts","../src/hooks/use-priority-extension.ts","../src/hooks/use-extension.ts","../src/extensions/solid-mark-view.ts","../src/extensions/solid-node-view.ts","../src/components/prosekit.ts","../src/hooks/use-doc-change.ts","../src/hooks/use-editor.ts","../src/hooks/use-keymap.ts","../src/hooks/use-state-update.ts"],"sourcesContent":["/**\n * Accesses the value of a MaybeAccessor\n *\n * @example\n * ```ts\n * access(\"foo\") // => \"foo\"\n * access(() => \"foo\") // => \"foo\"\n * ```\n */\nexport function toValue<T>(\n  v: (() => T) | T,\n): T {\n  return (typeof v === 'function') ? (v as () => T)() : v\n}\n","import {\n  EditorNotFoundError,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport {\n  createEffect,\n  onCleanup,\n  type Accessor,\n} from 'solid-js'\n\nimport { useEditorContext } from '../contexts/editor-context'\nimport type { MaybeAccessor } from '../types'\nimport { toValue } from '../utils/to-value'\n\n/**\n * @internal\n */\nexport function useEditorExtension(\n  editorAccessor: MaybeAccessor<Editor> | undefined | null,\n  extensionAccessor: Accessor<Extension | null>,\n): void {\n  const editorContext = useEditorContext()\n\n  createEffect(() => {\n    const editor = toValue(editorAccessor) || toValue(editorContext)\n    const extension = extensionAccessor()\n\n    if (!editor) {\n      throw new EditorNotFoundError()\n    }\n    if (extension) {\n      onCleanup(editor.use(extension))\n    }\n  })\n}\n","import {\n  withPriority,\n  type Extension,\n  type Priority,\n} from '@prosekit/core'\n\n/**\n * @internal\n */\nexport function usePriorityExtension<T extends Extension = Extension>(\n  extension: () => T | null,\n  priority?: Priority | null,\n): () => T | null {\n  return () => {\n    const ext = extension()\n    return ext && priority ? withPriority(ext, priority) : ext\n  }\n}\n","import type {\n  Editor,\n  Extension,\n  Priority,\n} from '@prosekit/core'\nimport type { Accessor } from 'solid-js'\n\nimport type { MaybeAccessor } from '../types'\n\nimport { useEditorExtension } from './use-editor-extension'\nimport { usePriorityExtension } from './use-priority-extension'\n\nexport interface UseExtensionOptions {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `ProseKit` component.\n   */\n  editor?: MaybeAccessor<Editor>\n\n  /**\n   * Optional priority to add the extension with.\n   */\n  priority?: Priority\n}\n\n/**\n * Add an extension to the editor.\n */\nexport function useExtension(\n  /**\n   * The accessor to an extension to add to the editor. If it changes, the previous\n   * extension will be removed and the new one (if not null) will be added.\n   */\n  extension: Accessor<Extension | null>,\n  options?: UseExtensionOptions,\n): void {\n  useEditorExtension(\n    options?.editor,\n    usePriorityExtension(extension, options?.priority),\n  )\n}\n","import {\n  defineMarkViewComponent,\n  defineMarkViewFactory,\n  type Extension,\n} from '@prosekit/core'\nimport type { MarkViewConstructor } from '@prosekit/pm/view'\nimport type { CoreMarkViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useMarkViewContext,\n  useMarkViewFactory,\n  type MarkViewContextProps,\n  type SolidMarkViewUserOptions,\n} from '@prosemirror-adapter/solid'\nimport {\n  createComponent,\n  createMemo,\n  type Accessor,\n  type Component,\n} from 'solid-js'\n\nimport { useExtension } from '../hooks/use-extension'\n\n/**\n * @public\n */\nexport interface SolidMarkViewProps extends MarkViewContextProps {}\n\n/**\n * @public\n */\nexport type SolidMarkViewComponent = Component<SolidMarkViewProps>\n\n/**\n * Options for {@link defineSolidMarkView}.\n *\n * @public\n */\nexport interface SolidMarkViewOptions extends CoreMarkViewUserOptions<SolidMarkViewComponent> {\n  /**\n   * The name of the mark type.\n   */\n  name: string\n}\n\nfunction withMarkViewProps(\n  component: SolidMarkViewComponent,\n): Component<SolidMarkViewProps> {\n  return function MarkViewPropsWrapper() {\n    const props: Accessor<SolidMarkViewProps> = useMarkViewContext()\n\n    return createComponent(component, props())\n  }\n}\n\n/**\n * @internal\n */\nexport function consumeSolidMarkViews(): void {\n  const markViewFactory = useMarkViewFactory()\n  const extension = createMemo(\n    () => defineSolidMarkViewFactory(markViewFactory),\n    [markViewFactory],\n  )\n\n  useExtension(extension)\n}\n\n/**\n * Defines a mark view using a Solid component.\n *\n * @public\n */\nexport function defineSolidMarkView(options: SolidMarkViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: SolidMarkViewUserOptions = {\n    ...userOptions,\n    component: withMarkViewProps(component),\n  }\n\n  return defineMarkViewComponent<SolidMarkViewUserOptions>({\n    group: 'solid',\n    name,\n    args,\n  })\n}\n\nfunction defineSolidMarkViewFactory(\n  factory: (options: SolidMarkViewOptions) => MarkViewConstructor,\n) {\n  return defineMarkViewFactory<SolidMarkViewOptions>({\n    group: 'solid',\n    factory,\n  })\n}\n","import {\n  defineNodeViewComponent,\n  defineNodeViewFactory,\n  type Extension,\n} from '@prosekit/core'\nimport type { NodeViewConstructor } from '@prosekit/pm/view'\nimport type { CoreNodeViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useNodeViewContext,\n  useNodeViewFactory,\n  type NodeViewContextProps,\n  type SolidNodeViewUserOptions,\n} from '@prosemirror-adapter/solid'\nimport {\n  createComponent,\n  createMemo,\n  type Accessor,\n  type Component,\n} from 'solid-js'\n\nimport { useExtension } from '../hooks/use-extension'\n\n/**\n * @public\n */\nexport interface SolidNodeViewProps extends NodeViewContextProps {}\n\n/**\n * @public\n */\nexport type SolidNodeViewComponent = Component<SolidNodeViewProps>\n\n/**\n * Options for {@link defineSolidNodeView}.\n *\n * @public\n */\nexport interface SolidNodeViewOptions extends CoreNodeViewUserOptions<SolidNodeViewComponent> {\n  /**\n   * The name of the node type.\n   */\n  name: string\n}\n\nfunction withNodeViewProps(\n  component: SolidNodeViewComponent,\n): Component<SolidNodeViewProps> {\n  return function NodeViewPropsWrapper() {\n    const props: Accessor<SolidNodeViewProps> = useNodeViewContext()\n\n    return createComponent(component, props())\n  }\n}\n\n/**\n * @internal\n */\nexport function consumeSolidNodeViews(): void {\n  const nodeViewFactory = useNodeViewFactory()\n  const extension = createMemo(\n    () => defineSolidNodeViewFactory(nodeViewFactory),\n    [nodeViewFactory],\n  )\n\n  useExtension(extension)\n}\n\n/**\n * Defines a node view using a Solid component.\n *\n * @public\n */\nexport function defineSolidNodeView(options: SolidNodeViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: SolidNodeViewUserOptions = {\n    ...userOptions,\n    component: withNodeViewProps(component),\n  }\n\n  return defineNodeViewComponent<SolidNodeViewUserOptions>({\n    group: 'solid',\n    name,\n    args,\n  })\n}\n\nfunction defineSolidNodeViewFactory(\n  factory: (options: SolidNodeViewOptions) => NodeViewConstructor,\n) {\n  return defineNodeViewFactory<SolidNodeViewOptions>({\n    group: 'solid',\n    factory,\n  })\n}\n","import type { Editor } from '@prosekit/core'\nimport { ProsemirrorAdapterProvider } from '@prosemirror-adapter/solid'\nimport {\n  createComponent,\n  type Component,\n  type ParentProps,\n} from 'solid-js'\n\nimport { EditorContextProvider } from '../contexts/editor-context'\nimport { consumeSolidMarkViews } from '../extensions/solid-mark-view'\nimport { consumeSolidNodeViews } from '../extensions/solid-node-view'\n\nexport type ProseKitProps = ParentProps<{\n  editor: Editor\n}>\n\n/**\n * The root component for a ProseKit editor.\n *\n * @public\n */\nexport const ProseKit: Component<ProseKitProps> = (props) => {\n  return createComponent(ProsemirrorAdapterProvider, {\n    get children() {\n      return createComponent(EditorContextProvider, {\n        get value() {\n          return props.editor\n        },\n        get children() {\n          consumeSolidNodeViews()\n          consumeSolidMarkViews()\n          return props.children\n        },\n      })\n    },\n  })\n}\n","import { defineDocChangeHandler } from '@prosekit/core'\nimport type { ProseMirrorNode } from '@prosekit/pm/model'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\n/**\n * Calls the given handler whenever the editor document changes.\n *\n * @public\n */\nexport function useDocChange(\n  handler: (doc: ProseMirrorNode) => void,\n  options?: UseExtensionOptions,\n): void {\n  const extension = defineDocChangeHandler((view) => handler(view.state.doc))\n  useExtension(() => extension, options)\n}\n","import {\n  defineMountHandler,\n  defineUpdateHandler,\n  ProseKitError,\n  union,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport {\n  createEffect,\n  createSignal,\n} from 'solid-js'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\n/**\n * Retrieves the editor instance from the nearest ProseKit component.\n *\n * @public\n */\nexport function useEditor<E extends Extension = any>(options?: {\n  /**\n   * Whether to update the component when the editor is mounted or editor state\n   * is updated.\n   *\n   * @default false\n   */\n  update?: boolean\n}): () => Editor<E> {\n  const update = options?.update ?? false\n\n  const editor = useEditorContext<E>()\n  if (!editor) {\n    throw new ProseKitError(\n      'useEditor must be used within the ProseKit component',\n    )\n  }\n\n  const [depend, forceUpdate] = useForceUpdate()\n\n  createEffect(() => {\n    if (update) {\n      const extension = union(\n        defineMountHandler(forceUpdate),\n        defineUpdateHandler(forceUpdate),\n      )\n      return editor.use(extension)\n    }\n  }, [editor, update, forceUpdate])\n\n  return () => {\n    depend()\n    return editor\n  }\n}\n\nfunction useForceUpdate() {\n  return createSignal(undefined, { equals: false })\n}\n","import {\n  defineKeymap,\n  type Keymap,\n} from '@prosekit/core'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\nexport function useKeymap(keymap: () => Keymap, options?: UseExtensionOptions): void {\n  const extension = () => defineKeymap(keymap())\n  useExtension(extension, options)\n}\n","import { defineUpdateHandler } from '@prosekit/core'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\n/**\n * Calls the given handler whenever the editor state changes.\n *\n * @public\n */\nexport function useStateUpdate(\n  handler: (state: EditorState) => void,\n  options?: UseExtensionOptions,\n): void {\n  const extension = defineUpdateHandler((view) => handler(view.state))\n  useExtension(() => extension, options)\n}\n"],"mappings":";;;;;;;;;;;;;;;AASA,SAAgB,QACd,GACG;AACH,QAAQ,OAAO,MAAM,aAAe,GAAe,GAAG;;;;;;;;ACMxD,SAAgB,mBACd,gBACA,mBACM;CACN,MAAM,gBAAgB,kBAAkB;AAExC,oBAAmB;EACjB,MAAM,SAAS,QAAQ,eAAe,IAAI,QAAQ,cAAc;EAChE,MAAM,YAAY,mBAAmB;AAErC,MAAI,CAAC,OACH,OAAM,IAAI,qBAAqB;AAEjC,MAAI,UACF,WAAU,OAAO,IAAI,UAAU,CAAC;GAElC;;;;;;;;ACzBJ,SAAgB,qBACd,WACA,UACgB;AAChB,cAAa;EACX,MAAM,MAAM,WAAW;AACvB,SAAO,OAAO,WAAW,aAAa,KAAK,SAAS,GAAG;;;;;;;;;ACa3D,SAAgB,aAKd,WACA,SACM;AACN,oBACE,SAAS,QACT,qBAAqB,WAAW,SAAS,SAAS,CACnD;;;;;ACKH,SAAS,kBACP,WAC+B;AAC/B,QAAO,SAAS,uBAAuB;EACrC,MAAMA,QAAsC,oBAAoB;AAEhE,SAAO,gBAAgB,WAAW,OAAO,CAAC;;;;;;AAO9C,SAAgB,wBAA8B;CAC5C,MAAM,kBAAkB,oBAAoB;CAC5C,MAAM,YAAY,iBACV,2BAA2B,gBAAgB,EACjD,CAAC,gBAAgB,CAClB;AAED,cAAa,UAAU;;;;;;;AAQzB,SAAgB,oBAAoB,SAA0C;CAC5E,MAAM,EAAE,MAAM,UAAW,GAAG,gBAAgB;CAE5C,MAAMC,OAAiC;EACrC,GAAG;EACH,WAAW,kBAAkB,UAAU;EACxC;AAED,QAAO,wBAAkD;EACvD,OAAO;EACP;EACA;EACD,CAAC;;AAGJ,SAAS,2BACP,SACA;AACA,QAAO,sBAA4C;EACjD,OAAO;EACP;EACD,CAAC;;;;;ACjDJ,SAAS,kBACP,WAC+B;AAC/B,QAAO,SAAS,uBAAuB;EACrC,MAAMC,QAAsC,oBAAoB;AAEhE,SAAO,gBAAgB,WAAW,OAAO,CAAC;;;;;;AAO9C,SAAgB,wBAA8B;CAC5C,MAAM,kBAAkB,oBAAoB;CAC5C,MAAM,YAAY,iBACV,2BAA2B,gBAAgB,EACjD,CAAC,gBAAgB,CAClB;AAED,cAAa,UAAU;;;;;;;AAQzB,SAAgB,oBAAoB,SAA0C;CAC5E,MAAM,EAAE,MAAM,UAAW,GAAG,gBAAgB;CAE5C,MAAMC,OAAiC;EACrC,GAAG;EACH,WAAW,kBAAkB,UAAU;EACxC;AAED,QAAO,wBAAkD;EACvD,OAAO;EACP;EACA;EACD,CAAC;;AAGJ,SAAS,2BACP,SACA;AACA,QAAO,sBAA4C;EACjD,OAAO;EACP;EACD,CAAC;;;;;;;;;;ACxEJ,MAAaC,YAAsC,UAAU;AAC3D,QAAO,gBAAgB,4BAA4B,EACjD,IAAI,WAAW;AACb,SAAO,gBAAgB,uBAAuB;GAC5C,IAAI,QAAQ;AACV,WAAO,MAAM;;GAEf,IAAI,WAAW;AACb,2BAAuB;AACvB,2BAAuB;AACvB,WAAO,MAAM;;GAEhB,CAAC;IAEL,CAAC;;;;;;;;;;ACtBJ,SAAgB,aACd,SACA,SACM;CACN,MAAM,YAAY,wBAAwB,SAAS,QAAQ,KAAK,MAAM,IAAI,CAAC;AAC3E,oBAAmB,WAAW,QAAQ;;;;;;;;;;ACExC,SAAgB,UAAqC,SAQjC;CAClB,MAAM,SAAS,SAAS,UAAU;CAElC,MAAM,SAAS,kBAAqB;AACpC,KAAI,CAAC,OACH,OAAM,IAAI,cACR,uDACD;CAGH,MAAM,CAAC,QAAQ,eAAe,gBAAgB;AAE9C,oBAAmB;AACjB,MAAI,QAAQ;GACV,MAAM,YAAY,MAChB,mBAAmB,YAAY,EAC/B,oBAAoB,YAAY,CACjC;AACD,UAAO,OAAO,IAAI,UAAU;;IAE7B;EAAC;EAAQ;EAAQ;EAAY,CAAC;AAEjC,cAAa;AACX,UAAQ;AACR,SAAO;;;AAIX,SAAS,iBAAiB;AACxB,QAAO,aAAa,QAAW,EAAE,QAAQ,OAAO,CAAC;;;;;AC/CnD,SAAgB,UAAU,QAAsB,SAAqC;CACnF,MAAM,kBAAkB,aAAa,QAAQ,CAAC;AAC9C,cAAa,WAAW,QAAQ;;;;;;;;;;ACClC,SAAgB,eACd,SACA,SACM;CACN,MAAM,YAAY,qBAAqB,SAAS,QAAQ,KAAK,MAAM,CAAC;AACpE,oBAAmB,WAAW,QAAQ"}