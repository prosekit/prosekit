{"version":3,"file":"prosekit-solid.js","names":[],"sources":["../src/utils/to-value.ts","../src/hooks/use-editor-extension.ts","../src/hooks/use-priority-extension.ts","../src/hooks/use-extension.ts","../src/extensions/solid-mark-view.ts","../src/extensions/solid-node-view.ts","../src/components/prosekit.ts","../src/hooks/use-doc-change.ts","../src/hooks/use-editor.ts","../src/hooks/use-editor-derived-value.ts","../src/hooks/use-keymap.ts","../src/hooks/use-state-update.ts"],"sourcesContent":["/**\n * Accesses the value of a MaybeAccessor\n *\n * @example\n * ```ts\n * access(\"foo\") // => \"foo\"\n * access(() => \"foo\") // => \"foo\"\n * ```\n */\nexport function toValue<T>(\n  v: (() => T) | T,\n): T {\n  return (typeof v === 'function') ? (v as () => T)() : v\n}\n","import { EditorNotFoundError, type Editor, type Extension } from '@prosekit/core'\nimport { createEffect, onCleanup, type Accessor } from 'solid-js'\n\nimport { useEditorContext } from '../contexts/editor-context.ts'\nimport type { MaybeAccessor } from '../types.ts'\nimport { toValue } from '../utils/to-value.ts'\n\n/**\n * @internal\n */\nexport function useEditorExtension(\n  editorAccessor: MaybeAccessor<Editor> | undefined | null,\n  extensionAccessor: Accessor<Extension | null>,\n): void {\n  const editorContext = useEditorContext()\n\n  createEffect(() => {\n    const editor = toValue(editorAccessor) || toValue(editorContext)\n    const extension = extensionAccessor()\n\n    if (!editor) {\n      throw new EditorNotFoundError()\n    }\n    if (extension) {\n      onCleanup(editor.use(extension))\n    }\n  })\n}\n","import { withPriority, type Extension, type Priority } from '@prosekit/core'\n\n/**\n * @internal\n */\nexport function usePriorityExtension<T extends Extension = Extension>(\n  extension: () => T | null,\n  priority?: Priority | null,\n): () => T | null {\n  return () => {\n    const ext = extension()\n    return ext && priority ? withPriority(ext, priority) : ext\n  }\n}\n","import type { Editor, Extension, Priority } from '@prosekit/core'\nimport type { Accessor } from 'solid-js'\n\nimport type { MaybeAccessor } from '../types.ts'\n\nimport { useEditorExtension } from './use-editor-extension.ts'\nimport { usePriorityExtension } from './use-priority-extension.ts'\n\nexport interface UseExtensionOptions {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `<ProseKit>` component.\n   */\n  editor?: MaybeAccessor<Editor>\n\n  /**\n   * Optional priority to add the extension with.\n   */\n  priority?: Priority\n}\n\n/**\n * Add an extension to the editor.\n */\nexport function useExtension(\n  /**\n   * The accessor to an extension to add to the editor. If it changes, the previous\n   * extension will be removed and the new one (if not null) will be added.\n   */\n  extension: Accessor<Extension | null>,\n  options?: UseExtensionOptions,\n): void {\n  useEditorExtension(\n    options?.editor,\n    usePriorityExtension(extension, options?.priority),\n  )\n}\n","import { defineMarkViewComponent, defineMarkViewFactory, type Extension } from '@prosekit/core'\nimport type { MarkViewConstructor } from '@prosekit/pm/view'\nimport type { CoreMarkViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useMarkViewContext,\n  useMarkViewFactory,\n  type MarkViewContextProps,\n  type SolidMarkViewUserOptions,\n} from '@prosemirror-adapter/solid'\nimport { createComponent, createMemo, type Accessor, type Component } from 'solid-js'\n\nimport { useExtension } from '../hooks/use-extension.ts'\n\n/**\n * @public\n */\nexport interface SolidMarkViewProps extends MarkViewContextProps {}\n\n/**\n * @public\n */\nexport type SolidMarkViewComponent = Component<SolidMarkViewProps>\n\n/**\n * Options for {@link defineSolidMarkView}.\n *\n * @public\n */\nexport interface SolidMarkViewOptions extends CoreMarkViewUserOptions<SolidMarkViewComponent> {\n  /**\n   * The name of the mark type.\n   */\n  name: string\n}\n\nfunction withMarkViewProps(\n  component: SolidMarkViewComponent,\n): Component<SolidMarkViewProps> {\n  return function MarkViewPropsWrapper() {\n    const context: Accessor<SolidMarkViewProps> = useMarkViewContext()\n    const props: SolidMarkViewProps = {\n      get contentRef() {\n        return context().contentRef\n      },\n      get view() {\n        return context().view\n      },\n      get mark() {\n        return context().mark\n      },\n    }\n    return createComponent(component, props)\n  }\n}\n\n/**\n * @internal\n */\nexport function consumeSolidMarkViews(): void {\n  const markViewFactory = useMarkViewFactory()\n  const extension = createMemo(\n    () => defineSolidMarkViewFactory(markViewFactory),\n    [markViewFactory],\n  )\n\n  useExtension(extension)\n}\n\n/**\n * Defines a mark view using a Solid component.\n *\n * @public\n */\nexport function defineSolidMarkView(options: SolidMarkViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: SolidMarkViewUserOptions = {\n    ...userOptions,\n    component: withMarkViewProps(component),\n  }\n\n  return defineMarkViewComponent<SolidMarkViewUserOptions>({\n    group: 'solid',\n    name,\n    args,\n  })\n}\n\nfunction defineSolidMarkViewFactory(\n  factory: (options: SolidMarkViewOptions) => MarkViewConstructor,\n) {\n  return defineMarkViewFactory<SolidMarkViewOptions>({\n    group: 'solid',\n    factory,\n  })\n}\n","import { defineNodeViewComponent, defineNodeViewFactory, type Extension } from '@prosekit/core'\nimport type { NodeViewConstructor } from '@prosekit/pm/view'\nimport type { CoreNodeViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useNodeViewContext,\n  useNodeViewFactory,\n  type NodeViewContextProps,\n  type SolidNodeViewUserOptions,\n} from '@prosemirror-adapter/solid'\nimport { createComponent, createMemo, type Accessor, type Component } from 'solid-js'\n\nimport { useExtension } from '../hooks/use-extension.ts'\n\n/**\n * @public\n */\nexport interface SolidNodeViewProps extends NodeViewContextProps {}\n\n/**\n * @public\n */\nexport type SolidNodeViewComponent = Component<SolidNodeViewProps>\n\n/**\n * Options for {@link defineSolidNodeView}.\n *\n * @public\n */\nexport interface SolidNodeViewOptions extends CoreNodeViewUserOptions<SolidNodeViewComponent> {\n  /**\n   * The name of the node type.\n   */\n  name: string\n}\n\nfunction withNodeViewProps(\n  component: SolidNodeViewComponent,\n): Component<SolidNodeViewProps> {\n  return function NodeViewPropsWrapper() {\n    const context: Accessor<SolidNodeViewProps> = useNodeViewContext()\n    const props: SolidNodeViewProps = {\n      get contentRef() {\n        return context().contentRef\n      },\n      get view() {\n        return context().view\n      },\n      get getPos() {\n        return context().getPos\n      },\n      get setAttrs() {\n        return context().setAttrs\n      },\n      get node() {\n        return context().node\n      },\n      get selected() {\n        return context().selected\n      },\n      get decorations() {\n        return context().decorations\n      },\n      get innerDecorations() {\n        return context().innerDecorations\n      },\n    }\n    return createComponent(component, props)\n  }\n}\n\n/**\n * @internal\n */\nexport function consumeSolidNodeViews(): void {\n  const nodeViewFactory = useNodeViewFactory()\n  const extension = createMemo(\n    () => defineSolidNodeViewFactory(nodeViewFactory),\n    [nodeViewFactory],\n  )\n\n  useExtension(extension)\n}\n\n/**\n * Defines a node view using a Solid component.\n *\n * @public\n */\nexport function defineSolidNodeView(options: SolidNodeViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: SolidNodeViewUserOptions = {\n    ...userOptions,\n    component: withNodeViewProps(component),\n  }\n\n  return defineNodeViewComponent<SolidNodeViewUserOptions>({\n    group: 'solid',\n    name,\n    args,\n  })\n}\n\nfunction defineSolidNodeViewFactory(\n  factory: (options: SolidNodeViewOptions) => NodeViewConstructor,\n) {\n  return defineNodeViewFactory<SolidNodeViewOptions>({\n    group: 'solid',\n    factory,\n  })\n}\n","import type { Editor } from '@prosekit/core'\nimport { ProsemirrorAdapterProvider } from '@prosemirror-adapter/solid'\nimport { createComponent, type Component, type ParentProps } from 'solid-js'\n\nimport { EditorContextProvider } from '../contexts/editor-context.ts'\nimport { consumeSolidMarkViews } from '../extensions/solid-mark-view.ts'\nimport { consumeSolidNodeViews } from '../extensions/solid-node-view.ts'\n\nexport type ProseKitProps = ParentProps<{\n  editor: Editor\n}>\n\n/**\n * The root component for a ProseKit editor.\n *\n * @public\n */\nexport const ProseKit: Component<ProseKitProps> = (props) => {\n  return createComponent(EditorContextProvider, {\n    get value() {\n      return props.editor\n    },\n    get children() {\n      return createComponent(ProsemirrorAdapterProvider, {\n        get children() {\n          consumeSolidNodeViews()\n          consumeSolidMarkViews()\n          return props.children\n        },\n      })\n    },\n  })\n}\n","import { defineDocChangeHandler } from '@prosekit/core'\nimport type { ProseMirrorNode } from '@prosekit/pm/model'\n\nimport { useExtension, type UseExtensionOptions } from './use-extension.ts'\n\n/**\n * Calls the given handler whenever the editor document changes.\n *\n * @public\n */\nexport function useDocChange(\n  handler: (doc: ProseMirrorNode) => void,\n  options?: UseExtensionOptions,\n): void {\n  const extension = defineDocChangeHandler((view) => handler(view.state.doc))\n  useExtension(() => extension, options)\n}\n","import { defineMountHandler, defineUpdateHandler, ProseKitError, union, type Editor, type Extension } from '@prosekit/core'\nimport { createEffect, createSignal } from 'solid-js'\n\nimport { useEditorContext } from '../contexts/editor-context.ts'\n\n/**\n * Retrieves the editor instance from the nearest ProseKit component.\n *\n * @public\n */\nexport function useEditor<E extends Extension = any>(options?: {\n  /**\n   * Whether to update the component when the editor is mounted or editor state\n   * is updated.\n   *\n   * @default false\n   */\n  update?: boolean\n}): () => Editor<E> {\n  const update = options?.update ?? false\n\n  const editor = useEditorContext<E>()\n  if (!editor) {\n    throw new ProseKitError(\n      'useEditor must be used within the ProseKit component',\n    )\n  }\n\n  const [depend, forceUpdate] = useForceUpdate()\n\n  createEffect(() => {\n    if (update) {\n      const extension = union(\n        defineMountHandler(forceUpdate),\n        defineUpdateHandler(forceUpdate),\n      )\n      return editor.use(extension)\n    }\n  }, [editor, update, forceUpdate])\n\n  return () => {\n    depend()\n    return editor\n  }\n}\n\nfunction useForceUpdate() {\n  return createSignal(undefined, { equals: false })\n}\n","import type { Editor, Extension } from '@prosekit/core'\nimport { createMemo, type Accessor } from 'solid-js'\n\nimport type { MaybeAccessor } from '../types.ts'\nimport { toValue } from '../utils/to-value.ts'\n\nimport { useEditor } from './use-editor.ts'\n\nexport interface UseEditorDerivedOptions<E extends Extension = any> {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `<ProseKit>` component.\n   */\n  editor?: MaybeAccessor<Editor<E>>\n}\n\n/**\n * Runs a function to derive a value from the editor instance after editor state\n * changes.\n *\n * This is useful when you need to render something based on the editor state,\n * for example, whether the selected text is wrapped in an italic mark.\n *\n * It returns an accessor of the derived value that updates whenever the editor\n * state changes.\n *\n * @public\n */\nexport function useEditorDerivedValue<E extends Extension, Derived>(\n  /**\n   * A function that receives the editor instance and returns a derived value.\n   *\n   * It will be called whenever the editor's document state changes, or when it\n   * mounts.\n   */\n  derive: (editor: Editor<E>) => Derived,\n  options?: UseEditorDerivedOptions<E>,\n): Accessor<Derived> {\n  const initialEditor = options?.editor\n  const editorAccessor: Accessor<Editor<E>> = initialEditor\n    ? () => toValue(initialEditor)\n    : useEditor<E>({ update: true })\n\n  return createMemo(() => derive(editorAccessor()))\n}\n","import { defineKeymap, type Keymap } from '@prosekit/core'\n\nimport { useExtension, type UseExtensionOptions } from './use-extension.ts'\n\nexport function useKeymap(keymap: () => Keymap, options?: UseExtensionOptions): void {\n  const extension = () => defineKeymap(keymap())\n  useExtension(extension, options)\n}\n","import { defineUpdateHandler } from '@prosekit/core'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport { useExtension, type UseExtensionOptions } from './use-extension.ts'\n\n/**\n * Calls the given handler whenever the editor state changes.\n *\n * @public\n */\nexport function useStateUpdate(\n  handler: (state: EditorState) => void,\n  options?: UseExtensionOptions,\n): void {\n  const extension = defineUpdateHandler((view) => handler(view.state))\n  useExtension(() => extension, options)\n}\n"],"mappings":"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"}