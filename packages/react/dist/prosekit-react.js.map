{"version":3,"file":"prosekit-react.js","names":["ReactMarkViewConsumer: FC","ReactNodeViewConsumer: FC","ProseKit: ComponentType<ProseKitProps>","derived: Derived"],"sources":["../src/hooks/use-editor-extension.ts","../src/hooks/use-priority-extension.ts","../src/hooks/use-extension.ts","../src/extensions/react-mark-view.ts","../src/extensions/react-node-view.ts","../src/components/prosekit.ts","../src/hooks/use-doc-change.ts","../src/hooks/use-editor.ts","../src/hooks/use-editor-derived-value.ts","../src/hooks/use-keymap.ts","../src/hooks/use-state-update.ts"],"sourcesContent":["import {\n  EditorNotFoundError,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport { useEffect } from 'react'\n\n/**\n * @internal\n */\nexport function useEditorExtension(\n  editor: Editor | null | undefined,\n  extension: Extension | null,\n): void {\n  if (!editor) {\n    throw new EditorNotFoundError()\n  }\n\n  useEffect(() => {\n    if (extension) {\n      return editor.use(extension)\n    }\n  }, [editor, extension])\n}\n","import {\n  withPriority,\n  type Extension,\n  type Priority,\n} from '@prosekit/core'\nimport { useMemo } from 'react'\n\n/**\n * @internal\n */\nexport function usePriorityExtension<T extends Extension = Extension>(\n  extension: T | null,\n  priority?: Priority | null,\n): T | null {\n  return useMemo(() => {\n    return extension && priority ? withPriority(extension, priority) : extension\n  }, [extension, priority])\n}\n","import type {\n  Editor,\n  Extension,\n  Priority,\n} from '@prosekit/core'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\nimport { useEditorExtension } from './use-editor-extension'\nimport { usePriorityExtension } from './use-priority-extension'\n\nexport interface UseExtensionOptions {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `<ProseKit>` component.\n   */\n  editor?: Editor\n\n  /**\n   * Optional priority to add the extension with.\n   */\n  priority?: Priority\n}\n\n/**\n * Add an extension to the editor.\n */\nexport function useExtension(\n  /**\n   * The extension to add to the editor. If it changes, the previous\n   * extension will be removed and the new one (if not null) will be added.\n   */\n  extension: Extension | null,\n  options?: UseExtensionOptions,\n): void {\n  const editorContext = useEditorContext()\n  useEditorExtension(\n    options?.editor || editorContext,\n    usePriorityExtension(extension, options?.priority),\n  )\n}\n","import {\n  defineMarkViewComponent,\n  defineMarkViewFactory,\n  type Extension,\n} from '@prosekit/core'\nimport type { MarkViewConstructor } from '@prosekit/pm/view'\nimport type { CoreMarkViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useMarkViewContext,\n  useMarkViewFactory,\n  type MarkViewContext,\n  type ReactMarkViewUserOptions,\n} from '@prosemirror-adapter/react'\nimport {\n  createElement,\n  useMemo,\n  type ComponentType,\n  type FC,\n} from 'react'\n\nimport { useExtension } from '../hooks/use-extension'\n\n/**\n * @public\n */\nexport interface ReactMarkViewProps extends MarkViewContext {}\n\n/**\n * @public\n */\nexport type ReactMarkViewComponent = ComponentType<ReactMarkViewProps>\n\n/**\n * Options for {@link defineReactMarkView}.\n *\n * @public\n */\nexport interface ReactMarkViewOptions extends CoreMarkViewUserOptions<ReactMarkViewComponent> {\n  /**\n   * The name of the mark type.\n   */\n  name: string\n}\n\nfunction withMarkViewProps(component: ReactMarkViewComponent) {\n  return function MarkViewPropsWrapper() {\n    const props: ReactMarkViewProps = useMarkViewContext()\n    return createElement(component, props)\n  }\n}\n\n/**\n * @internal\n */\nexport const ReactMarkViewConsumer: FC = () => {\n  const markViewFactory = useMarkViewFactory()\n  const extension = useMemo(\n    () => defineReactMarkViewFactory(markViewFactory),\n    [markViewFactory],\n  )\n  useExtension(extension)\n\n  return null\n}\n\n/**\n * Defines a mark view using a React component.\n *\n * @public\n */\nexport function defineReactMarkView(options: ReactMarkViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: ReactMarkViewUserOptions = {\n    ...userOptions,\n    component: withMarkViewProps(component),\n  }\n\n  return defineMarkViewComponent<ReactMarkViewUserOptions>({\n    group: 'react',\n    name,\n    args,\n  })\n}\n\nfunction defineReactMarkViewFactory(\n  factory: (options: ReactMarkViewUserOptions) => MarkViewConstructor,\n) {\n  return defineMarkViewFactory<ReactMarkViewUserOptions>({\n    group: 'react',\n    factory,\n  })\n}\n","import {\n  defineNodeViewComponent,\n  defineNodeViewFactory,\n  type Extension,\n} from '@prosekit/core'\nimport type { NodeViewConstructor } from '@prosekit/pm/view'\nimport type { CoreNodeViewUserOptions } from '@prosemirror-adapter/core'\nimport {\n  useNodeViewContext,\n  useNodeViewFactory,\n  type NodeViewContext,\n  type ReactNodeViewUserOptions,\n} from '@prosemirror-adapter/react'\nimport {\n  createElement,\n  useMemo,\n  type ComponentType,\n  type FC,\n} from 'react'\n\nimport { useExtension } from '../hooks/use-extension'\n\n/**\n * @public\n */\nexport interface ReactNodeViewProps extends NodeViewContext {}\n\n/**\n * @public\n */\nexport type ReactNodeViewComponent = ComponentType<ReactNodeViewProps>\n\n/**\n * Options for {@link defineReactNodeView}.\n *\n * @public\n */\nexport interface ReactNodeViewOptions extends CoreNodeViewUserOptions<ReactNodeViewComponent> {\n  /**\n   * The name of the node type.\n   */\n  name: string\n}\n\nfunction withNodeViewProps(component: ReactNodeViewComponent) {\n  return function NodeViewPropsWrapper() {\n    const props: ReactNodeViewProps = useNodeViewContext()\n    return createElement(component, props)\n  }\n}\n\n/**\n * @internal\n */\nexport const ReactNodeViewConsumer: FC = () => {\n  const nodeViewFactory = useNodeViewFactory()\n  const extension = useMemo(\n    () => defineReactNodeViewFactory(nodeViewFactory),\n    [nodeViewFactory],\n  )\n  useExtension(extension)\n\n  return null\n}\n\n/**\n * Defines a node view using a React component.\n *\n * @public\n */\nexport function defineReactNodeView(options: ReactNodeViewOptions): Extension {\n  const { name, component, ...userOptions } = options\n\n  const args: ReactNodeViewUserOptions = {\n    ...userOptions,\n    component: withNodeViewProps(component),\n  }\n\n  return defineNodeViewComponent<ReactNodeViewUserOptions>({\n    group: 'react',\n    name,\n    args,\n  })\n}\n\nfunction defineReactNodeViewFactory(\n  factory: (options: ReactNodeViewUserOptions) => NodeViewConstructor,\n) {\n  return defineNodeViewFactory<ReactNodeViewUserOptions>({\n    group: 'react',\n    factory,\n  })\n}\n","import type { Editor } from '@prosekit/core'\nimport { ProsemirrorAdapterProvider } from '@prosemirror-adapter/react'\nimport {\n  createElement,\n  type ComponentType,\n  type ReactNode,\n} from 'react'\n\nimport { EditorContextProvider } from '../contexts/editor-context'\nimport { ReactMarkViewConsumer } from '../extensions/react-mark-view'\nimport { ReactNodeViewConsumer } from '../extensions/react-node-view'\n\nexport interface ProseKitProps {\n  editor: Editor\n  children?: ReactNode\n}\n\n/**\n * The root component for a ProseKit editor.\n *\n * @public\n */\nexport const ProseKit: ComponentType<ProseKitProps> = (props) => {\n  const { editor, children } = props\n\n  return createElement(\n    ProsemirrorAdapterProvider,\n    null,\n    createElement(\n      EditorContextProvider,\n      { value: editor },\n      createElement(ReactNodeViewConsumer),\n      createElement(ReactMarkViewConsumer),\n      children,\n    ),\n  )\n}\n","import { defineDocChangeHandler } from '@prosekit/core'\nimport type { ProseMirrorNode } from '@prosekit/pm/model'\nimport { useMemo } from 'react'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\n/**\n * Calls the given handler whenever the editor document changes.\n *\n * @public\n */\nexport function useDocChange(\n  handler: (doc: ProseMirrorNode) => void,\n  options?: UseExtensionOptions,\n): void {\n  const extension = useMemo(\n    () => defineDocChangeHandler((view) => handler(view.state.doc)),\n    [handler],\n  )\n  useExtension(extension, options)\n}\n","import {\n  defineMountHandler,\n  defineUpdateHandler,\n  ProseKitError,\n  union,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport {\n  useEffect,\n  useReducer,\n} from 'react'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\n/**\n * Retrieves the editor instance from the nearest ProseKit component.\n *\n * @public\n */\nexport function useEditor<E extends Extension = any>(options?: {\n  /**\n   * Whether to update the component when the editor is mounted or editor state\n   * is updated.\n   *\n   * Note this this option doesn't work with [React\n   * compiler](https://react.dev/learn/react-compiler) because the returned\n   * editor will be the same instance after state updates. If you're using React\n   * compiler, you should use {@link useEditorDerivedValue} instead.\n   *\n   * @default false\n   */\n  update?: boolean\n}): Editor<E> {\n  const update = options?.update ?? false\n\n  const editor = useEditorContext<E>()\n  if (!editor) {\n    throw new ProseKitError(\n      'useEditor must be used within the ProseKit component',\n    )\n  }\n\n  const forceUpdate = useForceUpdate()\n\n  useEffect(() => {\n    if (update) {\n      const extension = union(\n        defineMountHandler(forceUpdate),\n        defineUpdateHandler(forceUpdate),\n      )\n      return editor.use(extension)\n    }\n  }, [editor, update, forceUpdate])\n\n  return editor\n}\n\nfunction useForceUpdate() {\n  const [, dispatch] = useReducer((x: number) => x + 1, 0)\n  return dispatch\n}\n","import {\n  defineMountHandler,\n  defineUpdateHandler,\n  EditorNotFoundError,\n  union,\n  type Editor,\n  type Extension,\n} from '@prosekit/core'\nimport {\n  useMemo,\n  useSyncExternalStore,\n} from 'react'\n\nimport { useEditorContext } from '../contexts/editor-context'\n\nexport interface UseEditorDerivedOptions<E extends Extension = any> {\n  /**\n   * The editor to add the extension to. If not provided, it will use the\n   * editor from the nearest `<ProseKit>` component.\n   */\n  editor?: Editor<E>\n}\n\n/**\n * Runs a function to derive a value from the editor instance after editor state\n * changes.\n *\n * This is useful when you need to render something based on the editor state,\n * for example, whether the selected text is wrapped in an italic mark.\n *\n * It returns the derived value that updates whenever the editor state changes.\n *\n * @public\n */\nexport function useEditorDerivedValue<E extends Extension, Derived>(\n  /**\n   * A function that receives the editor instance and returns a derived value.\n   *\n   * It will be called whenever the editor's document state changes, or when it\n   * mounts.\n   *\n   * This function should be memoized.\n   */\n  derive: (editor: Editor<E>) => Derived,\n  options?: UseEditorDerivedOptions<E>,\n): Derived {\n  const editorContext = useEditorContext<E>()\n  const editor = options?.editor ?? editorContext\n  if (!editor) {\n    throw new EditorNotFoundError()\n  }\n\n  const [subscribe, getSnapshot] = useMemo(() => {\n    return createEditorStore(editor, derive)\n  }, [editor, derive])\n\n  return useSyncExternalStore(subscribe, getSnapshot)\n}\n\nfunction createEditorStore<Derived, E extends Extension = any>(editor: Editor<E>, derive: (editor: Editor<E>) => Derived) {\n  let dirty = true\n  let derived: Derived\n\n  const subscribe = (onChange: VoidFunction): VoidFunction => {\n    const handleChange = () => {\n      dirty = true\n      onChange()\n    }\n    const extension = union(\n      defineUpdateHandler(handleChange),\n      defineMountHandler(handleChange),\n    )\n    return editor.use(extension)\n  }\n\n  const getSnapshot = () => {\n    if (dirty) {\n      dirty = false\n      derived = derive(editor)\n    }\n    return derived\n  }\n\n  return [subscribe, getSnapshot] as const\n}\n","import {\n  defineKeymap,\n  type Keymap,\n} from '@prosekit/core'\nimport { useMemo } from 'react'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\nexport function useKeymap(keymap: Keymap, options?: UseExtensionOptions): void {\n  const extension = useMemo(() => defineKeymap(keymap), [keymap])\n  useExtension(extension, options)\n}\n","import { defineUpdateHandler } from '@prosekit/core'\nimport type { EditorState } from '@prosekit/pm/state'\nimport { useMemo } from 'react'\n\nimport {\n  useExtension,\n  type UseExtensionOptions,\n} from './use-extension'\n\n/**\n * Calls the given handler whenever the editor state changes.\n *\n * @public\n */\nexport function useStateUpdate(\n  handler: (state: EditorState) => void,\n  options?: UseExtensionOptions,\n): void {\n  const extension = useMemo(\n    () => defineUpdateHandler((view) => handler(view.state)),\n    [handler],\n  )\n  useExtension(extension, options)\n}\n"],"mappings":"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"}