{"version":3,"file":"prosemirror-drop-indicator.js","names":["stack: StackItem[]","targets: DropTarget[]","prevTargets: DropTarget[]","prevDoc: ProseMirrorNode | undefined","prevRect: DOMRect | undefined","getTargetImpl: GetTarget","target","prevPoint: Point | undefined","prevTarget: DropTarget | undefined","getTargetCached: GetTarget","getTarget: GetTarget | undefined","hideId: ReturnType<typeof setTimeout> | undefined","prevX: number | undefined","prevY: number | undefined","hasDragOverEvent: boolean"],"sources":["../src/drop-target.ts","../src/drop-indicator-plugin.ts"],"sourcesContent":["import { isHTMLElement } from '@ocavue/utils'\nimport type { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { NodeSelection } from 'prosemirror-state'\nimport type { EditorView } from 'prosemirror-view'\n\nimport type { DragEventHandler } from './types'\n\ntype Point = readonly [x: number, y: number]\n\ntype Line = readonly [x1: number, y1: number, x2: number, y2: number]\n\n/**\n * @internal\n */\ntype DropTarget = readonly [pos: number, line: Line]\n\nfunction getTargetsByView(view: EditorView): DropTarget[] {\n  type StackItem = [pos: number, node: ProseMirrorNode]\n  let stack: StackItem[] = [[-1, view.state.doc]]\n  let targets: DropTarget[] = []\n\n  while (stack.length > 0) {\n    const [pos, node] = stack.pop()!\n    if (pos >= 0) {\n      let dom = view.nodeDOM(pos)\n      if (dom && isHTMLElement(dom)) {\n        let rect = dom.getBoundingClientRect()\n        let { top, bottom, left: x1, right: x2 } = rect\n        targets.push(\n          [pos, [x1, top, x2, top]],\n          [pos + node.nodeSize, [x1, bottom, x2, bottom]],\n        )\n      }\n    }\n    if (node.isBlock && !node.isTextblock) {\n      let childPos = pos + 1\n      for (let child of node.children) {\n        stack.push([childPos, child])\n        childPos += child.nodeSize\n      }\n    }\n  }\n\n  return targets\n}\n\n/**\n * @internal\n */\nexport type GetTarget = (point: Point, event: DragEvent) => DropTarget | undefined\n\n/**\n * @internal\n */\nexport function buildGetTarget(\n  view: EditorView,\n  onDrag?: DragEventHandler,\n): GetTarget {\n  let prevTargets: DropTarget[] = []\n  let prevDoc: ProseMirrorNode | undefined\n  let prevRect: DOMRect | undefined\n\n  const getTargets = (): DropTarget[] => {\n    const rect = view.dom.getBoundingClientRect()\n    const doc = view.state.doc\n\n    if (\n      prevTargets && prevDoc && prevRect\n      && rect.width === prevRect.width\n      && rect.height === prevRect.height\n      && rect.x === prevRect.x\n      && rect.y === prevRect.y\n      && prevDoc.eq(doc)\n    ) {\n      return prevTargets\n    }\n\n    prevRect = rect\n    prevDoc = doc\n    prevTargets = getTargetsByView(view)\n    return prevTargets\n  }\n\n  const getTargetImpl: GetTarget = (point, event) => {\n    if (!view.editable || view.isDestroyed) {\n      return\n    }\n\n    const compare = (p1: DropTarget, p2: DropTarget): number => {\n      const [pos1, line1] = p1\n      const [pos2, line2] = p2\n      const p1Distance = pointLineDistance(point, line1)\n      const p2Distance = pointLineDistance(point, line2)\n\n      return (p1Distance - p2Distance) || (pos1 - pos2)\n    }\n\n    let targets = getTargets()\n    targets.sort(compare)\n\n    // Only consider the first few targets for performance reasons.\n    targets = targets.slice(0, 8)\n\n    // Find the closest valid target.\n    const target = targets.find(target => onDrag?.({ view, pos: target[0], event }) !== false)\n\n    // If the dragging node is already at the target position, we ignore this\n    // target. Notice that we don't pick the second better target here.\n    if (target && isDraggingToItself(view, target[0])) {\n      return undefined\n    }\n\n    return target\n  }\n\n  let prevPoint: Point | undefined\n  let prevTarget: DropTarget | undefined\n\n  const getTargetCached: GetTarget = (point, event) => {\n    if (prevPoint && pointEqual(prevPoint, point)) {\n      return prevTarget\n    }\n\n    prevPoint = point\n    prevTarget = getTargetImpl(point, event)\n    return prevTarget\n  }\n\n  return getTargetCached\n}\n\nfunction pointEqual(a: Point, b: Point) {\n  return a[0] === b[0] && a[1] === b[1]\n}\n\nfunction pointPointDistance(a: Point, b: Point) {\n  // Manhattan distance\n  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1])\n}\n\nfunction pointLineDistance(point: Point, line: Line) {\n  // Notice that we are actually not calculating the distance between the point\n  // and the line. Instead, we are calculating the distance between the point\n  // and the two endpoints of the line.\n  return Math.min(\n    pointPointDistance(point, [line[0], line[1]]),\n    pointPointDistance(point, [line[2], line[3]]),\n  )\n}\n\n/**\n * Whether the dragging node is being dragged to the same position. For example,\n * dragging a list node into a new position that is just below the list node, or\n * dragging a nested quoteblock into itself.\n */\nfunction isDraggingToItself(view: EditorView, pos: number) {\n  const dragging = view.dragging\n  if (!dragging) return\n\n  const { move } = dragging\n  if (!move) return\n\n  const selection = view.state.selection\n  if (!(selection instanceof NodeSelection)) return\n\n  const { from, to } = selection\n  return from <= pos && pos <= to\n}\n","import type { ResolvedPos } from 'prosemirror-model'\nimport {\n  NodeSelection,\n  Plugin,\n  PluginKey,\n  TextSelection,\n  type PluginView,\n} from 'prosemirror-state'\nimport type { EditorView } from 'prosemirror-view'\n\nimport {\n  buildGetTarget,\n  type GetTarget,\n} from './drop-target'\nimport type {\n  DragEventHandler,\n  ShowHandler,\n  ViewDragging,\n} from './types'\n\n/**\n * @public\n */\nexport interface DropIndicatorPluginOptions {\n  /**\n   * A callback that is called when the drop indicator should be shown.\n   */\n  onShow?: ShowHandler\n\n  /**\n   * A callback that is called when the drop indicator should be hidden.\n   */\n  onHide?: VoidFunction\n\n  /**\n   * A callback that is called when the `dragover` event is fired. You can\n   * return `false` to disable the current drop point and thus hide the drop\n   * indicator.\n   */\n  onDrag?: DragEventHandler\n}\n\n/**\n * @public\n *\n * @param options - The options for the drop indicator plugin.\n */\nexport function createDropIndicatorPlugin(options: DropIndicatorPluginOptions): Plugin {\n  let getTarget: GetTarget | undefined\n\n  return new Plugin({\n    key: new PluginKey('prosekit-drop-indicator'),\n    view: (view) => {\n      getTarget = buildGetTarget(view, options.onDrag)\n      return createDropIndicatorView(view, getTarget, options)\n    },\n    props: {\n      handleDrop(view, event, slice, move): boolean {\n        if (!getTarget) return false\n\n        const target = getTarget([event.clientX, event.clientY], event)\n\n        if (!target) return false\n\n        event.preventDefault()\n        let insertPos = target[0]\n\n        let tr = view.state.tr\n        if (move) {\n          let { node } = (view.dragging as ViewDragging | null) || {}\n          if (node) node.replace(tr)\n          else tr.deleteSelection()\n        }\n\n        let pos = tr.mapping.map(insertPos)\n        let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1\n        let beforeInsert = tr.doc\n        if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild!)\n        else tr.replaceRange(pos, pos, slice)\n        if (tr.doc.eq(beforeInsert)) {\n          return true\n        }\n\n        let $pos = tr.doc.resolve(pos)\n        if (\n          isNode && NodeSelection.isSelectable(slice.content.firstChild!)\n          && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild!)\n        ) {\n          tr.setSelection(new NodeSelection($pos))\n        } else {\n          let end = tr.mapping.map(insertPos)\n          tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo)\n          tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)))\n        }\n        view.focus()\n        view.dispatch(tr.setMeta('uiEvent', 'drop'))\n        return true\n      },\n    },\n  })\n}\n\nfunction selectionBetween(view: EditorView, $anchor: ResolvedPos, $head: ResolvedPos, bias?: number) {\n  return view.someProp('createSelectionBetween', f => f(view, $anchor, $head))\n    || TextSelection.between($anchor, $head, bias)\n}\n\nfunction createDropIndicatorView(view: EditorView, getTarget: GetTarget, options: DropIndicatorPluginOptions): PluginView {\n  let dom = view.dom\n  let hideId: ReturnType<typeof setTimeout> | undefined\n  let prevX: number | undefined\n  let prevY: number | undefined\n  let hasDragOverEvent: boolean = false\n\n  const scheduleHide = () => {\n    if (hideId) {\n      clearTimeout(hideId)\n    }\n\n    hasDragOverEvent = false\n    hideId = setTimeout(() => {\n      if (hasDragOverEvent) return\n      options.onHide?.()\n    }, 30)\n  }\n\n  const handleDragOver = (event: DragEvent): void => {\n    hasDragOverEvent = true\n\n    const { clientX, clientY } = event\n    if (prevX === clientX && prevY === clientY) {\n      return\n    }\n    prevX = clientX\n    prevY = clientY\n\n    let target = getTarget([clientX, clientY], event)\n\n    if (!target) {\n      scheduleHide()\n      return\n    } else {\n      const [pos, [x1, y1, x2, y2]] = target\n      const line = { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } }\n      options.onShow?.({ view, pos, line })\n    }\n  }\n\n  dom.addEventListener('dragover', handleDragOver)\n  dom.addEventListener('dragend', scheduleHide)\n  dom.addEventListener('drop', scheduleHide)\n  dom.addEventListener('dragleave', scheduleHide)\n\n  const destroy = () => {\n    dom.removeEventListener('dragover', handleDragOver)\n    dom.removeEventListener('dragend', scheduleHide)\n    dom.removeEventListener('drop', scheduleHide)\n    dom.removeEventListener('dragleave', scheduleHide)\n  }\n\n  return { destroy }\n}\n"],"mappings":"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"}