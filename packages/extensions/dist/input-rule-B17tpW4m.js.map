{"version":3,"file":"input-rule-B17tpW4m.js","names":["rules: InputRule[]"],"sources":["../src/input-rule/index.ts"],"sourcesContent":["import {\n  defineFacet,\n  defineFacetPayload,\n  getMarkType,\n  getNodeType,\n  isMarkAbsent,\n  maybeRun,\n  pluginFacet,\n  type PlainExtension,\n  type PluginPayload,\n} from '@prosekit/core'\nimport {\n  InputRule,\n  inputRules,\n  textblockTypeInputRule,\n  wrappingInputRule,\n} from '@prosekit/pm/inputrules'\nimport type {\n  Attrs,\n  MarkType,\n  NodeType,\n  ProseMirrorNode,\n  Schema,\n} from '@prosekit/pm/model'\nimport type { Plugin } from '@prosekit/pm/state'\n\n/**\n * Defines an input rule extension.\n *\n * @param rule - The ProseMirror input rule to add.\n *\n * @public\n */\nexport function defineInputRule(rule: InputRule): PlainExtension {\n  return defineInputRuleFacetPayload(() => rule)\n}\n\n/**\n * Options for {@link defineMarkInputRule}.\n *\n * @public\n */\nexport interface MarkInputRuleOptions {\n  /**\n   * The regular expression to match against, which should end with `$` and has\n   * exactly one capture group. All other matched text outside the capture group\n   * will be deleted.\n   */\n  regex: RegExp\n\n  /**\n   * The type of mark to set.\n   */\n  type: string | MarkType\n\n  /**\n   * Attributes to set on the mark.\n   */\n  attrs?: Attrs | null | ((match: RegExpMatchArray) => Attrs | null)\n\n  /**\n   * Whether this rule should fire inside marks marked as [code](https://prosemirror.net/docs/ref/#model.MarkSpec.code).\n   *\n   * @default `false`\n   */\n  inCodeMark?: boolean\n}\n\n/**\n * @internal\n */\nexport function createMarkInputRule({\n  regex,\n  type,\n  attrs = null,\n  inCodeMark = false,\n}: MarkInputRuleOptions): InputRule {\n  const rule = new InputRule(regex, (state, match, start, end) => {\n    const { tr, schema } = state\n    const [fullText, markText] = match\n\n    if (!markText) {\n      return null\n    }\n\n    const markStart = start + fullText.indexOf(markText)\n    const markEnd = markStart + markText.length\n\n    if (!(start <= markStart && markStart < markEnd && markEnd <= end)) {\n      // Incorrect regex.\n      return null\n    }\n\n    const markType = getMarkType(schema, type)\n    const mark = markType.create(maybeRun(attrs, match))\n\n    if (!isMarkAbsent(tr.doc, markStart, markEnd, markType, attrs)) {\n      // The mark is already active.\n      return null\n    }\n\n    const initialStoredMarks = tr.storedMarks ?? []\n\n    tr.addMark(markStart, markEnd, mark)\n\n    if (markEnd < end) {\n      tr.delete(markEnd, end)\n    }\n    if (start < markStart) {\n      tr.delete(start, markStart)\n    }\n\n    // Make sure not to reactivate any marks which had previously been\n    // deactivated. By keeping track of the initial stored marks we are able to\n    // discard any unintended consequences of deleting text and adding it again.\n    tr.setStoredMarks(initialStoredMarks)\n\n    return tr\n  }, { inCodeMark })\n\n  return rule\n}\n\n/**\n * Defines an input rule for automatically adding inline marks when a given\n * pattern is typed.\n *\n * @public\n */\nexport function defineMarkInputRule(\n  options: MarkInputRuleOptions,\n): PlainExtension {\n  return defineInputRule(createMarkInputRule(options))\n}\n\n/**\n * Defines an input rule that changes the type of a textblock when the matched\n * text is typed into it.\n *\n * See also [textblockTypeInputRule](https://prosemirror.net/docs/ref/#inputrules.textblockTypeInputRule)\n *\n * @param options\n *\n * @public\n */\nexport function defineTextBlockInputRule({\n  regex,\n  type,\n  attrs,\n}: {\n  /**\n   * The regular expression to match against, which should end with `$`. It\n   * usually also starts with `^` to that it is only matched at the start of a\n   * textblock.\n   */\n  regex: RegExp\n\n  /**\n   * The node type to replace the matched text with.\n   */\n  type: string | NodeType\n\n  /**\n   * Attributes to set on the node.\n   */\n  attrs?: Attrs | null | ((match: RegExpMatchArray) => Attrs | null)\n}): PlainExtension {\n  return defineInputRuleFacetPayload(({ schema }): InputRule => {\n    const nodeType = getNodeType(schema, type)\n    return textblockTypeInputRule(regex, nodeType, attrs)\n  })\n}\n\n/**\n * Defines an input rule for automatically wrapping a textblock when a given\n * string is typed.\n *\n * See also [wrappingInputRule](https://prosemirror.net/docs/ref/#inputrules.wrappingInputRule)\n *\n * @param options\n *\n * @public\n */\nexport function defineWrappingInputRule({\n  regex,\n  type,\n  attrs,\n  join,\n}: {\n  /**\n   * The regular expression to match against, which should end with `$`. It\n   * usually also starts with `^` to that it is only matched at the start of a\n   * textblock.\n   */\n  regex: RegExp\n\n  /**\n   * The type of node to wrap in.\n   */\n  type: string | NodeType\n\n  /**\n   * Attributes to set on the node.\n   */\n  attrs?: Attrs | null | ((match: RegExpMatchArray) => Attrs | null)\n\n  /**\n   * By default, if there's a node with the same type above the newly wrapped\n   * node, the rule will try to\n   * [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\n   * two nodes. You can pass a join predicate, which takes a regular expression\n   * match and the node before the wrapped node, and can return a boolean to\n   * indicate whether a join should happen.\n   */\n  join?: (match: RegExpMatchArray, node: ProseMirrorNode) => boolean\n}): PlainExtension {\n  return defineInputRuleFacetPayload(({ schema }): InputRule => {\n    const nodeType = getNodeType(schema, type)\n    return wrappingInputRule(regex, nodeType, attrs, join)\n  })\n}\n\nfunction defineInputRuleFacetPayload(input: InputRulePayload): PlainExtension {\n  return defineFacetPayload(inputRuleFacet, [input]) as PlainExtension\n}\n\ntype InputRulePayload = (context: { schema: Schema }) => InputRule\n\nconst inputRuleFacet = defineFacet<InputRulePayload, PluginPayload>({\n  reducer: (inputs: InputRulePayload[]): PluginPayload => {\n    return (context): Plugin[] => {\n      const rules: InputRule[] = inputs.flatMap((callback) => callback(context))\n      return [inputRules({ rules })]\n    }\n  },\n  parent: pluginFacet,\n})\n"],"mappings":";;;;;;;;;;;AAiCA,SAAgB,gBAAgB,MAAiC;AAC/D,QAAO,kCAAkC,KAAK;;;;;AAqChD,SAAgB,oBAAoB,EAClC,OACA,MACA,QAAQ,MACR,aAAa,SACqB;AA4ClC,QA3Ca,IAAI,UAAU,QAAQ,OAAO,OAAO,OAAO,QAAQ;EAC9D,MAAM,EAAE,IAAI,WAAW;EACvB,MAAM,CAAC,UAAU,YAAY;AAE7B,MAAI,CAAC,SACH,QAAO;EAGT,MAAM,YAAY,QAAQ,SAAS,QAAQ,SAAS;EACpD,MAAM,UAAU,YAAY,SAAS;AAErC,MAAI,EAAE,SAAS,aAAa,YAAY,WAAW,WAAW,KAE5D,QAAO;EAGT,MAAM,WAAW,YAAY,QAAQ,KAAK;EAC1C,MAAM,OAAO,SAAS,OAAO,SAAS,OAAO,MAAM,CAAC;AAEpD,MAAI,CAAC,aAAa,GAAG,KAAK,WAAW,SAAS,UAAU,MAAM,CAE5D,QAAO;EAGT,MAAM,qBAAqB,GAAG,eAAe,EAAE;AAE/C,KAAG,QAAQ,WAAW,SAAS,KAAK;AAEpC,MAAI,UAAU,IACZ,IAAG,OAAO,SAAS,IAAI;AAEzB,MAAI,QAAQ,UACV,IAAG,OAAO,OAAO,UAAU;AAM7B,KAAG,eAAe,mBAAmB;AAErC,SAAO;IACN,EAAE,YAAY,CAAC;;;;;;;;AAWpB,SAAgB,oBACd,SACgB;AAChB,QAAO,gBAAgB,oBAAoB,QAAQ,CAAC;;;;;;;;;;;;AAatD,SAAgB,yBAAyB,EACvC,OACA,MACA,SAkBiB;AACjB,QAAO,6BAA6B,EAAE,aAAwB;EAC5D,MAAM,WAAW,YAAY,QAAQ,KAAK;AAC1C,SAAO,uBAAuB,OAAO,UAAU,MAAM;GACrD;;;;;;;;;;;;AAaJ,SAAgB,wBAAwB,EACtC,OACA,MACA,OACA,QA4BiB;AACjB,QAAO,6BAA6B,EAAE,aAAwB;EAC5D,MAAM,WAAW,YAAY,QAAQ,KAAK;AAC1C,SAAO,kBAAkB,OAAO,UAAU,OAAO,KAAK;GACtD;;AAGJ,SAAS,4BAA4B,OAAyC;AAC5E,QAAO,mBAAmB,gBAAgB,CAAC,MAAM,CAAC;;AAKpD,MAAM,iBAAiB,YAA6C;CAClE,UAAU,WAA8C;AACtD,UAAQ,YAAsB;GAC5B,MAAMA,QAAqB,OAAO,SAAS,aAAa,SAAS,QAAQ,CAAC;AAC1E,UAAO,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;;;CAGlC,QAAQ;CACT,CAAC"}