{"version":3,"file":"prosekit-web-inline-popover.js","names":["overlayPositionerProps","overlayPositionerEvents"],"sources":["../src/hooks/use-editor-focus-event.ts","../src/hooks/use-editor-update-event.ts","../src/hooks/use-keymap.ts","../src/components/inline-popover/inline-popover/virtual-selection-element.ts","../src/components/inline-popover/inline-popover/setup.ts","../src/components/inline-popover/inline-popover/types.ts","../src/components/inline-popover/inline-popover/element.gen.ts"],"sourcesContent":["import type { ConnectableElement, ReadonlySignal } from '@aria-ui/core'\nimport { defineFocusChangeHandler, type Editor, type FocusChangeHandler } from '@prosekit/core'\n\nimport { useEditorExtension } from './use-editor-extension.ts'\n\n/**\n * @internal\n */\nexport function useEditorFocusChangeEvent(\n  host: ConnectableElement,\n  editor: ReadonlySignal<Editor | null>,\n  handler: FocusChangeHandler,\n): void {\n  const extension = defineFocusChangeHandler(handler)\n  useEditorExtension(host, editor, extension)\n}\n","import type { ConnectableElement, ReadonlySignal } from '@aria-ui/core'\nimport { defineUpdateHandler, type Editor, type UpdateHandler } from '@prosekit/core'\n\nimport { useEditorExtension } from './use-editor-extension.ts'\n\n/**\n * @internal\n */\nexport function useEditorUpdateEvent(\n  host: ConnectableElement,\n  editor: ReadonlySignal<Editor | null>,\n  handler: UpdateHandler,\n): void {\n  const extension = defineUpdateHandler(handler)\n  useEditorExtension(host, editor, extension)\n}\n","import type { ConnectableElement, ReadonlySignal } from '@aria-ui/core'\nimport { defineKeymap, type Editor, type Keymap } from '@prosekit/core'\n\nimport { useEditorExtension } from './use-editor-extension.ts'\n\nexport function useKeymap(\n  host: ConnectableElement,\n  editor: ReadonlySignal<Editor | null>,\n  keymap: Keymap,\n): void {\n  const extension = defineKeymap(keymap)\n  useEditorExtension(host, editor, extension)\n}\n","import type { ReferenceElement } from '@floating-ui/dom'\nimport { containsInlineNode, isInCodeBlock, isTextSelection } from '@prosekit/core'\nimport type { EditorView } from '@prosekit/pm/view'\n\nexport function getVirtualSelectionElement(\n  view: EditorView,\n): ReferenceElement | undefined {\n  if (typeof window === 'undefined' || view.isDestroyed) {\n    return\n  }\n\n  const selection = view.state.selection\n\n  if (\n    !selection.empty\n    && !isInCodeBlock(selection)\n    && isTextSelection(selection)\n    && containsInlineNode(view.state.doc, selection.from, selection.to)\n  ) {\n    return getDomDecoration(view) || getInlineDecoration(view)\n  }\n}\n\nfunction getDomDecoration(view: EditorView): ReferenceElement | undefined {\n  const range = getDomRange(view)\n  if (range) {\n    // To get it work properly in Safari, we cannot return the range directly.\n    // We have to return a contextElement.\n    return {\n      contextElement: view.dom,\n      getBoundingClientRect: () => range.getBoundingClientRect(),\n      getClientRects: () => range.getClientRects(),\n    }\n  }\n}\n\nfunction getDomRange(view: EditorView): Range | undefined {\n  const win = view.dom.ownerDocument.defaultView\n  const selection = win?.getSelection()\n  if (!selection || selection.isCollapsed) {\n    return\n  }\n\n  const range = typeof selection.rangeCount === 'number'\n    && selection.rangeCount > 0\n    && selection.getRangeAt(0)\n\n  if (!range) {\n    return\n  }\n\n  return range\n}\n\nfunction getInlineDecoration(view: EditorView): ReferenceElement | undefined {\n  const match = view.dom.querySelectorAll('.prosekit-virtual-selection')\n\n  if (match.length === 0) {\n    return\n  }\n  if (match.length === 1) {\n    return match[0]\n  }\n\n  const items = Array.from(match)\n  return {\n    contextElement: items[0],\n    getBoundingClientRect: () => items[0].getBoundingClientRect(),\n    getClientRects: () => items.map((item) => item.getBoundingClientRect()),\n  }\n}\n","import {\n  createComputed,\n  createSignal,\n  useAttribute,\n  useEffect,\n  type ConnectableElement,\n  type ReadonlySignal,\n  type SetupOptions,\n} from '@aria-ui/core'\nimport { useOverlayPositionerState } from '@aria-ui/overlay/elements'\nimport { usePresence } from '@aria-ui/presence'\nimport type { ReferenceElement } from '@floating-ui/dom'\nimport type { Editor } from '@prosekit/core'\nimport type { Selection } from '@prosekit/pm/state'\n\nimport { useEditorFocusChangeEvent } from '../../../hooks/use-editor-focus-event.ts'\nimport { useEditorUpdateEvent } from '../../../hooks/use-editor-update-event.ts'\nimport { useKeymap } from '../../../hooks/use-keymap.ts'\n\nimport type { InlinePopoverEvents, InlinePopoverProps } from './types.ts'\nimport { getVirtualSelectionElement } from './virtual-selection-element.ts'\n\n/**\n * @internal\n */\nexport function useInlinePopover(\n  host: ConnectableElement,\n  { state, emit }: SetupOptions<InlinePopoverProps, InlinePopoverEvents>,\n): void {\n  const { editor, defaultOpen, open, ...overlayState } = state\n\n  const reference = useInlinePopoverReference(host, editor)\n  const hasReference = createComputed(() => !!reference.get())\n\n  useEffect(host, () => {\n    const hasReferenceValue = hasReference.get()\n    const defaultOpenValue = defaultOpen.peek()\n    const openValue = open.peek()\n\n    if (defaultOpenValue || openValue) {\n      emit('openChange', hasReferenceValue)\n    }\n  })\n\n  useEffect(host, () => {\n    const hasReferenceValue = hasReference.get()\n    const defaultOpenValue = defaultOpen.peek()\n\n    if (hasReferenceValue && defaultOpenValue) {\n      open.set(true)\n    } else if (!hasReferenceValue) {\n      open.set(false)\n    }\n  })\n\n  useKeymap(host, editor, {\n    Escape: () => {\n      if (!state.dismissOnEscape.peek() || !open.peek()) {\n        return false\n      }\n      open.set(false)\n      emit('openChange', false)\n      return true\n    },\n  })\n\n  useOverlayPositionerState(host, overlayState, { reference })\n\n  useAttribute(host, 'data-state', () => (open.get() ? 'open' : 'closed'))\n  usePresence(host, open)\n}\n\nfunction useInlinePopoverReference(\n  host: ConnectableElement,\n  editor: ReadonlySignal<Editor | null>,\n) {\n  const reference = createSignal<ReferenceElement | null>(null)\n  let editorFocused = false\n\n  useEditorFocusChangeEvent(host, editor, (focus) => {\n    editorFocused = focus\n  })\n\n  let prevSelection: Selection | undefined\n\n  useEditorUpdateEvent(host, editor, (view) => {\n    const isPopoverFocused = !editorFocused && host.contains(host.ownerDocument.activeElement)\n\n    if (isPopoverFocused) {\n      return\n    }\n\n    const { selection } = view.state\n    const selectionUnchanged = prevSelection?.eq(selection)\n    prevSelection = selection\n\n    // Skip reference update if only the document content has changed, not the\n    // selection itself.\n    //\n    // Example: If the user selects text and then applies mark bold using the\n    // popover, the selection may widen, but we don't want to reposition the\n    // popover.\n    if (selectionUnchanged) {\n      return\n    }\n\n    reference.set(getVirtualSelectionElement(view) || null)\n  })\n\n  return reference\n}\n","import type { EventDeclarations, PropDeclarations } from '@aria-ui/core'\nimport {\n  overlayPositionerEvents,\n  overlayPositionerProps,\n  type OverlayPositionerEvents,\n  type OverlayPositionerProps,\n} from '@aria-ui/overlay'\nimport type { Editor } from '@prosekit/core'\n\nexport interface InlinePopoverProps extends\n  Omit<\n    OverlayPositionerProps,\n    'placement' | 'offset' | 'hide' | 'overlap' | 'inline' | 'overflowPadding'\n  >\n{\n  /**\n   * The ProseKit editor instance.\n   *\n   * @default null\n   * @hidden\n   */\n  editor: Editor | null\n\n  /**\n   * Whether the popover is open by default when some inline content is\n   * selected.\n   *\n   * When `defaultOpen` is true, the popover will open or close based on the\n   * inline selection. When `defaultOpen` is false, the popover will never be\n   * opened unless the `open` prop is true.\n   *\n   * @default true\n   */\n  defaultOpen: boolean\n\n  /**\n   * Whether the popover is open.\n   *\n   * Notice that the popover will be always hidden if the inline selection is\n   * empty.\n   *\n   * @default false\n   */\n  open: boolean\n\n  /**\n   * Whether the inline popover should be dismissed when the editor receives an\n   * Escape key press.\n   *\n   * @default true\n   */\n  dismissOnEscape: boolean\n\n  /**\n   * @default \"top\"\n   */\n  placement: OverlayPositionerProps['placement']\n\n  /**\n   * @default 12\n   */\n  offset: OverlayPositionerProps['offset']\n\n  /**\n   * @default true\n   */\n  hide: OverlayPositionerProps['hide']\n\n  /**\n   * @default true\n   */\n  overlap: OverlayPositionerProps['overlap']\n\n  /**\n   * @default true\n   */\n  inline: OverlayPositionerProps['inline']\n\n  /**\n   * @default 8\n   */\n  overflowPadding: OverlayPositionerProps['overflowPadding']\n}\n\n/** @internal */\nexport const inlinePopoverProps: PropDeclarations<InlinePopoverProps> = Object.freeze({\n  ...overlayPositionerProps,\n  editor: { default: null },\n  defaultOpen: { default: true },\n  open: { default: false },\n  dismissOnEscape: { default: true },\n\n  placement: { default: 'top' },\n  offset: { default: 12 },\n  hide: { default: true },\n  overlap: { default: true },\n  inline: { default: true },\n  overflowPadding: { default: 8 },\n})\n\nexport interface InlinePopoverEvents extends OverlayPositionerEvents {\n  /**\n   * Fired when the open state changes.\n   */\n  openChange: CustomEvent<boolean>\n}\n\n/** @internal */\nexport const inlinePopoverEvents: EventDeclarations<InlinePopoverEvents> = {\n  ...overlayPositionerEvents,\n  openChange: {},\n}\n","import { defineCustomElement, registerCustomElement, type BaseElementConstructor } from \"@aria-ui/core\"\n\nimport { useInlinePopover } from \"./setup.ts\"\nimport { inlinePopoverEvents, inlinePopoverProps, type InlinePopoverEvents, type InlinePopoverProps } from \"./types.ts\"\n\nconst InlinePopoverElementBase: BaseElementConstructor<InlinePopoverProps> = defineCustomElement<\n  InlinePopoverProps,\n  InlinePopoverEvents\n>({\n  props: inlinePopoverProps,\n  events: inlinePopoverEvents,\n  setup: useInlinePopover,\n})\nclass InlinePopoverElement extends InlinePopoverElementBase {}\n\nregisterCustomElement('prosekit-inline-popover', InlinePopoverElement)\n  \nexport { InlinePopoverElement }\n"],"mappings":"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"}