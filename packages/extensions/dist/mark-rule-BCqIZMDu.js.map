{"version":3,"file":"mark-rule-BCqIZMDu.js","names":["stack: Array<[start: number, node: ProseMirrorNode]>","ranges: Array<[number, number]>","start","ranges: MarkRange[]","result: MarkRange[]","mark","tr","toRemove: MarkRange[]","toCreate: MarkRange[]","rules: MarkRuleOptions[]"],"sources":["../src/mark-rule/range.ts","../src/mark-rule/apply.ts","../src/mark-rule/mark-rule.ts"],"sourcesContent":["import type {\n  ProseMirrorNode,\n  ResolvedPos,\n} from '@prosekit/pm/model'\nimport type {\n  EditorState,\n  Transaction,\n} from '@prosekit/pm/state'\nimport type { ProsemirrorNode } from 'prosemirror-flat-list'\n\nfunction getSpanTextRanges($from: ResolvedPos, $to: ResolvedPos) {\n  const nodeRange = $from.blockRange($to)\n  if (!nodeRange) {\n    return []\n  }\n\n  const stack: Array<[start: number, node: ProseMirrorNode]> = []\n  let start = nodeRange.start\n\n  for (let i = nodeRange.startIndex; i < nodeRange.endIndex; i++) {\n    const child = nodeRange.parent.child(i)\n    stack.push([start, child])\n    start += child.nodeSize\n  }\n\n  const ranges: Array<[number, number]> = []\n\n  while (stack.length > 0) {\n    const [start, node] = stack.pop()!\n    if (node.type.spec.code) {\n      continue\n    }\n\n    if (node.type.isTextblock) {\n      ranges.push([start + 1, start + 1 + node.content.size])\n      continue\n    }\n\n    node.forEach((child, offset) => {\n      stack.push([start + offset + 1, child])\n    })\n  }\n\n  return ranges\n}\n\nfunction getInlineTextRange(\n  $from: ResolvedPos,\n  $to: ResolvedPos,\n): [number, number] {\n  return [$from.start(), $to.end()]\n}\n\nfunction getTextRanges(\n  doc: ProsemirrorNode,\n  from: number,\n  to: number,\n): Array<[number, number]> {\n  const $from = doc.resolve(from)\n  const $to = doc.resolve(to)\n\n  if ($from.sameParent($to) && $from.parent.isTextblock) {\n    return [getInlineTextRange($from, $to)]\n  } else {\n    const nodeRange = $from.blockRange($to)\n    if (!nodeRange) {\n      return []\n    }\n\n    return getSpanTextRanges($from, $to)\n  }\n}\n\nfunction getMapRange(\n  transactions: readonly Transaction[],\n  oldState: EditorState,\n  newState: EditorState,\n) {\n  let lo = oldState.selection.from\n  let hi = oldState.selection.to\n\n  for (const tr of transactions) {\n    for (const map of tr.mapping.maps) {\n      lo = map.map(lo)\n      hi = map.map(hi)\n\n      map.forEach((_oldStart, _oldEnd, newStart, newEnd) => {\n        lo = Math.min(lo, hi, newStart)\n        hi = Math.max(lo, hi, newEnd)\n      })\n    }\n  }\n\n  lo = Math.min(lo, hi, newState.selection.from)\n  hi = Math.min(lo, hi, newState.selection.to)\n\n  return [lo, hi] as const\n}\n\nexport function getCheckRanges(\n  transactions: readonly Transaction[],\n  oldState: EditorState,\n  newState: EditorState,\n): Array<[number, number]> {\n  const [from, to] = getMapRange(transactions, oldState, newState)\n  return getTextRanges(newState.doc, from, to)\n}\n","import {\n  getMarkType,\n  maybeRun,\n  OBJECT_REPLACEMENT_CHARACTER,\n} from '@prosekit/core'\nimport type {\n  Mark,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\nimport type {\n  EditorState,\n  Transaction,\n} from '@prosekit/pm/state'\n\nimport { getCheckRanges } from './range'\nimport type { MarkRuleOptions } from './types'\n\ntype MarkRange = [from: number, to: number, mark: Mark]\n\nfunction getExpectedMarkings(\n  rules: MarkRuleOptions[],\n  doc: ProseMirrorNode,\n  from: number,\n  to: number,\n): MarkRange[] {\n  const text = doc.textBetween(from, to, null, OBJECT_REPLACEMENT_CHARACTER)\n  const ranges: MarkRange[] = []\n\n  for (const rule of rules) {\n    rule.regex.lastIndex = 0\n    const matches = text.matchAll(rule.regex)\n    const markType = getMarkType(doc.type.schema, rule.type)\n\n    for (const match of matches) {\n      const index = match.index\n      if (index == null) continue\n      const attrs = maybeRun(rule.attrs, match)\n      const mark = markType.create(attrs)\n      ranges.push([from + index, from + index + match[0].length, mark])\n    }\n  }\n\n  // Sort by start position. If start positions are equal, the longer match\n  // should be prioritized.\n  ranges.sort((a, b) => a[0] - b[0] || b[1] - a[1])\n\n  // Remove overlapped marks.\n  const result: MarkRange[] = []\n  let freeIndex = 0\n\n  for (const range of ranges) {\n    if (range[0] >= freeIndex) {\n      result.push(range)\n      freeIndex = range[1]\n    }\n  }\n\n  return result\n}\n\nfunction getReceivedMarkings(\n  rules: MarkRuleOptions[],\n  doc: ProseMirrorNode,\n  from: number,\n  to: number,\n): MarkRange[] {\n  const result: MarkRange[] = []\n  const schema = doc.type.schema\n  const markTypes = rules.map((rule) => getMarkType(schema, rule.type))\n\n  doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) {\n      return\n    }\n\n    for (const markType of markTypes) {\n      const mark = node.marks.find((mark) => mark.type === markType)\n      if (mark) {\n        result.push([pos, pos + node.nodeSize, mark])\n      }\n    }\n  })\n  return result\n}\n\nfunction markRangeEquals(a: MarkRange, b: MarkRange): boolean {\n  return a[0] === b[0] && a[1] === b[1] && a[2].eq(b[2])\n}\n\nfunction markRangeDiffs(a: MarkRange[], b: MarkRange[]): MarkRange[] {\n  return a.filter((x) => !b.some((y) => markRangeEquals(x, y)))\n}\n\nexport function applyMarkRules(\n  rules: MarkRuleOptions[],\n  transactions: readonly Transaction[],\n  oldState: EditorState,\n  newState: EditorState,\n): Transaction | null {\n  if (transactions.length === 0 || transactions.every((tr) => !tr.docChanged)) {\n    return null\n  }\n\n  const ranges = getCheckRanges(transactions, oldState, newState)\n\n  const toRemove: MarkRange[] = []\n  const toCreate: MarkRange[] = []\n\n  for (const [from, to] of ranges) {\n    const expected = getExpectedMarkings(rules, newState.doc, from, to)\n    const received = getReceivedMarkings(rules, newState.doc, from, to)\n\n    toRemove.push(...markRangeDiffs(received, expected))\n    toCreate.push(...markRangeDiffs(expected, received))\n  }\n\n  if (toCreate.length === 0 && toRemove.length === 0) {\n    return null\n  }\n\n  const tr = newState.tr\n  for (const [from, to, mark] of toRemove) {\n    tr.removeMark(from, to, mark)\n  }\n  for (const [from, to, mark] of toCreate) {\n    tr.addMark(from, to, mark)\n  }\n  return tr\n}\n","import {\n  defineFacet,\n  defineFacetPayload,\n  pluginFacet,\n  type PlainExtension,\n  type PluginPayload,\n} from '@prosekit/core'\nimport {\n  PluginKey,\n  ProseMirrorPlugin,\n  type EditorState,\n  type Transaction,\n} from '@prosekit/pm/state'\n\nimport { applyMarkRules } from './apply'\nimport type { MarkRuleOptions } from './types'\n\n/**\n * A mark rule is something that can automatically apply marks to text if it\n * matches a certain pattern, and remove them if it doesn't match anymore.\n */\nexport function defineMarkRule(options: MarkRuleOptions): PlainExtension {\n  return defineFacetPayload(markRuleFacet, [options]) as PlainExtension\n}\n\nconst markRuleFacet = defineFacet<MarkRuleOptions, PluginPayload>({\n  reduce: () => {\n    let rules: MarkRuleOptions[] = []\n\n    const plugin = new ProseMirrorPlugin({\n      key: new PluginKey('prosekit-mark-rule'),\n      appendTransaction: (\n        transactions: readonly Transaction[],\n        oldState: EditorState,\n        newState: EditorState,\n      ) => {\n        return applyMarkRules(rules, transactions, oldState, newState)\n      },\n    })\n\n    return function reducer(input) {\n      rules = input\n      return plugin\n    }\n  },\n\n  parent: pluginFacet,\n})\n"],"mappings":"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"}