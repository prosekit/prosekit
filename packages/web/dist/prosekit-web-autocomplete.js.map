{"version":3,"file":"prosekit-web-autocomplete.js","names":["useAutocompleteEmpty: typeof useListboxEmpty","autocompleteEmptyProps: PropDeclarations<AutocompleteEmptyProps>","autocompleteEmptyEvents: EventDeclarations<AutocompleteEmptyEvents>","AutocompleteEmptyElementBase: BaseElementConstructor<AutocompleteEmptyProps>","queryContext: Context<string>","onSubmitContext: Context<VoidFunction | null>","openContext: Context<boolean>","autocompleteItemProps: PropDeclarations<AutocompleteItemProps>","autocompleteItemEvents: EventDeclarations<AutocompleteItemEvents>","AutocompleteItemElementBase: BaseElementConstructor<AutocompleteItemProps>","keydownHandlers: ((event: KeyboardEvent) => void)[]","autocompleteListProps: PropDeclarations<AutocompleteListProps>","listboxProps","autocompleteListEvents: EventDeclarations<AutocompleteListEvents>","AutocompleteListElementBase: BaseElementConstructor<AutocompleteListProps>","handleEnter: MatchHandler","autocompletePopoverProps: PropDeclarations<AutocompletePopoverProps>","autocompletePopoverEvents: EventDeclarations<AutocompletePopoverEvents>","AutocompletePopoverElementBase: BaseElementConstructor<AutocompletePopoverProps>"],"sources":["../src/components/autocomplete/autocomplete-empty/setup.ts","../src/components/autocomplete/autocomplete-empty/types.ts","../src/components/autocomplete/autocomplete-empty/element.gen.ts","../src/components/autocomplete/context.ts","../src/components/autocomplete/autocomplete-item/setup.ts","../src/components/autocomplete/autocomplete-item/types.ts","../src/components/autocomplete/autocomplete-item/element.gen.ts","../src/components/autocomplete/autocomplete-list/setup.ts","../src/components/autocomplete/autocomplete-list/types.ts","../src/components/autocomplete/autocomplete-list/element.gen.ts","../src/hooks/use-first-rendering.ts","../src/components/autocomplete/autocomplete-popover/helpers.ts","../src/components/autocomplete/autocomplete-popover/setup.ts","../src/components/autocomplete/autocomplete-popover/types.ts","../src/components/autocomplete/autocomplete-popover/element.gen.ts"],"sourcesContent":["import { useListboxEmpty } from '@aria-ui/listbox/elements'\n\n/**\n * @internal\n */\nexport const useAutocompleteEmpty: typeof useListboxEmpty = useListboxEmpty\n","import type {\n  EventDeclarations,\n  PropDeclarations,\n} from '@aria-ui/core'\n\n/** @internal */\nexport interface AutocompleteEmptyProps {}\n\n/** @internal */\nexport const autocompleteEmptyProps: PropDeclarations<AutocompleteEmptyProps> = {}\n\n/** @internal */\nexport interface AutocompleteEmptyEvents {}\n\n/** @internal */\nexport const autocompleteEmptyEvents: EventDeclarations<AutocompleteEmptyEvents> = {}\n","import { defineCustomElement, registerCustomElement, type BaseElementConstructor } from \"@aria-ui/core\"\n\nimport { useAutocompleteEmpty } from \"./setup\"\nimport { autocompleteEmptyEvents, autocompleteEmptyProps, type AutocompleteEmptyEvents, type AutocompleteEmptyProps } from \"./types\"\n\nconst AutocompleteEmptyElementBase: BaseElementConstructor<AutocompleteEmptyProps> = defineCustomElement<\n  AutocompleteEmptyProps,\n  AutocompleteEmptyEvents\n>({\n  props: autocompleteEmptyProps,\n  events: autocompleteEmptyEvents,\n  setup: useAutocompleteEmpty,\n})\nclass AutocompleteEmptyElement extends AutocompleteEmptyElementBase {}\n\nregisterCustomElement('prosekit-autocomplete-empty', AutocompleteEmptyElement)\n  \nexport { AutocompleteEmptyElement }\n","import {\n  createContext,\n  type Context,\n} from '@aria-ui/core'\n\nexport const queryContext: Context<string> = createContext(\n  'prosekit/autocomplete-popover/query',\n  '',\n)\n\nexport const onSubmitContext: Context<VoidFunction | null> = createContext(\n  'prosekit/autocomplete-popover/onSubmit',\n  null,\n)\n\nexport const openContext: Context<boolean> = createContext(\n  'prosekit/autocomplete-popover/open',\n  false,\n)\n","import {\n  useEffect,\n  useEventListener,\n  type ConnectableElement,\n  type SetupOptions,\n} from '@aria-ui/core'\nimport { useListboxItem } from '@aria-ui/listbox/elements'\n\nimport { openContext } from '../context'\n\nimport type {\n  AutocompleteItemEvents,\n  AutocompleteItemProps,\n} from './types'\n\n/**\n * @internal\n */\nexport function useAutocompleteItem(\n  element: ConnectableElement,\n  { state, emit }: SetupOptions<AutocompleteItemProps, AutocompleteItemEvents>,\n): void {\n  useListboxItem(element, { state, emit })\n\n  const open = openContext.consume(element)\n\n  useEffect(element, () => {\n    // Check the text content again when the open state changes\n    if (!state.value.peek() && open.get()) {\n      state.value.set(element.textContent ?? '')\n    }\n  })\n\n  useEventListener(element, 'pointerdown', (event) => {\n    // Prevent the editor from losing focus\n    event.preventDefault()\n  })\n}\n","import type {\n  EventDeclarations,\n  PropDeclarations,\n} from '@aria-ui/core'\nimport {\n  listboxItemEvents,\n  type ListboxItemEvents,\n} from '@aria-ui/listbox'\n\nexport interface AutocompleteItemProps {\n  /**\n   * The value of the item, which will be matched against the query.\n   *\n   * If not provided, the value is the item's text content.\n   *\n   * @default \"\"\n   */\n  value: string\n}\n\n/** @internal */\nexport const autocompleteItemProps: PropDeclarations<AutocompleteItemProps> = {\n  value: {\n    default: '',\n  },\n}\n\nexport interface AutocompleteItemEvents extends ListboxItemEvents {}\n\n/** @internal */\nexport const autocompleteItemEvents: EventDeclarations<AutocompleteItemEvents> = listboxItemEvents\n","import { defineCustomElement, registerCustomElement, type BaseElementConstructor } from \"@aria-ui/core\"\n\nimport { useAutocompleteItem } from \"./setup\"\nimport { autocompleteItemEvents, autocompleteItemProps, type AutocompleteItemEvents, type AutocompleteItemProps } from \"./types\"\n\nconst AutocompleteItemElementBase: BaseElementConstructor<AutocompleteItemProps> = defineCustomElement<\n  AutocompleteItemProps,\n  AutocompleteItemEvents\n>({\n  props: autocompleteItemProps,\n  events: autocompleteItemEvents,\n  setup: useAutocompleteItem,\n})\nclass AutocompleteItemElement extends AutocompleteItemElementBase {}\n\nregisterCustomElement('prosekit-autocomplete-item', AutocompleteItemElement)\n  \nexport { AutocompleteItemElement }\n","import {\n  createSignal,\n  useEffect,\n  type ConnectableElement,\n  type ReadonlySignal,\n  type SetupOptions,\n  type TypedEventTarget,\n} from '@aria-ui/core'\nimport {\n  listboxProps,\n  useListbox,\n  type ListboxProps,\n} from '@aria-ui/listbox/elements'\nimport {\n  defineDOMEventHandler,\n  Priority,\n  withPriority,\n  type Editor,\n} from '@prosekit/core'\n\nimport { getStateWithDefaults } from '../../../utils/get-default-state'\nimport {\n  onSubmitContext,\n  openContext,\n  queryContext,\n} from '../context'\n\nimport type {\n  AutocompleteListEvents,\n  AutocompleteListProps,\n} from './types'\n\n/**\n * @internal\n */\nexport function useAutocompleteList(\n  element: ConnectableElement,\n  { state, emit }: SetupOptions<AutocompleteListProps, AutocompleteListEvents>,\n): void {\n  const open = openContext.consume(element)\n  const query = queryContext.consume(element)\n  const onSubmit = onSubmitContext.consume(element)\n\n  const keydownTarget = useKeyDownTarget(element, open, state.editor)\n\n  const listboxState = getStateWithDefaults<ListboxProps>(\n    { filter: state.filter, eventTarget: createSignal(keydownTarget) },\n    listboxProps,\n  )\n\n  useEffect(element, () => {\n    element.addEventListener('valueChange', () => {\n      if (onSubmit) {\n        onSubmit.get()?.()\n      }\n    })\n  })\n\n  useListbox(element, { state: listboxState, emit })\n\n  useEffect(element, () => {\n    listboxState.query.set(query.get())\n  })\n\n  useEffect(element, () => {\n    if (!open.get()) {\n      listboxState.value.set('')\n      query.set('')\n    }\n  })\n\n  // Reset the focused item when the popover is open\n  useEffect(element, () => {\n    if (!open.get()) {\n      listboxState.autoFocus.set(false)\n    } else {\n      let canceled = false\n\n      requestAnimationFrame(() => {\n        if (canceled) return\n        listboxState.autoFocus.set(true)\n      })\n\n      return () => {\n        canceled = true\n      }\n    }\n  })\n\n  // The autocomplete list should not be focusable because the editor will get\n  // the focus during typing.\n  useEffect(element, () => {\n    element.tabIndex = -1\n  })\n}\n\nfunction useKeyDownTarget(\n  element: ConnectableElement,\n  open: ReadonlySignal<boolean>,\n  editor: ReadonlySignal<Editor | null>,\n): TypedEventTarget<'keydown'> {\n  const keydownHandlers: ((event: KeyboardEvent) => void)[] = []\n\n  useEffect(element, () => {\n    const editorValue = editor.get()\n\n    if (!editorValue) {\n      return\n    }\n\n    const extension = defineDOMEventHandler(\n      'keydown',\n      (view, event): boolean => {\n        if (view.composing || event.defaultPrevented || !open.get()) {\n          return false\n        }\n        keydownHandlers.forEach((handler) => handler(event))\n        return event.defaultPrevented\n      },\n    )\n\n    return editorValue.use(withPriority(extension, Priority.highest))\n  })\n\n  return {\n    addEventListener: (type, listener) => {\n      if (type === 'keydown') {\n        keydownHandlers.push(listener)\n      }\n    },\n    removeEventListener: (type, listener) => {\n      if (type === 'keydown') {\n        const index = keydownHandlers.indexOf(listener)\n        if (index !== -1) {\n          keydownHandlers.splice(index, 1)\n        }\n      }\n    },\n  }\n}\n","import type {\n  EventDeclarations,\n  PropDeclarations,\n} from '@aria-ui/core'\nimport {\n  listboxEvents,\n  listboxProps,\n  type ListboxEvents,\n  type ListboxProps,\n} from '@aria-ui/listbox'\nimport type { Editor } from '@prosekit/core'\n\nexport interface AutocompleteListProps extends Pick<ListboxProps, 'filter'> {\n  /**\n   * The ProseKit editor instance.\n   *\n   * @default null\n   * @hidden\n   */\n  editor: Editor | null\n}\n\nexport const autocompleteListProps: PropDeclarations<AutocompleteListProps> = {\n  filter: listboxProps.filter,\n  editor: { default: null },\n}\n\nexport interface AutocompleteListEvents extends ListboxEvents {}\n\nexport const autocompleteListEvents: EventDeclarations<AutocompleteListEvents> = { ...listboxEvents }\n","import { defineCustomElement, registerCustomElement, type BaseElementConstructor } from \"@aria-ui/core\"\n\nimport { useAutocompleteList } from \"./setup\"\nimport { autocompleteListEvents, autocompleteListProps, type AutocompleteListEvents, type AutocompleteListProps } from \"./types\"\n\nconst AutocompleteListElementBase: BaseElementConstructor<AutocompleteListProps> = defineCustomElement<\n  AutocompleteListProps,\n  AutocompleteListEvents\n>({\n  props: autocompleteListProps,\n  events: autocompleteListEvents,\n  setup: useAutocompleteList,\n})\nclass AutocompleteListElement extends AutocompleteListElementBase {}\n\nregisterCustomElement('prosekit-autocomplete-list', AutocompleteListElement)\n  \nexport { AutocompleteListElement }\n","import {\n  createSignal,\n  useEffect,\n  type ConnectableElement,\n  type ReadonlySignal,\n} from '@aria-ui/core'\n\nexport function useFirstRendering(\n  host: ConnectableElement,\n): ReadonlySignal<boolean> {\n  const firstRendering = createSignal(true)\n\n  useEffect(host, () => {\n    requestAnimationFrame(() => {\n      firstRendering.set(false)\n    })\n  })\n\n  return firstRendering\n}\n","export function defaultQueryBuilder(match: RegExpExecArray): string {\n  return match[0]\n    .toLowerCase()\n    .replace(/[!\"#$%&'()*+,-./:;<=>?@[\\\\\\]^_`{|}~]/g, '')\n    .replace(/\\s\\s+/g, ' ')\n    .trim()\n}\n","import {\n  createComputed,\n  createSignal,\n  useAnimationFrame,\n  useAttribute,\n  useEffect,\n  type ConnectableElement,\n  type ReadonlySignal,\n  type SetupOptions,\n  type Signal,\n} from '@aria-ui/core'\nimport { useOverlayPositionerState } from '@aria-ui/overlay/elements'\nimport { usePresence } from '@aria-ui/presence'\nimport {\n  defineKeymap,\n  Priority,\n  withPriority,\n  type Editor,\n} from '@prosekit/core'\nimport {\n  AutocompleteRule,\n  defineAutocomplete,\n  type MatchHandler,\n} from '@prosekit/extensions/autocomplete'\n\nimport { useEditorExtension } from '../../../hooks/use-editor-extension'\nimport { useFirstRendering } from '../../../hooks/use-first-rendering'\nimport { getSafeEditorView } from '../../../utils/get-safe-editor-view'\nimport {\n  onSubmitContext,\n  openContext,\n  queryContext,\n} from '../context'\n\nimport { defaultQueryBuilder } from './helpers'\nimport type {\n  AutocompletePopoverEvents,\n  AutocompletePopoverProps,\n} from './types'\n\n/**\n * @internal\n */\nexport function useAutocompletePopover(\n  host: ConnectableElement,\n  {\n    state,\n    emit,\n  }: SetupOptions<AutocompletePopoverProps, AutocompletePopoverEvents>,\n): void {\n  const { editor, regex, ...overlayState } = state\n\n  const reference = createSignal<Element | null>(null)\n  const query = createSignal<string>('')\n  const onDismiss = createSignal<VoidFunction | null>(null)\n  const onSubmit = createSignal<VoidFunction | null>(null)\n  const presence = createComputed(() => !!reference.get())\n\n  queryContext.provide(host, query)\n  onSubmitContext.provide(host, onSubmit)\n  openContext.provide(host, presence)\n\n  useEscapeKeydown(host, editor, createKeymapHandler(onDismiss, presence))\n\n  useAutocompleteExtension(\n    host,\n    editor,\n    regex,\n    reference,\n    query,\n    onDismiss,\n    onSubmit,\n  )\n\n  useOverlayPositionerState(host, overlayState, { reference })\n\n  useAttribute(host, 'data-state', () => (presence.get() ? 'open' : 'closed'))\n  usePresence(host, presence)\n\n  const firstRendering = useFirstRendering(host)\n\n  useEffect(host, () => {\n    const queryValue = query.get()\n\n    if (!firstRendering.peek()) {\n      emit('queryChange', queryValue)\n    }\n  })\n\n  useAnimationFrame(host, () => {\n    const presenceValue = presence.get()\n    return () => {\n      emit('openChange', presenceValue)\n    }\n  })\n}\n\nfunction useAutocompleteExtension(\n  host: ConnectableElement,\n  editor: ReadonlySignal<Editor | null>,\n  regex: ReadonlySignal<RegExp | null>,\n  reference: Signal<Element | null>,\n  query: Signal<string>,\n  onDismiss: Signal<VoidFunction | null>,\n  onSubmit: Signal<VoidFunction | null>,\n) {\n  useEffect(host, () => {\n    const editorValue = editor.get()\n    const regexValue = regex.get()\n\n    if (!editorValue || !regexValue) {\n      return\n    }\n\n    const rule = createAutocompleteRule(\n      editorValue,\n      regexValue,\n      reference,\n      query,\n      onDismiss,\n      onSubmit,\n    )\n    const extension = defineAutocomplete(rule)\n    return editorValue.use(extension)\n  })\n}\n\nfunction createAutocompleteRule(\n  editor: Editor,\n  regex: RegExp,\n  reference: Signal<Element | null>,\n  query: Signal<string>,\n  onDismiss: Signal<VoidFunction | null>,\n  onSubmit: Signal<VoidFunction | null>,\n) {\n  const handleEnter: MatchHandler = (options) => {\n    const view = getSafeEditorView(editor)\n    const span = view?.dom.querySelector('.prosemirror-prediction-match')\n\n    if (span) {\n      reference.set(span)\n    }\n\n    query.set(defaultQueryBuilder(options.match))\n    onDismiss.set(options.ignoreMatch)\n    onSubmit.set(options.deleteMatch)\n  }\n\n  const handleLeave = () => {\n    reference.set(null)\n    query.set('')\n  }\n\n  return new AutocompleteRule({\n    regex,\n    onEnter: handleEnter,\n    onLeave: handleLeave,\n  })\n}\n\nfunction createKeymapHandler(\n  handler: ReadonlySignal<VoidFunction | null>,\n  enabled: ReadonlySignal<boolean>,\n) {\n  return (): boolean => {\n    if (!enabled.get()) {\n      return false\n    }\n\n    const fn = handler.peek()\n    if (!fn) return false\n    fn()\n    return true\n  }\n}\n\nfunction useEscapeKeydown(\n  host: ConnectableElement,\n  editor: ReadonlySignal<Editor | null>,\n  handler: () => boolean,\n): void {\n  const keymap = { Escape: handler }\n  const extension = withPriority(defineKeymap(keymap), Priority.highest)\n  useEditorExtension(host, editor, extension)\n}\n","import type {\n  EventDeclarations,\n  PropDeclarations,\n} from '@aria-ui/core'\nimport {\n  overlayPositionerEvents,\n  overlayPositionerProps,\n  type OverlayPositionerEvents,\n  type OverlayPositionerProps,\n} from '@aria-ui/overlay/elements'\nimport type { Editor } from '@prosekit/core'\n\nexport interface AutocompletePopoverProps extends OverlayPositionerProps {\n  /**\n   * The ProseKit editor instance.\n   *\n   * @default null\n   * @hidden\n   */\n  editor: Editor | null\n\n  /**\n   * The regular expression to match the query text to autocomplete.\n   *\n   * @default null\n   */\n  regex: RegExp | null\n\n  /**\n   * The placement of the popover, relative to the text cursor.\n   *\n   * @default \"bottom-start\"\n   */\n  placement: OverlayPositionerProps['placement']\n\n  /**\n   * The distance between the popover and the hovered block.\n   *\n   * @default 4\n   */\n  offset: OverlayPositionerProps['offset']\n\n  /**\n   * @default true\n   */\n  inline: OverlayPositionerProps['inline']\n\n  /**\n   * @default true\n   */\n  hoist: OverlayPositionerProps['hoist']\n\n  /**\n   * @default true\n   */\n  fitViewport: OverlayPositionerProps['fitViewport']\n\n  /**\n   * @default \"The body element\"\n   */\n  boundary: OverlayPositionerProps['boundary']\n\n  /**\n   * @default 8\n   */\n  overflowPadding: OverlayPositionerProps['overflowPadding']\n}\n\nconst body = typeof document !== 'undefined' && document.querySelector('body')\nconst defaultBoundary = body || 'clippingAncestors'\n\n/** @internal */\nexport const autocompletePopoverProps: PropDeclarations<AutocompletePopoverProps> = {\n  ...overlayPositionerProps,\n  editor: { default: null },\n  regex: { default: null },\n  placement: { default: 'bottom-start' },\n  offset: { default: 4 },\n  inline: { default: true },\n  hoist: { default: true },\n  fitViewport: { default: true },\n  boundary: { default: defaultBoundary },\n  overflowPadding: { default: 8 },\n}\n\nexport interface AutocompletePopoverEvents extends OverlayPositionerEvents {\n  /**\n   * Fired when the open state changes.\n   */\n  openChange: CustomEvent<boolean>\n\n  /**\n   * Fired when the query changes.\n   */\n  queryChange: CustomEvent<string>\n}\n\n/** @internal */\nexport const autocompletePopoverEvents: EventDeclarations<AutocompletePopoverEvents> = {\n  ...overlayPositionerEvents,\n  openChange: {},\n  queryChange: {},\n}\n","import { defineCustomElement, registerCustomElement, type BaseElementConstructor } from \"@aria-ui/core\"\n\nimport { useAutocompletePopover } from \"./setup\"\nimport { autocompletePopoverEvents, autocompletePopoverProps, type AutocompletePopoverEvents, type AutocompletePopoverProps } from \"./types\"\n\nconst AutocompletePopoverElementBase: BaseElementConstructor<AutocompletePopoverProps> = defineCustomElement<\n  AutocompletePopoverProps,\n  AutocompletePopoverEvents\n>({\n  props: autocompletePopoverProps,\n  events: autocompletePopoverEvents,\n  setup: useAutocompletePopover,\n})\nclass AutocompletePopoverElement extends AutocompletePopoverElementBase {}\n\nregisterCustomElement('prosekit-autocomplete-popover', AutocompletePopoverElement)\n  \nexport { AutocompletePopoverElement }\n"],"mappings":"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"}