{"version":3,"file":"prosekit-core.js","names":["positions: number[]","baseToggleMark","setBlockType","pluginFacet: Facet<PluginPayload, StatePayload>","plugins: ProseMirrorPlugin[]","fn","serializeFragmentWrapper?: FunctionWrapper<SerializeFragmentFunction>","serializeNodeWrapper?: FunctionWrapper<SerializeNodeFunction>","fn: SerializeFragmentFunction","args","fn: SerializeNodeFunction","nodesFromSchema: NodesFromSchemaFunction","marksFromSchema: MarksFromSchemaFunction","options: ClipboardSerializerOptions","commandFacet: Facet<CommandPayload, RootPayload>","commands","schemaSpecFacet: Facet<SchemaSpec, SchemaSpec>","topNode: string | undefined","result: Partial<Record<K, T[]>>","result: { [K in keyof T]?: T[K][] }","attrs: T['attrs']","parseDOM: T['parseDOM']","insertedAttrs: Record<string, unknown>","oldAttrs: Record<string, unknown>","topNodeName: string | undefined","mountHandlers: MountHandler[]","updateHandlers: UpdateHandler[]","unmountHandlers: UnmountHandler[]","view","handlers: Handler[]","domEventFacet: Facet<DOMEventPayload, PluginPayload>","setHandlersMap: Record<string, Setter<DOMEventHandler[]>>","combinedHandlerMap: Record<string, DOMEventHandler>","plugin: ProseMirrorPlugin | undefined","e: DOMEventHandler","map: Record<string, DOMEventHandler[] | undefined>","editorEventFacet: Facet<EditorEventPayload, PluginPayload>","isApple: boolean","keymap","keymapFacet: Facet<KeymapPayload, PluginPayload>","handler: Handler | undefined","handlerWrapper: Handler","bindings: Record<string, Command[]>","commands","keymap: Keymap","markViews: { [markName: string]: MarkViewConstructor }","isServer","markViews: { [markName: string]: MarkViewConstructor }","factory","nodeViews: { [nodeName: string]: NodeViewConstructor }","nodeViews: { [nodeName: string]: NodeViewConstructor }","factory","canUseRegexLookbehind: () => boolean","clsx: (\n  ...args: Array<string | boolean | null | undefined>\n) => string","children: ProseMirrorNode[]","nodes: ProseMirrorNode[]"],"sources":["../src/commands/add-mark.ts","../src/commands/expand-mark.ts","../src/utils/default-block-at.ts","../src/commands/insert-default-block.ts","../src/utils/set-selection-around.ts","../src/commands/insert-node.ts","../src/commands/remove-mark.ts","../src/utils/find-parent-node.ts","../src/utils/find-parent-node-of-type.ts","../src/commands/remove-node.ts","../src/utils/get-custom-selection.ts","../src/commands/set-block-type.ts","../src/utils/get-node-types.ts","../src/commands/set-node-attrs.ts","../src/commands/toggle-mark.ts","../src/commands/toggle-node.ts","../src/commands/wrap.ts","../src/commands/toggle-wrap.ts","../src/commands/unset-block-type.ts","../src/commands/unset-mark.ts","../src/editor/with-priority.ts","../src/extensions/plugin.ts","../src/extensions/clipboard-serializer.ts","../src/commands/insert-text.ts","../src/commands/select-all.ts","../src/facets/command.ts","../src/extensions/command.ts","../src/facets/schema-spec.ts","../src/utils/array-grouping.ts","../src/utils/remove-undefined-values.ts","../src/utils/merge-objects.ts","../src/utils/merge-specs.ts","../src/utils/output-spec.ts","../src/extensions/node-spec.ts","../src/extensions/doc.ts","../src/extensions/events/plugin-view.ts","../src/extensions/events/doc-change.ts","../src/utils/combine-event-handlers.ts","../src/extensions/events/dom-event.ts","../src/extensions/events/editor-event.ts","../src/extensions/events/focus.ts","../src/utils/env.ts","../src/extensions/keymap.ts","../src/extensions/history.ts","../src/extensions/keymap-base.ts","../src/extensions/mark-spec.ts","../src/extensions/mark-view.ts","../src/extensions/mark-view-effect.ts","../src/extensions/node-view.ts","../src/extensions/node-view-effect.ts","../src/extensions/paragraph.ts","../src/extensions/text.ts","../src/utils/can-use-regex-lookbehind.ts","../src/utils/clsx.ts","../src/utils/collect-children.ts","../src/utils/collect-nodes.ts","../src/utils/contains-inline-node.ts","../src/utils/get-id.ts","../src/utils/is-at-block-start.ts","../src/utils/is-in-code-block.ts","../src/utils/maybe-run.ts","../src/utils/unicode.ts","../src/utils/with-skip-code-block.ts"],"sourcesContent":["import type {\n  Attrs,\n  MarkType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport type { CommandCreator } from '../types/extension-command'\nimport { getMarkType } from '../utils/get-mark-type'\n\n/**\n * @public\n */\nexport interface AddMarkOptions {\n  /**\n   * The type of the mark to add.\n   */\n  type: string | MarkType\n\n  /**\n   * The attributes of the mark to add.\n   */\n  attrs?: Attrs | null\n\n  /**\n   * The start position of the document. By default it will be the start position of current selection.\n   */\n  from?: number\n\n  /**\n   * The end position of the document. By default it will be the end position of current selection.\n   */\n  to?: number\n}\n\n/**\n * Returns a command that adds the given mark with the given attributes.\n *\n * @public\n */\nexport function addMark(options: AddMarkOptions): Command {\n  return (state, dispatch) => {\n    const mark = getMarkType(state.schema, options.type).create(options.attrs)\n    const from = options.from ?? state.selection.from\n    const to = options.to ?? state.selection.to\n    if (from > to) {\n      return false\n    }\n    dispatch?.(state.tr.addMark(from, to, mark))\n    return true\n  }\n}\n\naddMark satisfies CommandCreator\n","import type {\n  Mark,\n  MarkType,\n  ResolvedPos,\n} from '@prosekit/pm/model'\nimport {\n  TextSelection,\n  type Command,\n} from '@prosekit/pm/state'\n\nimport { getMarkType } from '../utils/get-mark-type'\n\n/**\n * @public\n */\nexport interface ExpandMarkOptions {\n  /**\n   * The type of the mark to expand.\n   */\n  type: string | MarkType\n}\n\n/**\n * Expands the selection to include the entire mark at the current position.\n *\n * @public\n */\nexport function expandMark(options: ExpandMarkOptions): Command {\n  return (state, dispatch) => {\n    const markType = getMarkType(state.schema, options.type)\n    const predicate = (mark: Mark) => mark.type === markType\n\n    const from = expandMarkBefore(state.selection.$from, predicate)\n    const to = expandMarkAfter(state.selection.$to, predicate)\n\n    if (from === state.selection.from && to === state.selection.to) {\n      return false\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setSelection(TextSelection.create(state.doc, from, to)))\n    }\n    return true\n  }\n}\n\nfunction expandMarkBefore(\n  $pos: ResolvedPos,\n  predicate: (mark: Mark) => boolean,\n): number {\n  const { parent } = $pos\n\n  if (!$pos.marks().some(predicate)) {\n    return $pos.pos\n  }\n\n  const index = $pos.index()\n  let boundaryIndex = index\n\n  for (let i = index; i >= 0; i--) {\n    const node = parent.child(i)\n    if (node.marks.some(predicate)) {\n      boundaryIndex = i\n    } else {\n      break\n    }\n  }\n\n  return $pos.posAtIndex(boundaryIndex)\n}\n\nfunction expandMarkAfter(\n  $pos: ResolvedPos,\n  predicate: (mark: Mark) => boolean,\n): number {\n  const { parent } = $pos\n\n  if (!$pos.marks().some(predicate)) {\n    return $pos.pos\n  }\n\n  const index = Math.max(0, $pos.indexAfter() - 1)\n  const childCount = parent.childCount\n  let boundaryIndex = index\n\n  for (let i = index; i < childCount; i++) {\n    const node = parent.child(i)\n    if (node.marks.some(predicate)) {\n      boundaryIndex = i\n    } else {\n      break\n    }\n  }\n\n  return $pos.posAtIndex(boundaryIndex) + parent.child(boundaryIndex).nodeSize\n}\n","import type {\n  ContentMatch,\n  NodeType,\n} from '@prosekit/pm/model'\n\n/**\n * @internal\n */\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i++) {\n    const { type } = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n","import {\n  TextSelection,\n  type Command,\n} from '@prosekit/pm/state'\n\nimport { defaultBlockAt } from '../utils/default-block-at'\n\n/**\n * @public\n */\nexport interface InsertDefaultBlockOptions {\n  /**\n   * The position to insert the node at. By default it will insert after the\n   * current selection.\n   */\n  pos?: number\n}\n\n/**\n * Returns a command that inserts a default block after current selection or at\n * the given position.\n *\n * @public\n */\nexport function insertDefaultBlock(\n  options?: InsertDefaultBlockOptions,\n): Command {\n  return (state, dispatch) => {\n    const $pos = options?.pos == null\n      ? state.selection.$to\n      : state.doc.resolve(options.pos)\n    const depth = $pos.parent.isTextblock ? $pos.depth - 1 : $pos.depth\n    const parent = $pos.node(depth)\n    const index = $pos.indexAfter(depth)\n    const type = defaultBlockAt(parent.contentMatchAt(index))\n    if (!type) return false\n    if (dispatch) {\n      const pos = $pos.posAtIndex(index, depth)\n      const node = type.createAndFill()\n      if (!node) return false\n      const tr = state.tr.insert(pos, node)\n      const selection = TextSelection.findFrom(tr.doc.resolve(pos), 1)\n      if (!selection) return false\n      tr.setSelection(selection)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n}\n","import {\n  TextSelection,\n  type Transaction,\n} from '@prosekit/pm/state'\n\nexport function setSelectionAround(tr: Transaction, pos: number): void {\n  const docSize = tr.doc.content.size\n  const $pos = tr.doc.resolve(pos > docSize ? docSize : pos < 0 ? 0 : pos)\n  const selection = TextSelection.between($pos, $pos)\n  tr.setSelection(selection)\n}\n","import type {\n  Attrs,\n  NodeType,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\nimport { insertPoint } from '@prosekit/pm/transform'\n\nimport { assert } from '../utils/assert'\nimport { getNodeType } from '../utils/get-node-type'\nimport { setSelectionAround } from '../utils/set-selection-around'\n\n/**\n * @public\n */\nexport interface InsertNodeOptions {\n  /**\n   * The node to insert. Either this or `type` must be provided.\n   */\n  node?: ProseMirrorNode\n\n  /**\n   * The type of the node to insert. Either this or `node` must be provided.\n   */\n  type?: string | NodeType\n\n  /**\n   * When `type` is provided, the attributes of the node to insert.\n   */\n  attrs?: Attrs\n\n  /**\n   * The position to insert the node at. By default it will be the anchor\n   * position of current selection.\n   */\n  pos?: number\n}\n\n/**\n * Returns a command that inserts the given node at the current selection or at\n * the given position.\n *\n * @public\n */\nfunction insertNode(options: InsertNodeOptions): Command {\n  return (state, dispatch) => {\n    const node = options.node\n      ? options.node\n      : options.type\n      ? getNodeType(state.schema, options.type).createAndFill(options.attrs)\n      : null\n\n    assert(node, 'You must provide either a node or a type')\n\n    const insertPos = insertPoint(\n      state.doc,\n      options.pos ?? state.selection.anchor,\n      node.type,\n    )\n    if (insertPos == null) return false\n\n    if (dispatch) {\n      const tr = state.tr.insert(insertPos, node)\n      setSelectionAround(tr, insertPos + node.nodeSize)\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\nexport { insertNode }\n","import type {\n  Attrs,\n  MarkType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport type { CommandCreator } from '../types/extension-command'\nimport { getMarkType } from '../utils/get-mark-type'\n\n/**\n * @public\n */\nexport interface RemoveMarkOptions {\n  /**\n   * The type of the mark to remove.\n   */\n  type: string | MarkType\n\n  /**\n   * If attrs is given, remove precisely the mark with the given attrs. Otherwise, remove all marks of the given type.\n   */\n  attrs?: Attrs | null\n\n  /**\n   * The start position of the document. By default it will be the start position of current selection.\n   */\n  from?: number\n\n  /**\n   * The end position of the document. By default it will be the end position of current selection.\n   */\n  to?: number\n}\n\n/**\n * Returns a command that removes the given mark.\n *\n * @public\n */\nexport function removeMark(options: RemoveMarkOptions): Command {\n  return (state, dispatch) => {\n    const markType = getMarkType(state.schema, options.type)\n    const mark = options.attrs ? markType.create(options.attrs) : markType\n    const from = options.from ?? state.selection.from\n    const to = options.to ?? state.selection.to\n    if (from > to) {\n      return false\n    }\n    dispatch?.(state.tr.removeMark(from, to, mark))\n    return true\n  }\n}\n\nremoveMark satisfies CommandCreator\n","import type {\n  ProseMirrorNode,\n  ResolvedPos,\n} from '@prosekit/pm/model'\n\n/**\n * @public\n */\nexport interface FindParentNodeResult {\n  /**\n   * The closest parent node that satisfies the predicate.\n   */\n  node: ProseMirrorNode\n\n  /**\n   * The position directly before the node.\n   */\n  pos: number\n\n  /**\n   * The position at the start of the node.\n   */\n  start: number\n\n  /**\n   * The depth of the node.\n   */\n  depth: number\n}\n\n/**\n * Find the closest parent node that satisfies the predicate.\n *\n * @public\n */\nexport function findParentNode(\n  /**\n   * The predicate to test the parent node.\n   */\n  predicate: (node: ProseMirrorNode) => boolean,\n  /**\n   * The position to start searching from.\n   */\n  $pos: ResolvedPos,\n): FindParentNodeResult | undefined {\n  for (let depth = $pos.depth; depth >= 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (predicate(node)) {\n      const pos = depth === 0 ? 0 : $pos.before(depth)\n      const start = $pos.start(depth)\n      return { node, pos, start, depth }\n    }\n  }\n}\n","import type {\n  NodeType,\n  ResolvedPos,\n} from '@prosekit/pm/model'\n\nimport {\n  findParentNode,\n  type FindParentNodeResult,\n} from './find-parent-node'\nimport { getNodeType } from './get-node-type'\n\n/**\n * Finds the closest parent node that matches the given node type.\n *\n * @public\n */\nexport function findParentNodeOfType(\n  /**\n   * The type of the node to find.\n   */\n  type: NodeType | string,\n  /**\n   * The position to start searching from.\n   */\n  $pos: ResolvedPos,\n): FindParentNodeResult | undefined {\n  const nodeType = getNodeType($pos.doc.type.schema, type)\n  return findParentNode((node) => node.type === nodeType, $pos)\n}\n","import type { NodeType } from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport type { CommandCreator } from '../types/extension-command'\nimport { findParentNodeOfType } from '../utils/find-parent-node-of-type'\n\n/**\n * @public\n */\nexport interface RemoveNodeOptions {\n  /**\n   * The type of the node to remove.\n   */\n  type: string | NodeType\n\n  /**\n   * The document position to start searching node. By default it will be the\n   * anchor position of current selection.\n   */\n  pos?: number\n}\n\n/**\n * Returns a command to remove the nearest ancestor node of a specific type from the current position.\n *\n * @public\n */\nexport function removeNode(options: RemoveNodeOptions): Command {\n  return (state, dispatch) => {\n    const $pos = typeof options.pos === 'number'\n      ? state.doc.resolve(options.pos)\n      : state.selection.$anchor\n\n    const found = findParentNodeOfType(options.type, $pos)\n    if (!found) return false\n\n    const { pos, node } = found\n    dispatch?.(state.tr.delete(pos, pos + node.nodeSize))\n    return true\n  }\n}\n\nremoveNode satisfies CommandCreator\n","import {\n  TextSelection,\n  type EditorState,\n  type Selection,\n} from '@prosekit/pm/state'\n\nexport function getCustomSelection(\n  state: EditorState,\n  from?: number | null,\n  to?: number | null,\n): Selection {\n  const pos = from ?? to\n  if (pos != null) {\n    const $from = state.doc.resolve(from ?? pos)\n    const $to = state.doc.resolve(to ?? pos)\n    return TextSelection.between($from, $to)\n  }\n  return state.selection\n}\n","import type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport { getCustomSelection } from '../utils/get-custom-selection'\nimport { getNodeType } from '../utils/get-node-type'\n\n/**\n * @public\n */\nexport interface SetBlockTypeOptions {\n  type: NodeType | string\n  attrs?: Attrs | null\n  from?: number\n  to?: number\n}\n\n/**\n * Returns a command that tries to set the selected textblocks to the given node\n * type with the given attributes.\n *\n * @public\n */\nexport function setBlockType(options: SetBlockTypeOptions): Command {\n  return (state, dispatch) => {\n    const nodeType = getNodeType(state.schema, options.type)\n    const selection = getCustomSelection(state, options.from, options.to)\n    const attrs = options.attrs\n\n    let applicable = false\n    for (let i = 0; i < selection.ranges.length && !applicable; i++) {\n      const {\n        $from: { pos: from },\n        $to: { pos: to },\n      } = selection.ranges[i]\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (applicable) return false\n        if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n        if (node.type == nodeType) {\n          applicable = true\n        } else {\n          const $pos = state.doc.resolve(pos),\n            index = $pos.index()\n          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n        }\n      })\n    }\n    if (!applicable) return false\n    if (dispatch) {\n      const tr = state.tr\n      for (const range of selection.ranges) {\n        const {\n          $from: { pos: from },\n          $to: { pos: to },\n        } = range\n        tr.setBlockType(from, to, nodeType, attrs)\n      }\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n}\n","import type {\n  NodeType,\n  Schema,\n} from '@prosekit/pm/model'\n\nimport { getNodeType } from './get-node-type'\n\n/**\n * @internal\n */\nexport function getNodeTypes(\n  schema: Schema,\n  types: string | NodeType | string[] | NodeType[],\n): NodeType[] {\n  if (Array.isArray(types)) {\n    return types.map((type) => getNodeType(schema, type))\n  }\n  return [getNodeType(schema, types)]\n}\n","import type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport { getNodeTypes } from '../utils/get-node-types'\n\n/**\n * @public\n */\nexport interface SetNodeAttrsOptions {\n  /**\n   * The type of node to set the attributes of.\n   *\n   * If current node is not of this type, the command will do nothing.\n   */\n  type: string | NodeType | string[] | NodeType[]\n\n  /**\n   * The attributes to set.\n   */\n  attrs: Attrs\n\n  /**\n   * The position of the node. Defaults to the position of the wrapping node\n   * containing the current selection.\n   */\n  pos?: number\n}\n\n/**\n * Returns a command that set the attributes of the current node.\n *\n * @public\n */\nexport function setNodeAttrs(options: SetNodeAttrsOptions): Command {\n  return (state, dispatch) => {\n    const nodeTypes = getNodeTypes(state.schema, options.type)\n    const from = options.pos ?? state.selection.from\n    const to = options.pos ?? state.selection.to\n    const positions: number[] = []\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (nodeTypes.includes(node.type)) {\n        positions.push(pos)\n      }\n      if (!dispatch && positions.length > 0) {\n        return false\n      }\n    })\n\n    if (positions.length === 0) {\n      return false\n    }\n\n    if (dispatch) {\n      const { tr } = state\n      for (const pos of positions) {\n        for (const [key, value] of Object.entries(options.attrs)) {\n          tr.setNodeAttribute(pos, key, value)\n        }\n      }\n      dispatch(tr)\n    }\n    return true\n  }\n}\n","import { toggleMark as baseToggleMark } from '@prosekit/pm/commands'\nimport type {\n  Attrs,\n  MarkType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport type { CommandCreator } from '../types/extension-command'\nimport { getMarkType } from '../utils/get-mark-type'\n\n/**\n * @public\n */\nexport interface ToggleMarkOptions {\n  /**\n   * The mark type to toggle.\n   */\n  type: string | MarkType\n\n  /**\n   * The optional attributes to set on the mark.\n   */\n  attrs?: Attrs | null\n\n  /**\n   * Controls whether, when part of the selected range has the mark\n   * already and part doesn't, the mark is removed (`true`) or added\n   * (`false`).\n   *\n   * @default false\n   */\n  removeWhenPresent?: boolean\n\n  /**\n   * Whether the command should act on the content of inline nodes marked as\n   * [atoms](https://prosemirror.net/docs/ref/#model.NodeSpec.atom) that are\n   * completely covered by a selection range.\n   *\n   * @default true\n   */\n  enterInlineAtoms?: boolean\n}\n\n/**\n * Returns a command that toggles the given mark with the given attributes.\n *\n * @param options\n *\n * @public\n */\nexport function toggleMark({\n  type,\n  attrs,\n  removeWhenPresent = false,\n  enterInlineAtoms = true,\n}: ToggleMarkOptions): Command {\n  return (state, dispatch, view) => {\n    return baseToggleMark(getMarkType(state.schema, type), attrs, {\n      removeWhenPresent,\n      enterInlineAtoms,\n    })(state, dispatch, view)\n  }\n}\n\ntoggleMark satisfies CommandCreator\n","import { setBlockType } from '@prosekit/pm/commands'\nimport type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport { getNodeType } from '../utils/get-node-type'\nimport { isNodeActive } from '../utils/is-node-active'\n\n/**\n * @public\n */\nexport interface ToggleNodeOptions {\n  /**\n   * The type of the node to toggle.\n   */\n  type: string | NodeType\n\n  /**\n   * The attributes of the node to toggle.\n   */\n  attrs?: Attrs | null\n}\n\n/**\n * Returns a command that set the selected textblocks to the given node type\n * with the given attributes.\n *\n * @param options\n *\n * @public\n */\nexport function toggleNode({ type, attrs }: ToggleNodeOptions): Command {\n  return (state, dispatch, view) => {\n    if (isNodeActive(state, type, attrs)) {\n      const defaultType = state.schema.topNodeType.contentMatch.defaultType\n      if (!defaultType) {\n        return false\n      }\n      return setBlockType(defaultType)(state, dispatch, view)\n    } else {\n      const nodeType = getNodeType(state.schema, type)\n      return setBlockType(nodeType, attrs)(state, dispatch, view)\n    }\n  }\n}\n","import type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\nimport { findWrapping } from '@prosekit/pm/transform'\n\nimport { getNodeType } from '../utils/get-node-type'\n\n/**\n * @public\n */\nexport interface WrapOptions {\n  /**\n   * The node type to wrap the selected textblock with.\n   */\n  type: NodeType | string\n\n  /**\n   * @deprecated Use `nodeSpec` instead.\n   */\n  nodeType?: NodeType\n\n  /**\n   * Optional attributes to apply to the node.\n   */\n  attrs?: Attrs | null\n}\n\n/**\n * Returns a command that wraps the selected textblock with the given node type.\n *\n * @param options\n *\n * @public\n */\nexport function wrap(options: WrapOptions): Command {\n  return (state, dispatch) => {\n    const { $from, $to } = state.selection\n    const range = $from.blockRange($to)\n    if (!range) return false\n\n    const nodeType = getNodeType(state.schema, options.nodeType || options.type)\n    const wrapping = findWrapping(range, nodeType, options.attrs)\n    if (!wrapping) return false\n\n    dispatch?.(state.tr.wrap(range, wrapping))\n    return true\n  }\n}\n","import { lift } from '@prosekit/pm/commands'\nimport type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport type { Command } from '@prosekit/pm/state'\n\nimport { isNodeActive } from '../utils/is-node-active'\n\nimport { wrap } from './wrap'\n\nexport interface ToggleWrapOptions {\n  /**\n   * The type of the node to toggle.\n   */\n  type: string | NodeType\n\n  /**\n   * The attributes of the node to toggle.\n   */\n  attrs?: Attrs | null\n}\n\n/**\n * Toggle between wrapping an inactive node with the provided node type, and\n * lifting it up into its parent.\n *\n * @param options\n *\n * @public\n */\nexport function toggleWrap(options: ToggleWrapOptions): Command {\n  const { type, attrs } = options\n\n  return (state, dispatch) => {\n    if (isNodeActive(state, type, attrs)) {\n      return lift(state, dispatch)\n    }\n\n    return wrap({ type, attrs })(state, dispatch)\n  }\n}\n","import {\n  Fragment,\n  Slice,\n} from '@prosekit/pm/model'\nimport type {\n  Command,\n  Transaction,\n} from '@prosekit/pm/state'\nimport { ReplaceAroundStep } from '@prosekit/pm/transform'\n\nimport type { CommandCreator } from '../types/extension-command'\n\n/**\n * @public\n */\nexport interface UnsetBlockTypeOptions {\n  /**\n   * The start position of the document. By default it will be the start position of current selection.\n   */\n  from?: number\n\n  /**\n   * The end position of the document. By default it will be the end position of current selection.\n   */\n  to?: number\n}\n\n/**\n * Returns a command that set the type of all textblocks between the given range\n * to the default type (usually `paragraph`).\n *\n * @public\n */\nexport function unsetBlockType(options?: UnsetBlockTypeOptions): Command {\n  return (state, dispatch) => {\n    const from = options?.from ?? state.selection.from\n    const to = options?.to ?? state.selection.to\n    if (from > to) return false\n\n    const tr = state.tr\n    if (unsetTextBlockType(tr, from, to)) {\n      dispatch?.(tr)\n      return true\n    }\n    return false\n  }\n}\n\nfunction unsetTextBlockType(\n  tr: Transaction,\n  from: number,\n  to: number,\n): boolean {\n  const mapFrom = tr.steps.length\n  tr.doc.nodesBetween(from, to, (node, pos, parent, index): boolean => {\n    if (!parent || !node.isTextblock) return true\n\n    const defaultType = parent.contentMatchAt(index).defaultType\n    if (\n      defaultType\n      && defaultType.isTextblock\n      && node.type !== defaultType\n      && defaultType.validContent(node.content)\n    ) {\n      const mapping = tr.mapping.slice(mapFrom)\n      const start = mapping.map(pos, 1)\n      const end = mapping.map(pos + node.nodeSize, 1)\n      const step = new ReplaceAroundStep(\n        start,\n        end,\n        start + 1,\n        end - 1,\n        new Slice(Fragment.from(defaultType.create()), 0, 0),\n        1,\n        true,\n      )\n      tr.step(step)\n    }\n    return false\n  })\n  return tr.steps.length > mapFrom\n}\n\nunsetBlockType satisfies CommandCreator\n","import type { Command } from '@prosekit/pm/state'\n\nimport type { CommandCreator } from '../types/extension-command'\n\n/**\n * @public\n *\n * Options for {@link unsetMark}.\n */\nexport interface UnsetMarkOptions {\n  /**\n   * The start position of the document. By default it will be the start position of current selection.\n   */\n  from?: number\n\n  /**\n   * The end position of the document. By default it will be the end position of current selection.\n   */\n  to?: number\n}\n\n/**\n * Returns a command that removes all marks.\n *\n * @public\n */\nexport function unsetMark(options?: UnsetMarkOptions): Command {\n  return (state, dispatch) => {\n    const from = options?.from ?? state.selection.from\n    const to = options?.to ?? state.selection.to\n    if (from > to) return false\n\n    dispatch?.(state.tr.removeMark(from, to))\n    return true\n  }\n}\n\nunsetMark satisfies CommandCreator\n","import type { Extension } from '../types/extension'\nimport type { Priority } from '../types/priority'\n\nimport { union } from './union'\n\n/**\n * Return an new extension with the given priority.\n *\n * @example\n * ```ts\n * import { Priority, withPriority } from 'prosekit/core'\n *\n * const extension = withPriority(defineMyExtension(), Priority.high)\n * ```\n *\n * @public\n */\nexport function withPriority<T extends Extension>(\n  extension: T,\n  priority: Priority,\n): T {\n  const result = union(extension)\n  result.priority = priority\n  return result as T\n}\n","import type { Schema } from '@prosekit/pm/model'\nimport {\n  Plugin,\n  type ProseMirrorPlugin,\n} from '@prosekit/pm/state'\n\nimport { ProseKitError } from '../error'\nimport {\n  defineFacet,\n  type Facet,\n} from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport {\n  stateFacet,\n  type StatePayload,\n} from '../facets/state'\nimport type { PlainExtension } from '../types/extension'\n\n/**\n * Adds a ProseMirror plugin to the editor.\n *\n * @param plugin - The ProseMirror plugin to add, or an array of plugins, or a\n * function that returns one or multiple plugins.\n *\n * @public\n */\nexport function definePlugin(\n  plugin:\n    | Plugin\n    | Plugin[]\n    | ((context: { schema: Schema }) => Plugin | Plugin[]),\n): PlainExtension {\n  if (\n    plugin instanceof Plugin\n    || (Array.isArray(plugin) && plugin.every((p) => p instanceof Plugin))\n  ) {\n    return definePluginPayload(() => plugin)\n  }\n\n  if (typeof plugin === 'function') {\n    return definePluginPayload(plugin)\n  }\n\n  throw new TypeError('Invalid plugin')\n}\n\nfunction definePluginPayload(payload: PluginPayload): PlainExtension {\n  return defineFacetPayload(pluginFacet, [payload]) as PlainExtension\n}\n\n/**\n * @internal\n */\nexport type PluginPayload =\n  | Plugin\n  | Plugin[]\n  | ((context: { schema: Schema }) => Plugin | Plugin[])\n\n/**\n * @internal\n */\nexport const pluginFacet: Facet<PluginPayload, StatePayload> = defineFacet({\n  reducer: (payloads): StatePayload => {\n    return ({ schema }) => {\n      const plugins: ProseMirrorPlugin[] = []\n\n      for (const payload of payloads) {\n        if (payload instanceof Plugin) {\n          plugins.push(payload)\n        } else if (\n          Array.isArray(payload)\n          && payload.every((p) => p instanceof Plugin)\n        ) {\n          plugins.push(...payload)\n        } else if (typeof payload === 'function') {\n          plugins.push(...[payload({ schema })].flat())\n        } else {\n          throw new ProseKitError('Invalid plugin')\n        }\n      }\n\n      // In ProseMirror, the plugins at the beginning have a higher priority.\n      // However, in ProseKit, the extensions at the end have a higher priority\n      // because we want to easily override the default behaviors by appending\n      // new extensions. Therefore, we need to reverse plugins here.\n      plugins.reverse()\n      return { plugins }\n    }\n  },\n  parent: stateFacet,\n})\n","import {\n  DOMSerializer,\n  type DOMOutputSpec,\n  type Mark,\n  type ProseMirrorNode,\n  type Schema,\n} from '@prosekit/pm/model'\nimport {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { AnyFunction } from '../types/any-function'\nimport type { PlainExtension } from '../types/extension'\nimport { isNotNullish } from '../utils/type-assertion'\n\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from './plugin'\n\ntype SerializeFragmentFunction = typeof DOMSerializer.prototype.serializeFragment\ntype SerializeNodeFunction = typeof DOMSerializer.prototype.serializeNode\ntype NodesFromSchemaFunction = typeof DOMSerializer.nodesFromSchema\ntype MarksFromSchemaFunction = typeof DOMSerializer.marksFromSchema\n\ntype FunctionWrapper<T extends AnyFunction> = (fn: T) => T\n\n/**\n * @internal\n */\nexport interface ClipboardSerializerOptions {\n  serializeFragmentWrapper?: FunctionWrapper<SerializeFragmentFunction>\n  serializeNodeWrapper?: FunctionWrapper<SerializeNodeFunction>\n  nodesFromSchemaWrapper?: FunctionWrapper<NodesFromSchemaFunction>\n  marksFromSchemaWrapper?: FunctionWrapper<MarksFromSchemaFunction>\n}\n\nfunction mergeWrappers<T extends AnyFunction>(wrappers: Array<FunctionWrapper<T> | undefined | null>): FunctionWrapper<T> {\n  return (fn: T) => wrappers.filter(isNotNullish).reduce((fn, wrapper) => wrapper(fn), fn)\n}\n\nfunction wrapFunction<T extends AnyFunction>(fn: T, wrapper?: FunctionWrapper<T>): T {\n  return wrapper ? wrapper(fn) : fn\n}\n\nclass CustomDOMSerializer extends DOMSerializer {\n  constructor(\n    nodes: Record<string, (node: ProseMirrorNode) => DOMOutputSpec>,\n    marks: Record<string, (mark: Mark, inline: boolean) => DOMOutputSpec>,\n    private serializeFragmentWrapper?: FunctionWrapper<SerializeFragmentFunction>,\n    private serializeNodeWrapper?: FunctionWrapper<SerializeNodeFunction>,\n  ) {\n    super(nodes, marks)\n  }\n\n  override serializeFragment(...args: Parameters<SerializeFragmentFunction>): ReturnType<SerializeFragmentFunction> {\n    const fn: SerializeFragmentFunction = (...args) => super.serializeFragment(...args)\n    return wrapFunction(fn, this.serializeFragmentWrapper)(...args)\n  }\n\n  override serializeNode(...args: Parameters<SerializeNodeFunction>): ReturnType<SerializeNodeFunction> {\n    const fn: SerializeNodeFunction = (...args) => super.serializeNode(...args)\n    return wrapFunction(fn, this.serializeNodeWrapper)(...args)\n  }\n}\n\nfunction createCustomDOMSerializer(schema: Schema, options: ClipboardSerializerOptions) {\n  const nodesFromSchema: NodesFromSchemaFunction = (...args) => DOMSerializer.nodesFromSchema(...args)\n  const marksFromSchema: MarksFromSchemaFunction = (...args) => DOMSerializer.marksFromSchema(...args)\n  const nodes = wrapFunction(nodesFromSchema, options.nodesFromSchemaWrapper)(schema)\n  const marks = wrapFunction(marksFromSchema, options.marksFromSchemaWrapper)(schema)\n  return new CustomDOMSerializer(nodes, marks, options.serializeFragmentWrapper, options.serializeNodeWrapper)\n}\n\nconst clipboardSerializerFacet = defineFacet<ClipboardSerializerOptions, PluginPayload>({\n  reducer: (inputs: ClipboardSerializerOptions[]): PluginPayload => {\n    const options: ClipboardSerializerOptions = {\n      serializeFragmentWrapper: mergeWrappers(inputs.map((input) => input.serializeFragmentWrapper)),\n      serializeNodeWrapper: mergeWrappers(inputs.map((input) => input.serializeNodeWrapper)),\n      nodesFromSchemaWrapper: mergeWrappers(inputs.map((input) => input.nodesFromSchemaWrapper)),\n      marksFromSchemaWrapper: mergeWrappers(inputs.map((input) => input.marksFromSchemaWrapper)),\n    }\n\n    return ({ schema }) => {\n      const clipboardSerializer = createCustomDOMSerializer(schema, options)\n\n      return [\n        new ProseMirrorPlugin({\n          key: new PluginKey('prosekit-clipboard-serializer'),\n          props: { clipboardSerializer },\n        }),\n      ]\n    }\n  },\n  singleton: true,\n  parent: pluginFacet,\n})\n\n/**\n * @internal\n */\nexport function defineClipboardSerializer(options: ClipboardSerializerOptions): PlainExtension {\n  return defineFacetPayload(clipboardSerializerFacet, [options]) as PlainExtension\n}\n","import type { Command } from '@prosekit/pm/state'\n\n/**\n * @public\n */\nexport type InsertTextOptions = {\n  text: string\n  from?: number\n  to?: number\n}\n\n/**\n * Returns a command that inserts the given text.\n *\n * @public\n */\nexport function insertText({ text, from, to }: InsertTextOptions): Command {\n  return (state, dispatch) => {\n    if (text) {\n      dispatch?.(state.tr.insertText(text, from, to))\n    }\n    return true\n  }\n}\n","import {\n  AllSelection,\n  type Command,\n} from '@prosekit/pm/state'\n\n/**\n * Returns a command that selects the whole document.\n *\n * @public\n */\nexport function selectAll(): Command {\n  return (state, dispatch) => {\n    dispatch?.(state.tr.setSelection(new AllSelection(state.doc)))\n    return true\n  }\n}\n","import type { CommandCreators } from '../types/extension-command'\n\nimport {\n  defineFacet,\n  type Facet,\n} from './facet'\nimport {\n  rootFacet,\n  type RootPayload,\n} from './root'\n\ntype CommandPayload = CommandCreators\n\nexport const commandFacet: Facet<CommandPayload, RootPayload> = defineFacet({\n  reducer: (inputs) => {\n    const commands = Object.assign({}, ...inputs) as CommandPayload\n    return { commands }\n  },\n  parent: rootFacet,\n  singleton: true,\n})\n","import {\n  addMark,\n  type AddMarkOptions,\n} from '../commands/add-mark'\nimport {\n  insertDefaultBlock,\n  type InsertDefaultBlockOptions,\n} from '../commands/insert-default-block'\nimport {\n  insertNode,\n  type InsertNodeOptions,\n} from '../commands/insert-node'\nimport {\n  insertText,\n  type InsertTextOptions,\n} from '../commands/insert-text'\nimport {\n  removeMark,\n  type RemoveMarkOptions,\n} from '../commands/remove-mark'\nimport {\n  removeNode,\n  type RemoveNodeOptions,\n} from '../commands/remove-node'\nimport { selectAll } from '../commands/select-all'\nimport {\n  setBlockType,\n  type SetBlockTypeOptions,\n} from '../commands/set-block-type'\nimport {\n  setNodeAttrs,\n  type SetNodeAttrsOptions,\n} from '../commands/set-node-attrs'\nimport {\n  toggleWrap,\n  type ToggleWrapOptions,\n} from '../commands/toggle-wrap'\nimport {\n  unsetBlockType,\n  type UnsetBlockTypeOptions,\n} from '../commands/unset-block-type'\nimport {\n  unsetMark,\n  type UnsetMarkOptions,\n} from '../commands/unset-mark'\nimport {\n  wrap,\n  type WrapOptions,\n} from '../commands/wrap'\nimport { commandFacet } from '../facets/command'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { Extension } from '../types/extension'\nimport type { CommandCreator } from '../types/extension-command'\n\nexport function defineCommands<\n  T extends Record<string, CommandCreator> = Record<string, CommandCreator>,\n>(\n  commands: T,\n): Extension<{\n  Commands: { [K in keyof T]: Parameters<T[K]> }\n}> {\n  return defineFacetPayload(commandFacet, [commands]) as Extension<{\n    Commands: { [K in keyof T]: Parameters<T[K]> }\n  }>\n}\n\n/**\n * @internal\n */\nexport type BaseCommandsExtension = Extension<{\n  Commands: {\n    insertText: [options: InsertTextOptions]\n    insertNode: [options: InsertNodeOptions]\n    removeNode: [options: RemoveNodeOptions]\n    wrap: [options: WrapOptions]\n    toggleWrap: [options: ToggleWrapOptions]\n    setBlockType: [options: SetBlockTypeOptions]\n    setNodeAttrs: [options: SetNodeAttrsOptions]\n    insertDefaultBlock: [options?: InsertDefaultBlockOptions]\n    selectAll: []\n    addMark: [options: AddMarkOptions]\n    removeMark: [options: RemoveMarkOptions]\n    unsetBlockType: [options?: UnsetBlockTypeOptions]\n    unsetMark: [options?: UnsetMarkOptions]\n  }\n}>\n\n/**\n * Add some base commands\n *\n * @public\n */\nexport function defineBaseCommands(): BaseCommandsExtension {\n  return defineCommands({\n    insertText,\n\n    insertNode,\n\n    removeNode,\n\n    wrap,\n\n    toggleWrap,\n\n    setBlockType,\n\n    setNodeAttrs,\n\n    insertDefaultBlock,\n\n    selectAll,\n\n    addMark,\n\n    removeMark,\n\n    unsetBlockType,\n\n    unsetMark,\n  })\n}\n","import type {\n  MarkSpec,\n  NodeSpec,\n  SchemaSpec,\n} from '@prosekit/pm/model'\nimport OrderedMap from 'orderedmap'\n\nimport {\n  defineFacet,\n  type Facet,\n} from './facet'\nimport { schemaFacet } from './schema'\n\nexport const schemaSpecFacet: Facet<SchemaSpec, SchemaSpec> = defineFacet({\n  reducer: (specs): SchemaSpec => {\n    let nodes = OrderedMap.from<NodeSpec>({})\n    let marks = OrderedMap.from<MarkSpec>({})\n    let topNode: string | undefined = undefined\n\n    for (const spec of specs) {\n      nodes = nodes.append(spec.nodes)\n      marks = marks.append(spec.marks ?? {})\n      topNode = topNode ?? spec.topNode\n    }\n\n    return { nodes, marks, topNode }\n  },\n  parent: schemaFacet,\n  singleton: true,\n})\n","import type { ObjectEntries } from '../types/object-entries'\n\nexport function groupBy<K extends PropertyKey, T>(\n  items: Iterable<T>,\n  keySelector: (item: T) => K,\n): Partial<Record<K, T[]>> {\n  const result: Partial<Record<K, T[]>> = {}\n  for (const item of items) {\n    const key = keySelector(item)\n    const values = (result[key] ||= [])\n    values.push(item)\n  }\n  return result\n}\n\nexport function groupEntries<T extends Record<string, any>>(\n  entries: ObjectEntries<T>[],\n): { [K in keyof T]?: T[K][] } {\n  const result: { [K in keyof T]?: T[K][] } = {}\n  for (const [key, value] of entries) {\n    const values = (result[key] ||= [])\n    values.push(value)\n  }\n  return result\n}\n","export function removeUndefinedValues<T extends object>(obj: T): T {\n  const result = {} as Record<string, unknown>\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== undefined) {\n      result[key] = value\n    }\n  }\n  return result as T\n}\n","import { removeUndefinedValues } from './remove-undefined-values'\nimport { isNotNullish } from './type-assertion'\n\nexport function mergeObjects<T extends object>(\n  ...objects: Array<Partial<T> | null | undefined>\n): Partial<T> {\n  const filteredObjects = objects\n    .filter(isNotNullish)\n    .map(removeUndefinedValues)\n  return Object.assign({}, ...filteredObjects) as Partial<T>\n}\n","import type {\n  MarkSpec,\n  NodeSpec,\n} from '@prosekit/pm/model'\n\nimport { mergeObjects } from './merge-objects'\n\nfunction mergeSpecs(a: NodeSpec, b: NodeSpec): NodeSpec\nfunction mergeSpecs(a: MarkSpec, b: MarkSpec): MarkSpec\nfunction mergeSpecs(\n  a: NodeSpec | MarkSpec,\n  b: NodeSpec | MarkSpec,\n): NodeSpec | MarkSpec {\n  type T = typeof a\n\n  const attrs: T['attrs'] = {}\n  const attrNames = new Set([\n    ...Object.keys(a.attrs ?? {}),\n    ...Object.keys(b.attrs ?? {}),\n  ])\n  for (const name of attrNames) {\n    const attrSpecA = a.attrs?.[name]\n    const attrSpecB = b.attrs?.[name]\n    const attrSpecMerged = mergeObjects(attrSpecA, attrSpecB)\n    if (attrSpecMerged) {\n      attrs[name] = attrSpecMerged\n    }\n  }\n\n  const parseDOM: T['parseDOM'] = [...(a.parseDOM ?? []), ...(b.parseDOM ?? [])]\n\n  return mergeObjects<T>(a, b, { attrs, parseDOM })\n}\n\nexport { mergeSpecs }\n","import { isElementLike } from '@ocavue/utils'\nimport type {\n  DOMOutputSpec,\n  Mark,\n  ProseMirrorNode,\n  TagParseRule,\n} from '@prosekit/pm/model'\n\nimport { isNotNullish } from './type-assertion'\n\ninterface AttrOptions {\n  attr: string\n  toDOM?: (value: unknown) => [key: string, value: string] | null | undefined\n  parseDOM?: (node: HTMLElement) => unknown\n}\n\nexport function wrapOutputSpecAttrs<\n  T extends ProseMirrorNode | Mark,\n  Args extends readonly unknown[],\n>(\n  toDOM: (node: T, ...args: Args) => DOMOutputSpec,\n  options: AttrOptions[],\n): (node: T, ...args: Args) => DOMOutputSpec {\n  return (node, ...args) => {\n    const dom = toDOM(node, ...args)\n    const pairs = options\n      .map((option) => option.toDOM?.(node.attrs[option.attr]))\n      .filter(isNotNullish)\n    return insertOutputSpecAttrs(dom, pairs)\n  }\n}\n\nexport function wrapTagParseRuleAttrs(\n  rule: TagParseRule,\n  options: AttrOptions[],\n): TagParseRule {\n  const existingGetAttrs = rule.getAttrs\n  const existingAttrs = rule.attrs\n\n  return {\n    ...rule,\n    getAttrs: (dom) => {\n      const baseAttrs = existingGetAttrs?.(dom) ?? existingAttrs ?? {}\n\n      if (baseAttrs === false || !dom || !isElementLike(dom)) {\n        return baseAttrs ?? null\n      }\n\n      const insertedAttrs: Record<string, unknown> = {}\n\n      for (const option of options) {\n        if (option.parseDOM) {\n          insertedAttrs[option.attr] = option.parseDOM(dom)\n        }\n      }\n\n      return { ...baseAttrs, ...insertedAttrs }\n    },\n  }\n}\n\nexport function insertOutputSpecAttrs(\n  dom: DOMOutputSpec,\n  attrs: Array<[key: string, value: string]>,\n): DOMOutputSpec {\n  if (!dom) {\n    return dom\n  }\n\n  if (Array.isArray(dom)) {\n    const rest = dom.slice(1) as Array<unknown>\n    let oldAttrs: Record<string, unknown>\n\n    if (rest.length > 0 && (rest[0] == null || typeof rest[0] === 'object')) {\n      oldAttrs = rest.shift() as Record<string, unknown>\n    } else {\n      oldAttrs = {}\n    }\n\n    const newAttrs = setObjectAttributes(oldAttrs, attrs)\n    return [dom[0], newAttrs, ...rest]\n  }\n\n  if (isElementLike(dom)) {\n    return setElementAttributes(dom, attrs)\n  }\n\n  if (typeof dom === 'object' && 'dom' in dom && isElementLike(dom.dom)) {\n    return { ...dom, dom: setElementAttributes(dom.dom, attrs) }\n  }\n\n  return dom\n}\n\nfunction setObjectAttributes(\n  obj: Record<string, unknown>,\n  attrs: Array<[key: string, value: string]>,\n): Record<string, unknown> {\n  obj = { ...obj }\n  for (const [key, value] of attrs) {\n    const oldValue = obj[key]\n    const newValue = key === 'style'\n      ? joinStyles(value, typeof oldValue === 'string' ? oldValue : '')\n      : value\n    obj[key] = newValue\n  }\n  return obj\n}\n\nfunction setElementAttributes(\n  element: Element,\n  attrs: Array<[key: string, value: string]>,\n): Element {\n  element = element.cloneNode(true) as Element\n  for (const [key, value] of attrs) {\n    const oldValue = element.getAttribute(key)\n    const newValue = key === 'style'\n      ? joinStyles(value, typeof oldValue === 'string' ? oldValue : '')\n      : value\n    element.setAttribute(key, newValue)\n  }\n  return element\n}\n\nfunction joinStyles(...styles: string[]) {\n  return styles\n    .map((style) => style.trim().replace(/;$/, ''))\n    .filter(Boolean)\n    .join('; ')\n}\n","import type {\n  AttributeSpec,\n  NodeSpec,\n  SchemaSpec,\n} from '@prosekit/pm/model'\nimport clone from 'just-clone'\nimport OrderedMap from 'orderedmap'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport { schemaSpecFacet } from '../facets/schema-spec'\nimport type {\n  AnyAttrs,\n  AttrSpec,\n} from '../types/attrs'\nimport type { Extension } from '../types/extension'\nimport { groupBy } from '../utils/array-grouping'\nimport { assert } from '../utils/assert'\nimport { mergeSpecs } from '../utils/merge-specs'\nimport {\n  wrapOutputSpecAttrs,\n  wrapTagParseRuleAttrs,\n} from '../utils/output-spec'\nimport { isNotNullish } from '../utils/type-assertion'\n\n/**\n * @public\n */\nexport interface NodeSpecOptions<\n  NodeName extends string = string,\n  Attrs extends AnyAttrs = AnyAttrs,\n> extends NodeSpec {\n  /**\n   * The name of the node type.\n   */\n  name: NodeName\n\n  /**\n   * Whether this is the top-level node type. Only one node type can be the\n   * top-level node type in a schema.\n   */\n  topNode?: boolean\n\n  /**\n   * The attributes that nodes of this type get.\n   */\n  attrs?: {\n    [key in keyof Attrs]: AttrSpec<Attrs[key]>\n  }\n}\n\n/**\n * @public\n */\nexport interface NodeAttrOptions<\n  NodeName extends string = string,\n  AttrName extends string = string,\n  AttrType = any,\n> extends AttrSpec<AttrType> {\n  /**\n   * The name of the node type.\n   */\n  type: NodeName\n\n  /**\n   * The name of the attribute.\n   */\n  attr: AttrName\n\n  /**\n   * Whether the attribute should be kept when the node is split. Set it to\n   * `true` if you want to inherit the attribute from the previous node when\n   * splitting the node by pressing `Enter`.\n   *\n   * @default undefined\n   */\n  splittable?: boolean\n\n  /**\n   * Returns the attribute key and value to be set on the HTML element.\n   *\n   * If the returned `key` is `\"style\"`, the value is a string of CSS properties and will\n   * be prepended to the existing `style` attribute on the DOM node.\n   *\n   * @param value - The value of the attribute of current ProseMirror node.\n   */\n  toDOM?: (value: AttrType) => [key: string, value: string] | null | undefined\n\n  /**\n   * Parses the attribute value from the DOM.\n   */\n  parseDOM?: (node: HTMLElement) => AttrType\n}\n\n/**\n * Defines a node type.\n *\n * @public\n */\nexport function defineNodeSpec<\n  Node extends string,\n  Attrs extends AnyAttrs = AnyAttrs,\n>(\n  options: NodeSpecOptions<Node, Attrs>,\n): Extension<{\n  Nodes: { [K in Node]: Attrs }\n}> {\n  const payload: NodeSpecPayload = [options, undefined]\n  return defineFacetPayload(nodeSpecFacet, [payload]) as Extension<{\n    Nodes: any\n  }>\n}\n\n/**\n * Defines an attribute for a node type.\n *\n * @public\n */\nexport function defineNodeAttr<\n  NodeType extends string = string,\n  AttrName extends string = string,\n  AttrType = any,\n>(\n  options: NodeAttrOptions<NodeType, AttrName, AttrType>,\n): Extension<{\n  Nodes: { [K in NodeType]: { [K in AttrName]: AttrType } }\n}> {\n  const payload: NodeSpecPayload = [undefined, options]\n  return defineFacetPayload(nodeSpecFacet, [payload]) as Extension<{\n    Nodes: any\n  }>\n}\n\ntype NodeSpecPayload = [\n  NodeSpecOptions | undefined,\n  NodeAttrOptions | undefined,\n]\n\nconst nodeSpecFacet = defineFacet<NodeSpecPayload, SchemaSpec>({\n  reducer: (payloads: NodeSpecPayload[]): SchemaSpec => {\n    let specs = OrderedMap.from<NodeSpec>({})\n    let topNodeName: string | undefined = undefined\n\n    const specPayloads = payloads.map((input) => input[0]).filter(isNotNullish)\n    const attrPayloads = payloads.map((input) => input[1]).filter(isNotNullish)\n\n    for (const { name, topNode, ...spec } of specPayloads) {\n      if (topNode) {\n        topNodeName = name\n      }\n\n      const prevSpec = specs.get(name)\n      if (prevSpec) {\n        specs = specs.update(name, mergeSpecs(prevSpec, spec))\n      } else {\n        // The latest spec has the highest priority, so we put it at the start\n        // of the map.\n        specs = specs.addToStart(name, spec)\n      }\n    }\n\n    const groupedAttrs = groupBy(attrPayloads, (payload) => payload.type)\n\n    for (const [type, attrs] of Object.entries(groupedAttrs)) {\n      if (!attrs) continue\n\n      const maybeSpec = specs.get(type)\n      assert(maybeSpec, `Node type ${type} must be defined`)\n\n      const spec = clone(maybeSpec)\n\n      if (!spec.attrs) {\n        spec.attrs = {}\n      }\n\n      for (const attr of attrs) {\n        spec.attrs[attr.attr] = {\n          default: attr.default as unknown,\n          validate: attr.validate,\n          splittable: attr.splittable,\n        } as AttributeSpec\n      }\n\n      if (spec.toDOM) {\n        spec.toDOM = wrapOutputSpecAttrs(spec.toDOM, attrs)\n      }\n\n      if (spec.parseDOM) {\n        spec.parseDOM = spec.parseDOM.map((rule) => wrapTagParseRuleAttrs(rule, attrs))\n      }\n\n      specs = specs.update(type, spec)\n    }\n\n    return { nodes: specs, topNode: topNodeName }\n  },\n  parent: schemaSpecFacet,\n  singleton: true,\n})\n","import type { Attrs } from '@prosekit/pm/model'\n\nimport type { Extension } from '../types/extension'\n\nimport { defineNodeSpec } from './node-spec'\n\n/**\n * @internal\n */\nexport type DocExtension = Extension<{ Nodes: { doc: Attrs } }>\n\n/**\n * @public\n *\n * @deprecated Use the following import instead:\n *\n * ```ts\n * import { defineDoc } from 'prosekit/extensions/doc'\n * ```\n */\nexport function defineDoc(): DocExtension {\n  console.warn(\n    '[prosekit] The `defineDoc` function from `prosekit/core` is deprecated. Use the following import instead: `import { defineDoc } from \"prosekit/extensions/doc\"`.',\n  )\n\n  return defineNodeSpec({\n    name: 'doc',\n    content: 'block+',\n    topNode: true,\n  })\n}\n","import {\n  PluginKey,\n  ProseMirrorPlugin,\n  type EditorState,\n} from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\n\nimport { defineFacet } from '../../facets/facet'\nimport { defineFacetPayload } from '../../facets/facet-extension'\nimport type { PlainExtension } from '../../types/extension'\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from '../plugin'\n\n/**\n * A function that is called when the editor view is mounted.\n *\n * @param view - The editor view.\n *\n * @public\n */\nexport type MountHandler = (view: EditorView) => void\n\n/**\n * A function that is called when the editor state is updated.\n *\n * @param view - The editor view.\n * @param prevState - The previous editor state.\n *\n * @public\n */\nexport type UpdateHandler = (view: EditorView, prevState: EditorState) => void\n\n/**\n * A function that is called when the editor view is unmounted.\n *\n * @public\n */\nexport type UnmountHandler = () => void\n\n/**\n * Registers a event handler that is called when the editor view is mounted.\n *\n * @public\n */\nexport function defineMountHandler(handler: MountHandler): PlainExtension {\n  return definePluginViewFacetPayload(['mount', handler])\n}\n\n/**\n * Registers a event handler that is called when the editor state is updated.\n *\n * @public\n */\nexport function defineUpdateHandler(handler: UpdateHandler): PlainExtension {\n  return definePluginViewFacetPayload(['update', handler])\n}\n\n/**\n * Registers a event handler that is called when the editor view is unmounted.\n *\n * @public\n */\nexport function defineUnmountHandler(handler: UnmountHandler): PlainExtension {\n  return definePluginViewFacetPayload(['unmount', handler])\n}\n\nfunction definePluginViewFacetPayload(\n  input: PluginViewHandlerArgs,\n): PlainExtension {\n  return defineFacetPayload(pluginViewFacet, [input]) as PlainExtension\n}\n\ntype PluginViewHandlerArgs =\n  | ['mount', MountHandler]\n  | ['update', UpdateHandler]\n  | ['unmount', UnmountHandler]\n\nconst pluginViewFacet = defineFacet<PluginViewHandlerArgs, PluginPayload>({\n  reduce: () => {\n    let mountHandlers: MountHandler[] = []\n    let updateHandlers: UpdateHandler[] = []\n    let unmountHandlers: UnmountHandler[] = []\n\n    const plugin = new ProseMirrorPlugin({\n      key: pluginKey,\n      view: (view) => {\n        // Run all handlers after the view is mounted\n        mountHandlers.forEach((fn) => fn(view))\n\n        return {\n          update: (view, prevState) => {\n            updateHandlers.forEach((fn) => fn(view, prevState))\n          },\n          destroy: () => {\n            unmountHandlers.forEach((fn) => fn())\n          },\n        }\n      },\n    })\n\n    const register = (input: PluginViewHandlerArgs[]) => {\n      mountHandlers = []\n      updateHandlers = []\n      unmountHandlers = []\n\n      for (const args of input) {\n        switch (args[0]) {\n          case 'mount':\n            mountHandlers.push(args[1])\n            break\n          case 'update':\n            updateHandlers.push(args[1])\n            break\n          case 'unmount':\n            unmountHandlers.push(args[1])\n            break\n        }\n      }\n    }\n\n    return function reducer(input: PluginViewHandlerArgs[]) {\n      register(input)\n      return plugin\n    }\n  },\n  parent: pluginFacet,\n  singleton: true,\n})\n\nconst pluginKey = new PluginKey('prosekit-plugin-view-handler')\n","import type { EditorState } from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\n\nimport type { PlainExtension } from '../../types/extension'\n\nimport { defineUpdateHandler } from './plugin-view'\n\n/**\n * A function that is called when the editor document is changed.\n *\n * @param view - The editor view.\n * @param prevState - The previous editor state.\n *\n * @public\n */\nexport type DocChangeHandler = (\n  view: EditorView,\n  prevState: EditorState,\n) => void\n\n/**\n * Registers a event handler that is called when the editor document is changed.\n *\n * @public\n */\nexport function defineDocChangeHandler(\n  handler: DocChangeHandler,\n): PlainExtension {\n  return defineUpdateHandler((view, prevState) => {\n    if (!view.state.doc.eq(prevState.doc)) {\n      handler(view, prevState)\n    }\n  })\n}\n","import { toReversed } from './array'\n\nexport function combineEventHandlers<\n  Handler extends (...args: any[]) => boolean | void,\n  Args extends Parameters<Handler> = Parameters<Handler>,\n>(): [\n  setHandlers: (eventHandlers: Handler[]) => void,\n  combinedEventHandler: (...args: Args) => boolean,\n] {\n  let handlers: Handler[] = []\n\n  function setHandlers(eventHandlers: Handler[]): void {\n    // The handlers at the end have a higher priority.\n    handlers = toReversed(eventHandlers)\n  }\n\n  function combinedEventHandler(...args: Args): boolean {\n    for (const handler of handlers) {\n      if (handler(...args)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  return [setHandlers, combinedEventHandler] as const\n}\n","import {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type {\n  DOMEventMap,\n  EditorView,\n} from '@prosekit/pm/view'\n\nimport {\n  defineFacet,\n  type Facet,\n} from '../../facets/facet'\nimport { defineFacetPayload } from '../../facets/facet-extension'\nimport type { PlainExtension } from '../../types/extension'\nimport type { Setter } from '../../types/setter'\nimport { groupEntries } from '../../utils/array-grouping'\nimport { combineEventHandlers } from '../../utils/combine-event-handlers'\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from '../plugin'\n\n/**\n * A function to handle the events fired on the editable DOM element. Returns\n * `true` to indicate that it handled the given event. When returning `true`,\n * you are responsible for calling `event.preventDefault()` yourself (or not, if\n * you want to allow the default behavior).\n *\n * @public\n */\nexport type DOMEventHandler<Event extends keyof DOMEventMap = string> = (\n  view: EditorView,\n  event: DOMEventMap[Event],\n) => boolean | void\n\n/**\n * @internal\n */\nexport function defineDomEventFacetPayload(\n  ...payloads: DOMEventPayload[]\n): PlainExtension {\n  return defineFacetPayload<DOMEventPayload>(\n    domEventFacet,\n    payloads,\n  ) as PlainExtension\n}\n\n/**\n * Register a new event handler for the given event type.\n *\n * @public\n */\nexport function defineDOMEventHandler<Event extends keyof DOMEventMap = string>(\n  event: Event,\n  handler: DOMEventHandler<Event>,\n): PlainExtension {\n  return defineDomEventFacetPayload([\n    event as string,\n    handler as DOMEventHandler,\n  ])\n}\n\n/**\n * @internal\n */\ntype DOMEventPayload = [event: string, handler: DOMEventHandler]\n\n/**\n * @internal\n */\nconst domEventFacet: Facet<DOMEventPayload, PluginPayload> = defineFacet(\n  {\n    reduce: () => {\n      const setHandlersMap: Record<string, Setter<DOMEventHandler[]>> = {}\n      const combinedHandlerMap: Record<string, DOMEventHandler> = {}\n\n      let plugin: ProseMirrorPlugin | undefined\n\n      const update = (payloads: DOMEventPayload[]): void => {\n        let hasNewEvent = false\n\n        for (const [event] of payloads) {\n          if (!setHandlersMap[event]) {\n            hasNewEvent = true\n            const [setHandlers, combinedHandler] = combineEventHandlers<DOMEventHandler>()\n            setHandlersMap[event] = setHandlers\n            const e: DOMEventHandler = (view, eventObject) => {\n              return combinedHandler(view, eventObject)\n            }\n            combinedHandlerMap[event] = e\n          }\n        }\n\n        const map: Record<string, DOMEventHandler[] | undefined> = groupEntries<DOMEventMap>(payloads)\n        for (const [event, setHandlers] of Object.entries(setHandlersMap)) {\n          const handlers = map[event] ?? []\n          setHandlers(handlers)\n        }\n\n        if (hasNewEvent) {\n          plugin = new ProseMirrorPlugin({\n            key: new PluginKey('prosekit-dom-event-handler'),\n            props: { handleDOMEvents: combinedHandlerMap },\n          })\n        }\n      }\n\n      return function reducer(inputs) {\n        update(inputs)\n        return plugin ?? []\n      }\n    },\n    parent: pluginFacet,\n    singleton: true,\n  },\n)\n","import type {\n  Node,\n  Slice,\n} from '@prosekit/pm/model'\nimport {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\n\nimport {\n  defineFacet,\n  type Facet,\n} from '../../facets/facet'\nimport { defineFacetPayload } from '../../facets/facet-extension'\nimport type { PlainExtension } from '../../types/extension'\nimport type { ObjectEntries } from '../../types/object-entries'\nimport { groupEntries } from '../../utils/array-grouping'\nimport { combineEventHandlers } from '../../utils/combine-event-handlers'\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from '../plugin'\n\nexport type KeyDownHandler = (\n  view: EditorView,\n  event: KeyboardEvent,\n) => boolean | void\nexport type KeyPressHandler = (\n  view: EditorView,\n  event: KeyboardEvent,\n) => boolean | void\nexport type TextInputHandler = (\n  view: EditorView,\n  from: number,\n  to: number,\n  text: string,\n) => boolean | void\nexport type ClickOnHandler = (\n  view: EditorView,\n  pos: number,\n  node: Node,\n  nodePos: number,\n  event: MouseEvent,\n  direct: boolean,\n) => boolean | void\nexport type ClickHandler = (\n  view: EditorView,\n  pos: number,\n  event: MouseEvent,\n) => boolean | void\nexport type DoubleClickOnHandler = (\n  view: EditorView,\n  pos: number,\n  node: Node,\n  nodePos: number,\n  event: MouseEvent,\n  direct: boolean,\n) => boolean | void\nexport type DoubleClickHandler = (\n  view: EditorView,\n  pos: number,\n  event: MouseEvent,\n) => boolean | void\nexport type TripleClickOnHandler = (\n  view: EditorView,\n  pos: number,\n  node: Node,\n  nodePos: number,\n  event: MouseEvent,\n  direct: boolean,\n) => boolean | void\nexport type TripleClickHandler = (\n  view: EditorView,\n  pos: number,\n  event: MouseEvent,\n) => boolean | void\nexport type PasteHandler = (\n  view: EditorView,\n  event: ClipboardEvent,\n  slice: Slice,\n) => boolean | void\nexport type DropHandler = (\n  view: EditorView,\n  event: DragEvent,\n  slice: Slice,\n  moved: boolean,\n) => boolean | void\nexport type ScrollToSelectionHandler = (view: EditorView) => boolean\n\nfunction defineEventFacetPayload(payload: EditorEventPayload): PlainExtension {\n  return defineFacetPayload(editorEventFacet, [payload]) as PlainExtension\n}\n\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown}\n */\nexport function defineKeyDownHandler(handler: KeyDownHandler): PlainExtension {\n  return defineEventFacetPayload(['keyDown', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyPress}\n */\nexport function defineKeyPressHandler(\n  handler: KeyPressHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['keyPress', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleTextInput}\n */\nexport function defineTextInputHandler(\n  handler: TextInputHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['textInput', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleClickOn}\n */\nexport function defineClickOnHandler(handler: ClickOnHandler): PlainExtension {\n  return defineEventFacetPayload(['clickOn', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleClick}\n */\nexport function defineClickHandler(handler: ClickHandler): PlainExtension {\n  return defineEventFacetPayload(['click', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleDoubleClickOn}\n */\nexport function defineDoubleClickOnHandler(\n  handler: DoubleClickOnHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['doubleClickOn', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleDoubleClick}\n */\nexport function defineDoubleClickHandler(\n  handler: DoubleClickHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['doubleClick', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleTripleClickOn}\n */\nexport function defineTripleClickOnHandler(\n  handler: TripleClickOnHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['tripleClickOn', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleTripleClick}\n */\nexport function defineTripleClickHandler(\n  handler: TripleClickHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['tripleClick', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste}\n */\nexport function definePasteHandler(handler: PasteHandler): PlainExtension {\n  return defineEventFacetPayload(['paste', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleDrop}\n */\nexport function defineDropHandler(handler: DropHandler): PlainExtension {\n  return defineEventFacetPayload(['drop', handler])\n}\n/**\n * @public\n *\n * See {@link https://prosemirror.net/docs/ref/#view.EditorProps.handleScrollToSelection}\n */\nexport function defineScrollToSelectionHandler(\n  handler: ScrollToSelectionHandler,\n): PlainExtension {\n  return defineEventFacetPayload(['scrollToSelection', handler])\n}\n\ninterface EditorEventMap {\n  keyDown: KeyDownHandler\n  keyPress: KeyPressHandler\n  textInput: TextInputHandler\n  clickOn: ClickOnHandler\n  click: ClickHandler\n  doubleClickOn: DoubleClickOnHandler\n  doubleClick: DoubleClickHandler\n  tripleClickOn: TripleClickOnHandler\n  tripleClick: TripleClickHandler\n  paste: PasteHandler\n  drop: DropHandler\n  scrollToSelection: ScrollToSelectionHandler\n}\n\n/**\n * @internal\n */\nexport type EditorEventPayload = ObjectEntries<EditorEventMap>\n\n/**\n * @internal\n */\nexport const editorEventFacet: Facet<EditorEventPayload, PluginPayload> = defineFacet<EditorEventPayload, PluginPayload>({\n  reduce: () => {\n    const [update, plugin] = setupEditorEventPlugin()\n\n    return (entries) => {\n      update(entries)\n      return plugin\n    }\n  },\n  parent: pluginFacet,\n  singleton: true,\n})\n\n// dprint-ignore\nfunction setupEditorEventPlugin() {\n  const [setKeyDownHandlers, handleKeyDown] = combineEventHandlers<KeyDownHandler>()\n  const [setKeyPressHandlers, handleKeyPress] = combineEventHandlers<KeyPressHandler>()\n  const [setTextInputHandlers, handleTextInput] = combineEventHandlers<TextInputHandler>()\n  const [setClickOnHandlers, handleClickOn] = combineEventHandlers<ClickOnHandler>()\n  const [setClickHandlers, handleClick] = combineEventHandlers<ClickHandler>()\n  const [setDoubleClickOnHandlers, handleDoubleClickOn] = combineEventHandlers<DoubleClickOnHandler>()\n  const [setDoubleClickHandlers, handleDoubleClick] = combineEventHandlers<DoubleClickHandler>()\n  const [setTripleClickOnHandlers, handleTripleClickOn] = combineEventHandlers<TripleClickOnHandler>()\n  const [setTripleClickHandlers, handleTripleClick] = combineEventHandlers<TripleClickHandler>()\n  const [setPasteHandlers, handlePaste] = combineEventHandlers<PasteHandler>()\n  const [setDropHandlers, handleDrop] = combineEventHandlers<DropHandler>()\n  const [setScrollToSelectionHandlers, handleScrollToSelection] = combineEventHandlers<ScrollToSelectionHandler>()\n\n  const update = (entries: EditorEventPayload[]) => {\n    const map = groupEntries<EditorEventMap>(entries)\n\n    setKeyDownHandlers(map.keyDown ?? [])\n    setKeyPressHandlers(map.keyPress ?? [])\n    setTextInputHandlers(map.textInput ?? [])\n    setClickOnHandlers(map.clickOn ?? [])\n    setClickHandlers(map.click ?? [])\n    setDoubleClickOnHandlers(map.doubleClickOn ?? [])\n    setDoubleClickHandlers(map.doubleClick ?? [])\n    setTripleClickOnHandlers(map.tripleClickOn ?? [])\n    setTripleClickHandlers(map.tripleClick ?? [])\n    setPasteHandlers(map.paste ?? [])\n    setDropHandlers(map.drop ?? [])\n    setScrollToSelectionHandlers(map.scrollToSelection ?? [])      \n  }\n\n  const plugin = new ProseMirrorPlugin({\n    key: new PluginKey('prosekit-editor-event'),\n    props: {\n      handleKeyDown,\n      handleKeyPress,\n      handleTextInput,\n      handleClickOn,\n      handleClick,\n      handleDoubleClickOn,\n      handleDoubleClick,\n      handleTripleClickOn,\n      handleTripleClick,\n      handlePaste,\n      handleDrop,\n      handleScrollToSelection,\n    },\n  })\n\n  return [update, plugin] as const \n}\n","import type { PlainExtension } from '../../types/extension'\n\nimport { defineDomEventFacetPayload } from './dom-event'\n\n/**\n * A function that is called when the editor gains or loses focus.\n *\n * @param hasFocus - Whether the editor has focus.\n *\n * @public\n */\nexport type FocusChangeHandler = (hasFocus: boolean) => void\n\n/**\n * Registers a event handler that is called when the editor gains or loses focus.\n *\n * @public\n */\nexport function defineFocusChangeHandler(\n  handler: FocusChangeHandler,\n): PlainExtension {\n  const handleFocus = () => handler(true)\n  const handleBlur = () => handler(false)\n  return defineDomEventFacetPayload(\n    ['focus', handleFocus],\n    ['blur', handleBlur],\n  )\n}\n","/**\n * @internal\n */\nexport const isApple: boolean = typeof navigator !== 'undefined'\n  ? /Mac|iP(hone|[ao]d)/.test(navigator.platform)\n  : false\n","import { chainCommands } from '@prosekit/pm/commands'\nimport { keydownHandler } from '@prosekit/pm/keymap'\nimport {\n  Plugin,\n  PluginKey,\n  type Command,\n} from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\nimport mapValues from 'just-map-values'\n\nimport {\n  defineFacet,\n  type Facet,\n} from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { PlainExtension } from '../types/extension'\nimport { toReversed } from '../utils/array'\n\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from './plugin'\n\n/**\n * @public\n */\nexport interface Keymap {\n  [key: string]: Command\n}\n\n/**\n * @public\n */\nexport function defineKeymap(keymap: Keymap): PlainExtension {\n  return defineFacetPayload(keymapFacet, [keymap]) as PlainExtension\n}\n\n/**\n * @internal\n */\nexport type KeymapPayload = Keymap\n\n/**\n * @internal\n */\nexport const keymapFacet: Facet<KeymapPayload, PluginPayload> = defineFacet<\n  KeymapPayload,\n  PluginPayload\n>({\n  reduce: () => {\n    type Handler = (view: EditorView, event: KeyboardEvent) => boolean\n\n    let handler: Handler | undefined\n\n    const handlerWrapper: Handler = (view, event) => {\n      if (handler) return handler(view, event)\n      return false\n    }\n\n    const plugin = new Plugin({\n      key: keymapPluginKey,\n      props: { handleKeyDown: handlerWrapper },\n    })\n\n    return (keymaps: Keymap[]) => {\n      handler = keydownHandler(\n        mergeKeymaps(\n          // The keymap at the end have a higher priority.\n          toReversed(keymaps),\n        ),\n      )\n      return plugin\n    }\n  },\n  parent: pluginFacet,\n  singleton: true,\n})\n\nfunction mergeKeymaps(keymaps: Keymap[]): Keymap {\n  const bindings: Record<string, Command[]> = {}\n\n  for (const keymap of keymaps) {\n    for (const [key, command] of Object.entries(keymap)) {\n      const commands = bindings[key] || (bindings[key] = [])\n      commands.push(command)\n    }\n  }\n\n  return mapValues(bindings, mergeCommands)\n}\n\nfunction mergeCommands(commands: Command[]): Command {\n  return chainCommands(...commands)\n}\n\nconst keymapPluginKey = new PluginKey('prosekit-keymap')\n","import {\n  history,\n  redo,\n  undo,\n} from '@prosekit/pm/history'\n\nimport { union } from '../editor/union'\nimport type { Extension } from '../types/extension'\nimport { isApple } from '../utils/env'\n\nimport { defineCommands } from './command'\nimport {\n  defineKeymap,\n  type Keymap,\n} from './keymap'\nimport { definePlugin } from './plugin'\n\nconst keymap: Keymap = {\n  'Mod-z': undo,\n  'Shift-Mod-z': redo,\n}\n\nif (!isApple) {\n  keymap['Mod-y'] = redo\n}\n\nconst commands = {\n  undo: () => undo,\n  redo: () => redo,\n} as const\n\n/**\n * Options for {@link defineHistory}.\n *\n * @public\n */\nexport interface HistoryOptions {\n  /**\n   * The amount of history events that are collected before the oldest events\n   * are discarded.\n   *\n   * @default 200\n   */\n  depth?: number\n\n  /**\n   * The delay in milliseconds between changes after which a new group should be\n   * started.\n   *\n   * @default 250\n   */\n  newGroupDelay?: number\n}\n\n/**\n * @internal\n */\nexport type HistoryExtension = Extension<{\n  Commands: {\n    undo: []\n    redo: []\n  }\n}>\n\n/**\n * Add undo/redo history to the editor.\n *\n * @param options\n *\n * @public\n */\nexport function defineHistory({\n  depth = 200,\n  newGroupDelay = 250,\n}: HistoryOptions = {}): HistoryExtension {\n  return union(\n    definePlugin(history({ depth, newGroupDelay })),\n    defineKeymap(keymap),\n    defineCommands(commands),\n  )\n}\n","import {\n  baseKeymap,\n  chainCommands,\n  createParagraphNear,\n  deleteSelection,\n  joinTextblockBackward,\n  liftEmptyBlock,\n  newlineInCode,\n  selectNodeBackward,\n} from '@prosekit/pm/commands'\nimport { splitSplittableBlock } from 'prosemirror-splittable'\n\nimport { withPriority } from '../editor/with-priority'\nimport type { PlainExtension } from '../types/extension'\nimport { Priority } from '../types/priority'\n\nimport { defineKeymap } from './keymap'\n\n// Replace `splitBlock` with `splitSplittableBlock`\nconst customEnter = chainCommands(\n  newlineInCode,\n  createParagraphNear,\n  liftEmptyBlock,\n  splitSplittableBlock,\n)\n\n// Replace `joinBackward` with `joinTextblockBackward`\nconst customBackspace = chainCommands(\n  deleteSelection,\n  joinTextblockBackward,\n  selectNodeBackward,\n)\n\nconst customBaseKeymap = {\n  ...baseKeymap,\n  Enter: customEnter,\n  Backspace: customBackspace,\n}\n\n/**\n * @internal\n */\nexport type BaseKeymapExtension = PlainExtension\n\n/**\n * Defines some basic key bindings.\n *\n * @public\n */\nexport function defineBaseKeymap(options?: {\n  /**\n   * The priority of the keymap.\n   *\n   * @default Priority.low\n   */\n  priority?: Priority\n}): BaseKeymapExtension {\n  const priority = options?.priority ?? Priority.low\n  return withPriority(defineKeymap(customBaseKeymap), priority)\n}\n","import type {\n  MarkSpec,\n  ParseRule,\n  SchemaSpec,\n} from '@prosekit/pm/model'\nimport clone from 'just-clone'\nimport OrderedMap from 'orderedmap'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport { schemaSpecFacet } from '../facets/schema-spec'\nimport type {\n  AnyAttrs,\n  AttrSpec,\n} from '../types/attrs'\nimport type { Extension } from '../types/extension'\nimport { groupBy } from '../utils/array-grouping'\nimport { assert } from '../utils/assert'\nimport { mergeSpecs } from '../utils/merge-specs'\nimport {\n  wrapOutputSpecAttrs,\n  wrapTagParseRuleAttrs,\n} from '../utils/output-spec'\nimport { isNotNullish } from '../utils/type-assertion'\n\n/**\n * @public\n */\nexport interface MarkSpecOptions<\n  MarkName extends string = string,\n  Attrs extends AnyAttrs = AnyAttrs,\n> extends MarkSpec {\n  /**\n   * The name of the mark type.\n   */\n  name: MarkName\n\n  /**\n   * The attributes that marks of this type get.\n   */\n  attrs?: { [K in keyof Attrs]: AttrSpec<Attrs[K]> }\n}\n\n/**\n * @public\n */\nexport interface MarkAttrOptions<\n  MarkName extends string = string,\n  AttrName extends string = string,\n  AttrType = any,\n> extends AttrSpec<AttrType> {\n  /**\n   * The name of the mark type.\n   */\n  type: MarkName\n\n  /**\n   * The name of the attribute.\n   */\n  attr: AttrName\n\n  /**\n   * Returns the attribute key and value to be set on the HTML element.\n   *\n   * If the returned `key` is `\"style\"`, the value is a string of CSS properties and will\n   * be prepended to the existing `style` attribute on the DOM node.\n   *\n   * @param value - The value of the attribute of current ProseMirror node.\n   */\n  toDOM?: (value: AttrType) => [key: string, value: string] | null | undefined\n\n  /**\n   * Parses the attribute value from the DOM.\n   */\n  parseDOM?: (node: HTMLElement) => AttrType\n}\n\n/**\n * @public\n */\nexport function defineMarkSpec<\n  Mark extends string,\n  Attrs extends AnyAttrs = AnyAttrs,\n>(\n  options: MarkSpecOptions<Mark, Attrs>,\n): Extension<{\n  Marks: { [K in Mark]: Attrs }\n}> {\n  const payload: MarkSpecPayload = [options, undefined]\n  return defineFacetPayload(markSpecFacet, [payload]) as Extension<{\n    Marks: any\n  }>\n}\n\n/**\n * @public\n */\nexport function defineMarkAttr<\n  MarkType extends string = string,\n  AttrName extends string = string,\n  AttrType = any,\n>(\n  options: MarkAttrOptions<MarkType, AttrName, AttrType>,\n): Extension<{\n  Marks: { [K in MarkType]: AttrType }\n}> {\n  const payload: MarkSpecPayload = [undefined, options]\n  return defineFacetPayload(markSpecFacet, [payload]) as Extension<{\n    Marks: any\n  }>\n}\n\ntype MarkSpecPayload = [\n  MarkSpecOptions | undefined,\n  MarkAttrOptions | undefined,\n]\n\nconst markSpecFacet = defineFacet<MarkSpecPayload, SchemaSpec>({\n  reducer: (payloads: MarkSpecPayload[]): SchemaSpec => {\n    let specs = OrderedMap.from<MarkSpec>({})\n\n    const specPayloads = payloads.map((input) => input[0]).filter(isNotNullish)\n    const attrPayloads = payloads.map((input) => input[1]).filter(isNotNullish)\n\n    for (const { name, ...spec } of specPayloads) {\n      const prevSpec = specs.get(name)\n      if (prevSpec) {\n        specs = specs.update(name, mergeSpecs(prevSpec, spec))\n      } else {\n        // The latest spec has the highest priority, so we put it at the start\n        // of the map.\n        specs = specs.addToStart(name, spec)\n      }\n    }\n\n    const groupedAttrs = groupBy(attrPayloads, (payload) => payload.type)\n\n    for (const [type, attrs] of Object.entries(groupedAttrs)) {\n      if (!attrs) continue\n\n      const maybeSpec = specs.get(type)\n      assert(maybeSpec, `Mark type ${type} must be defined`)\n      const spec = clone(maybeSpec)\n\n      if (!spec.attrs) {\n        spec.attrs = {}\n      }\n\n      for (const attr of attrs) {\n        spec.attrs[attr.attr] = {\n          default: attr.default as unknown,\n          validate: attr.validate,\n        }\n      }\n\n      if (spec.toDOM) {\n        spec.toDOM = wrapOutputSpecAttrs(spec.toDOM, attrs)\n      }\n\n      if (spec.parseDOM) {\n        spec.parseDOM = spec.parseDOM.map((rule) => wrapParseRuleAttrs(rule, attrs))\n      }\n\n      specs = specs.update(type, spec)\n    }\n\n    return { marks: specs, nodes: {} }\n  },\n  parent: schemaSpecFacet,\n  singleton: true,\n})\n\nfunction wrapParseRuleAttrs(\n  rule: ParseRule,\n  attrs: MarkAttrOptions[],\n): ParseRule {\n  if (rule.tag) {\n    return wrapTagParseRuleAttrs(rule, attrs)\n  }\n  return rule\n}\n","import {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type { MarkViewConstructor } from '@prosekit/pm/view'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { Extension } from '../types/extension'\n\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from './plugin'\n\nexport interface MarkViewOptions {\n  name: string\n  constructor: MarkViewConstructor\n}\n\nexport function defineMarkView(options: MarkViewOptions): Extension {\n  return defineFacetPayload(markViewFacet, [options])\n}\n\nconst markViewFacet = defineFacet<MarkViewOptions, PluginPayload>({\n  reducer: (inputs: MarkViewOptions[]): PluginPayload => {\n    const markViews: { [markName: string]: MarkViewConstructor } = {}\n\n    for (const input of inputs) {\n      if (!markViews[input.name]) {\n        markViews[input.name] = input.constructor\n      }\n    }\n\n    return () => [\n      new ProseMirrorPlugin({\n        key: new PluginKey('prosekit-mark-view'),\n        props: { markViews },\n      }),\n    ]\n  },\n  parent: pluginFacet,\n})\n","import {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type { MarkViewConstructor } from '@prosekit/pm/view'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { Extension } from '../types/extension'\nimport { isNotNullish } from '../utils/type-assertion'\n\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from './plugin'\n\n/**\n * @internal\n */\nexport type MarkViewFactoryOptions<T> = {\n  group: string\n  factory: (args: T) => MarkViewConstructor\n}\n\n/**\n * @internal\n */\nexport type MarkViewComponentOptions<T> = {\n  group: string\n  name: string\n  args: T\n}\n\ntype MarkViewFactoryInput = [\n  MarkViewFactoryOptions<any> | null,\n  MarkViewComponentOptions<any> | null,\n]\n\n/**\n * @internal\n */\nexport function defineMarkViewFactory<T>(\n  options: MarkViewFactoryOptions<T>,\n): Extension {\n  const input: MarkViewFactoryInput = [options, null]\n  return defineFacetPayload(markViewFactoryFacet, [input])\n}\n\n/**\n * @internal\n */\nexport function defineMarkViewComponent<T>(\n  options: MarkViewComponentOptions<T>,\n): Extension {\n  const input: MarkViewFactoryInput = [null, options]\n  return defineFacetPayload(markViewFactoryFacet, [input])\n}\n\nconst isServer = typeof window === 'undefined'\n\nconst markViewFactoryFacet = defineFacet<MarkViewFactoryInput, PluginPayload>({\n  reducer: (inputs: MarkViewFactoryInput[]): PluginPayload => {\n    // Don't register mark views on the server\n    if (isServer) return []\n\n    const markViews: { [markName: string]: MarkViewConstructor } = {}\n\n    const factories = inputs.map((x) => x[0]).filter(isNotNullish)\n    const options = inputs.map((x) => x[1]).filter(isNotNullish)\n\n    for (const { group, name, args } of options) {\n      const factory = factories.find((factory) => factory.group === group)\n      if (!factory) continue\n      markViews[name] = factory.factory(args)\n    }\n\n    return () => [\n      new ProseMirrorPlugin({\n        key: new PluginKey('prosekit-mark-view-effect'),\n        props: { markViews },\n      }),\n    ]\n  },\n  parent: pluginFacet,\n})\n","import {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type { NodeViewConstructor } from '@prosekit/pm/view'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { Extension } from '../types/extension'\n\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from './plugin'\n\nexport interface NodeViewOptions {\n  name: string\n  constructor: NodeViewConstructor\n}\n\nexport function defineNodeView(options: NodeViewOptions): Extension {\n  return defineFacetPayload(nodeViewFacet, [options])\n}\n\nconst nodeViewFacet = defineFacet<NodeViewOptions, PluginPayload>({\n  reducer: (inputs: NodeViewOptions[]): PluginPayload => {\n    const nodeViews: { [nodeName: string]: NodeViewConstructor } = {}\n\n    for (const input of inputs) {\n      if (!nodeViews[input.name]) {\n        nodeViews[input.name] = input.constructor\n      }\n    }\n\n    return () => [\n      new ProseMirrorPlugin({\n        key: new PluginKey('prosekit-node-view'),\n        props: { nodeViews },\n      }),\n    ]\n  },\n  parent: pluginFacet,\n})\n","import {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type { NodeViewConstructor } from '@prosekit/pm/view'\n\nimport { defineFacet } from '../facets/facet'\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport type { Extension } from '../types/extension'\nimport { isNotNullish } from '../utils/type-assertion'\n\nimport {\n  pluginFacet,\n  type PluginPayload,\n} from './plugin'\n\n/**\n * @internal\n */\nexport type NodeViewFactoryOptions<T> = {\n  group: string\n  factory: (args: T) => NodeViewConstructor\n}\n\n/**\n * @internal\n */\nexport type NodeViewComponentOptions<T> = {\n  group: string\n  name: string\n  args: T\n}\n\ntype NodeViewFactoryInput = [\n  NodeViewFactoryOptions<any> | null,\n  NodeViewComponentOptions<any> | null,\n]\n\n/**\n * @internal\n */\nexport function defineNodeViewFactory<T>(\n  options: NodeViewFactoryOptions<T>,\n): Extension {\n  const input: NodeViewFactoryInput = [options, null]\n  return defineFacetPayload(nodeViewFactoryFacet, [input])\n}\n\n/**\n * @internal\n */\nexport function defineNodeViewComponent<T>(\n  options: NodeViewComponentOptions<T>,\n): Extension {\n  const input: NodeViewFactoryInput = [null, options]\n  return defineFacetPayload(nodeViewFactoryFacet, [input])\n}\n\nconst isServer = typeof window === 'undefined'\n\nconst nodeViewFactoryFacet = defineFacet<NodeViewFactoryInput, PluginPayload>({\n  reducer: (inputs: NodeViewFactoryInput[]): PluginPayload => {\n    // Don't register node views on the server\n    if (isServer) return []\n\n    const nodeViews: { [nodeName: string]: NodeViewConstructor } = {}\n\n    const factories = inputs.map((x) => x[0]).filter(isNotNullish)\n    const options = inputs.map((x) => x[1]).filter(isNotNullish)\n\n    for (const { group, name, args } of options) {\n      const factory = factories.find((factory) => factory.group === group)\n      if (!factory) continue\n      nodeViews[name] = factory.factory(args)\n    }\n\n    return () => [\n      new ProseMirrorPlugin({\n        key: new PluginKey('prosekit-node-view-effect'),\n        props: { nodeViews },\n      }),\n    ]\n  },\n  parent: pluginFacet,\n})\n","import type { Attrs } from '@prosekit/pm/model'\n\nimport { withPriority } from '../editor/with-priority'\nimport type { Extension } from '../types/extension'\nimport { Priority } from '../types/priority'\n\nimport { defineNodeSpec } from './node-spec'\n\n/**\n * @internal\n */\ntype ParagraphSpecExtension = Extension<{\n  Nodes: {\n    paragraph: Attrs\n  }\n}>\n\n/**\n * Defines a paragraph node spec.\n */\nfunction defineParagraphSpec(): ParagraphSpecExtension {\n  return defineNodeSpec({\n    name: 'paragraph',\n    content: 'inline*',\n    group: 'block',\n    parseDOM: [{ tag: 'p' }],\n    toDOM() {\n      return ['p', 0]\n    },\n  })\n}\n\n/**\n * @internal\n *\n * @deprecated Use the following import instead:\n *\n * ```ts\n * import type { ParagraphExtension } from 'prosekit/extensions/paragraph'\n * ```\n */\nexport type ParagraphExtension = ParagraphSpecExtension\n\n/**\n * @public\n *\n * Defines a paragraph node spec as the highest priority, because it should be the default block node for most cases.\n *\n * @deprecated Use the following import instead:\n *\n * ```ts\n * import { defineParagraph } from 'prosekit/extensions/paragraph'\n * ```\n */\nexport function defineParagraph(): ParagraphExtension {\n  console.warn(\n    '[prosekit] The `defineParagraph` function from `prosekit/core` is deprecated. Use the following import instead: `import { defineParagraph } from \"prosekit/extensions/paragraph\"`.',\n  )\n\n  return withPriority(defineParagraphSpec(), Priority.highest)\n}\n","import type { Attrs } from '@prosekit/pm/model'\n\nimport type { Extension } from '../types/extension'\n\nimport { defineNodeSpec } from './node-spec'\n\n/**\n * @internal\n */\nexport type TextExtension = Extension<{\n  Nodes: {\n    text: Attrs\n  }\n}>\n\n/**\n * @public\n *\n * @deprecated Use the following import instead:\n *\n * ```ts\n * import { defineText } from 'prosekit/extensions/text'\n * ```\n */\nexport function defineText(): TextExtension {\n  console.warn(\n    '[prosekit] The `defineText` function from `prosekit/core` is deprecated. Use the following import instead: `import { defineText } from \"prosekit/extensions/text\"`.',\n  )\n\n  return defineNodeSpec({\n    name: 'text',\n    group: 'inline',\n  })\n}\n","import { once } from '@ocavue/utils'\n\n/**\n * Checks if the browser supports [regex lookbehind assertion](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion).\n */\nexport const canUseRegexLookbehind: () => boolean = once(() => {\n  try {\n    return 'ab'.replace(new RegExp('(?<=a)b', 'g'), 'c') === 'ac'\n  } catch {\n    return false\n  }\n})\n","import clsxLite from 'clsx/lite'\n\n/**\n * A utility for constructing `className` strings conditionally.\n *\n * It is a re-export of [clsx/lite](https://www.npmjs.com/package/clsx) with stricter types.\n *\n * @public\n */\nexport const clsx: (\n  ...args: Array<string | boolean | null | undefined>\n) => string = clsxLite\n","import type {\n  Fragment,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\n\n/**\n * Collects all children of a node or a fragment, and returns them as an array.\n *\n * @deprecated Use `node.children` or `fragment.content` instead.\n *\n * @hidden\n */\nexport function collectChildren(\n  parent: ProseMirrorNode | Fragment,\n): ProseMirrorNode[] {\n  const children: ProseMirrorNode[] = []\n  for (let i = 0; i < parent.childCount; i++) {\n    children.push(parent.child(i))\n  }\n  return children\n}\n","import {\n  ProseMirrorFragment,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\n\nimport { ProseKitError } from '../error'\n\n/**\n * @hidden\n *\n * @deprecated\n */\nexport type NodeContent = ProseMirrorNode | ProseMirrorFragment | NodeContent[]\n\n/**\n * Collects all nodes from a given content.\n *\n * @deprecated Use `collectChildren` instead.\n *\n * @hidden\n */\nexport function collectNodes(content: NodeContent): ProseMirrorNode[] {\n  if (Array.isArray(content)) {\n    return content.flatMap(collectNodes)\n  }\n  if (content instanceof ProseMirrorNode) {\n    return [content]\n  }\n  if (content instanceof ProseMirrorFragment) {\n    const nodes: ProseMirrorNode[] = []\n    for (let i = 0; i < content.childCount; i++) {\n      nodes.push(content.child(i))\n    }\n    return nodes\n  }\n  throw new ProseKitError(`Invalid node content: ${typeof content}`)\n}\n","import type { ProseMirrorNode } from '@prosekit/pm/model'\n\n/**\n * @internal\n */\nexport function containsInlineNode(\n  doc: ProseMirrorNode,\n  from: number,\n  to: number,\n): boolean {\n  let found = false\n  doc.nodesBetween(from, to, (node) => {\n    if (found) return false\n    if (node.isInline) found = true\n  })\n  return found\n}\n","let id = 0\n\n/**\n * Returns a unique id in the current process that can be used in various places.\n *\n * @internal\n *\n * @deprecated Import `getId` from `@ocavue/utils` package instead. Remove it in a future version.\n */\nexport function getId(): string {\n  id = (id + 1) % Number.MAX_SAFE_INTEGER\n  return `id:${id}`\n}\n","import type { ResolvedPos } from '@prosekit/pm/model'\nimport type {\n  EditorState,\n  TextSelection,\n} from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\n\n/**\n * Whether the selection is an empty text selection at the start of a block.\n *\n * @internal\n */\nexport function isAtBlockStart(\n  state: EditorState,\n  view?: EditorView,\n): ResolvedPos | null {\n  // Copy from https://github.com/ProseMirror/prosemirror-commands/blob/1.5.2/src/commands.ts#L15\n  const { $cursor } = state.selection as TextSelection\n  if (\n    !$cursor\n    || (view ? !view.endOfTextblock('backward', state) : $cursor.parentOffset > 0)\n  ) {\n    return null\n  }\n  return $cursor\n}\n","import type { NodeType } from '@prosekit/pm/model'\nimport type { Selection } from '@prosekit/pm/state'\n\nfunction isCodeBlockType(type: NodeType): boolean {\n  return !!(type.spec.code && type.isBlock)\n}\n\n/**\n * Check if the selection is in a code block.\n *\n * @internal\n */\nexport function isInCodeBlock(selection: Selection): boolean {\n  return (\n    isCodeBlockType(selection.$from.parent.type)\n    || isCodeBlockType(selection.$to.parent.type)\n  )\n}\n","/**\n * @internal\n */\nexport function maybeRun<\n  Value,\n  Args extends unknown[],\n>(value: Value | ((...args: Args) => Value), ...args: Args): Value {\n  return typeof value === 'function'\n    ? (value as (...args: Args) => Value)(...args)\n    : value\n}\n","/**\n * @internal\n */\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\uFFFC'\n","import type { Command } from '@prosekit/pm/state'\n\nimport { isInCodeBlock } from './is-in-code-block'\n\n/**\n * @internal\n */\nexport function withSkipCodeBlock(command: Command): Command {\n  return (state, dispatch, view) => {\n    if (isInCodeBlock(state.selection)) {\n      return false\n    }\n    return command(state, dispatch, view)\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAuCA,SAAgB,QAAQ,SAAkC;AACxD,SAAQ,OAAO,aAAa;EAC1B,MAAM,OAAO,YAAY,MAAM,QAAQ,QAAQ,KAAK,CAAC,OAAO,QAAQ,MAAM;EAC1E,MAAM,OAAO,QAAQ,QAAQ,MAAM,UAAU;EAC7C,MAAM,KAAK,QAAQ,MAAM,MAAM,UAAU;AACzC,MAAI,OAAO,GACT,QAAO;AAET,aAAW,MAAM,GAAG,QAAQ,MAAM,IAAI,KAAK,CAAC;AAC5C,SAAO;;;;;;;;;;;ACrBX,SAAgB,WAAW,SAAqC;AAC9D,SAAQ,OAAO,aAAa;EAC1B,MAAM,WAAW,YAAY,MAAM,QAAQ,QAAQ,KAAK;EACxD,MAAM,aAAa,SAAe,KAAK,SAAS;EAEhD,MAAM,OAAO,iBAAiB,MAAM,UAAU,OAAO,UAAU;EAC/D,MAAM,KAAK,gBAAgB,MAAM,UAAU,KAAK,UAAU;AAE1D,MAAI,SAAS,MAAM,UAAU,QAAQ,OAAO,MAAM,UAAU,GAC1D,QAAO;AAGT,MAAI,SACF,UAAS,MAAM,GAAG,aAAa,cAAc,OAAO,MAAM,KAAK,MAAM,GAAG,CAAC,CAAC;AAE5E,SAAO;;;AAIX,SAAS,iBACP,MACA,WACQ;CACR,MAAM,EAAE,WAAW;AAEnB,KAAI,CAAC,KAAK,OAAO,CAAC,KAAK,UAAU,CAC/B,QAAO,KAAK;CAGd,MAAM,QAAQ,KAAK,OAAO;CAC1B,IAAI,gBAAgB;AAEpB,MAAK,IAAI,IAAI,OAAO,KAAK,GAAG,IAE1B,KADa,OAAO,MAAM,EAAE,CACnB,MAAM,KAAK,UAAU,CAC5B,iBAAgB;KAEhB;AAIJ,QAAO,KAAK,WAAW,cAAc;;AAGvC,SAAS,gBACP,MACA,WACQ;CACR,MAAM,EAAE,WAAW;AAEnB,KAAI,CAAC,KAAK,OAAO,CAAC,KAAK,UAAU,CAC/B,QAAO,KAAK;CAGd,MAAM,QAAQ,KAAK,IAAI,GAAG,KAAK,YAAY,GAAG,EAAE;CAChD,MAAM,aAAa,OAAO;CAC1B,IAAI,gBAAgB;AAEpB,MAAK,IAAI,IAAI,OAAO,IAAI,YAAY,IAElC,KADa,OAAO,MAAM,EAAE,CACnB,MAAM,KAAK,UAAU,CAC5B,iBAAgB;KAEhB;AAIJ,QAAO,KAAK,WAAW,cAAc,GAAG,OAAO,MAAM,cAAc,CAAC;;;;;;;;ACtFtE,SAAgB,eAAe,OAAsC;AACnE,MAAK,IAAI,IAAI,GAAG,IAAI,MAAM,WAAW,KAAK;EACxC,MAAM,EAAE,SAAS,MAAM,KAAK,EAAE;AAC9B,MAAI,KAAK,eAAe,CAAC,KAAK,kBAAkB,CAAE,QAAO;;AAE3D,QAAO;;;;;;;;;;;ACWT,SAAgB,mBACd,SACS;AACT,SAAQ,OAAO,aAAa;EAC1B,MAAM,OAAO,SAAS,OAAO,OACzB,MAAM,UAAU,MAChB,MAAM,IAAI,QAAQ,QAAQ,IAAI;EAClC,MAAM,QAAQ,KAAK,OAAO,cAAc,KAAK,QAAQ,IAAI,KAAK;EAC9D,MAAM,SAAS,KAAK,KAAK,MAAM;EAC/B,MAAM,QAAQ,KAAK,WAAW,MAAM;EACpC,MAAM,OAAO,eAAe,OAAO,eAAe,MAAM,CAAC;AACzD,MAAI,CAAC,KAAM,QAAO;AAClB,MAAI,UAAU;GACZ,MAAM,MAAM,KAAK,WAAW,OAAO,MAAM;GACzC,MAAM,OAAO,KAAK,eAAe;AACjC,OAAI,CAAC,KAAM,QAAO;GAClB,MAAM,KAAK,MAAM,GAAG,OAAO,KAAK,KAAK;GACrC,MAAM,YAAY,cAAc,SAAS,GAAG,IAAI,QAAQ,IAAI,EAAE,EAAE;AAChE,OAAI,CAAC,UAAW,QAAO;AACvB,MAAG,aAAa,UAAU;AAC1B,YAAS,GAAG,gBAAgB,CAAC;;AAE/B,SAAO;;;;;;ACzCX,SAAgB,mBAAmB,IAAiB,KAAmB;CACrE,MAAM,UAAU,GAAG,IAAI,QAAQ;CAC/B,MAAM,OAAO,GAAG,IAAI,QAAQ,MAAM,UAAU,UAAU,MAAM,IAAI,IAAI,IAAI;CACxE,MAAM,YAAY,cAAc,QAAQ,MAAM,KAAK;AACnD,IAAG,aAAa,UAAU;;;;;;;;;;;ACmC5B,SAAS,WAAW,SAAqC;AACvD,SAAQ,OAAO,aAAa;EAC1B,MAAM,OAAO,QAAQ,OACjB,QAAQ,OACR,QAAQ,OACR,YAAY,MAAM,QAAQ,QAAQ,KAAK,CAAC,cAAc,QAAQ,MAAM,GACpE;AAEJ,SAAO,MAAM,2CAA2C;EAExD,MAAM,YAAY,YAChB,MAAM,KACN,QAAQ,OAAO,MAAM,UAAU,QAC/B,KAAK,KACN;AACD,MAAI,aAAa,KAAM,QAAO;AAE9B,MAAI,UAAU;GACZ,MAAM,KAAK,MAAM,GAAG,OAAO,WAAW,KAAK;AAC3C,sBAAmB,IAAI,YAAY,KAAK,SAAS;AACjD,YAAS,GAAG;;AAEd,SAAO;;;;;;;;;;;AC3BX,SAAgB,WAAW,SAAqC;AAC9D,SAAQ,OAAO,aAAa;EAC1B,MAAM,WAAW,YAAY,MAAM,QAAQ,QAAQ,KAAK;EACxD,MAAM,OAAO,QAAQ,QAAQ,SAAS,OAAO,QAAQ,MAAM,GAAG;EAC9D,MAAM,OAAO,QAAQ,QAAQ,MAAM,UAAU;EAC7C,MAAM,KAAK,QAAQ,MAAM,MAAM,UAAU;AACzC,MAAI,OAAO,GACT,QAAO;AAET,aAAW,MAAM,GAAG,WAAW,MAAM,IAAI,KAAK,CAAC;AAC/C,SAAO;;;;;;;;;;;ACdX,SAAgB,eAId,WAIA,MACkC;AAClC,MAAK,IAAI,QAAQ,KAAK,OAAO,SAAS,GAAG,SAAS,GAAG;EACnD,MAAM,OAAO,KAAK,KAAK,MAAM;AAE7B,MAAI,UAAU,KAAK,EAAE;GACnB,MAAM,MAAM,UAAU,IAAI,IAAI,KAAK,OAAO,MAAM;GAChD,MAAM,QAAQ,KAAK,MAAM,MAAM;AAC/B,UAAO;IAAE;IAAM;IAAK;IAAO;IAAO;;;;;;;;;;;;ACnCxC,SAAgB,qBAId,MAIA,MACkC;CAClC,MAAM,WAAW,YAAY,KAAK,IAAI,KAAK,QAAQ,KAAK;AACxD,QAAO,gBAAgB,SAAS,KAAK,SAAS,UAAU,KAAK;;;;;;;;;;ACA/D,SAAgB,WAAW,SAAqC;AAC9D,SAAQ,OAAO,aAAa;EAC1B,MAAM,OAAO,OAAO,QAAQ,QAAQ,WAChC,MAAM,IAAI,QAAQ,QAAQ,IAAI,GAC9B,MAAM,UAAU;EAEpB,MAAM,QAAQ,qBAAqB,QAAQ,MAAM,KAAK;AACtD,MAAI,CAAC,MAAO,QAAO;EAEnB,MAAM,EAAE,KAAK,SAAS;AACtB,aAAW,MAAM,GAAG,OAAO,KAAK,MAAM,KAAK,SAAS,CAAC;AACrD,SAAO;;;;;;AChCX,SAAgB,mBACd,OACA,MACA,IACW;CACX,MAAM,MAAM,QAAQ;AACpB,KAAI,OAAO,MAAM;EACf,MAAM,QAAQ,MAAM,IAAI,QAAQ,QAAQ,IAAI;EAC5C,MAAM,MAAM,MAAM,IAAI,QAAQ,MAAM,IAAI;AACxC,SAAO,cAAc,QAAQ,OAAO,IAAI;;AAE1C,QAAO,MAAM;;;;;;;;;;;ACQf,SAAgB,aAAa,SAAuC;AAClE,SAAQ,OAAO,aAAa;EAC1B,MAAM,WAAW,YAAY,MAAM,QAAQ,QAAQ,KAAK;EACxD,MAAM,YAAY,mBAAmB,OAAO,QAAQ,MAAM,QAAQ,GAAG;EACrE,MAAM,QAAQ,QAAQ;EAEtB,IAAI,aAAa;AACjB,OAAK,IAAI,IAAI,GAAG,IAAI,UAAU,OAAO,UAAU,CAAC,YAAY,KAAK;GAC/D,MAAM,EACJ,OAAO,EAAE,KAAK,QACd,KAAK,EAAE,KAAK,SACV,UAAU,OAAO;AACrB,SAAM,IAAI,aAAa,MAAM,KAAK,MAAM,QAAQ;AAC9C,QAAI,WAAY,QAAO;AACvB,QAAI,CAAC,KAAK,eAAe,KAAK,UAAU,UAAU,MAAM,CAAE;AAC1D,QAAI,KAAK,QAAQ,SACf,cAAa;SACR;KACL,MAAM,OAAO,MAAM,IAAI,QAAQ,IAAI,EACjC,QAAQ,KAAK,OAAO;AACtB,kBAAa,KAAK,OAAO,eAAe,OAAO,QAAQ,GAAG,SAAS;;KAErE;;AAEJ,MAAI,CAAC,WAAY,QAAO;AACxB,MAAI,UAAU;GACZ,MAAM,KAAK,MAAM;AACjB,QAAK,MAAM,SAAS,UAAU,QAAQ;IACpC,MAAM,EACJ,OAAO,EAAE,KAAK,QACd,KAAK,EAAE,KAAK,SACV;AACJ,OAAG,aAAa,MAAM,IAAI,UAAU,MAAM;;AAE5C,YAAS,GAAG,gBAAgB,CAAC;;AAE/B,SAAO;;;;;;;;;ACnDX,SAAgB,aACd,QACA,OACY;AACZ,KAAI,MAAM,QAAQ,MAAM,CACtB,QAAO,MAAM,KAAK,SAAS,YAAY,QAAQ,KAAK,CAAC;AAEvD,QAAO,CAAC,YAAY,QAAQ,MAAM,CAAC;;;;;;;;;;ACmBrC,SAAgB,aAAa,SAAuC;AAClE,SAAQ,OAAO,aAAa;EAC1B,MAAM,YAAY,aAAa,MAAM,QAAQ,QAAQ,KAAK;EAC1D,MAAM,OAAO,QAAQ,OAAO,MAAM,UAAU;EAC5C,MAAM,KAAK,QAAQ,OAAO,MAAM,UAAU;EAC1C,MAAMA,YAAsB,EAAE;AAE9B,QAAM,IAAI,aAAa,MAAM,KAAK,MAAM,QAAQ;AAC9C,OAAI,UAAU,SAAS,KAAK,KAAK,CAC/B,WAAU,KAAK,IAAI;AAErB,OAAI,CAAC,YAAY,UAAU,SAAS,EAClC,QAAO;IAET;AAEF,MAAI,UAAU,WAAW,EACvB,QAAO;AAGT,MAAI,UAAU;GACZ,MAAM,EAAE,OAAO;AACf,QAAK,MAAM,OAAO,UAChB,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,QAAQ,MAAM,CACtD,IAAG,iBAAiB,KAAK,KAAK,MAAM;AAGxC,YAAS,GAAG;;AAEd,SAAO;;;;;;;;;;;;;ACfX,SAAgB,WAAW,EACzB,MACA,OACA,oBAAoB,OACpB,mBAAmB,QACU;AAC7B,SAAQ,OAAO,UAAU,SAAS;AAChC,SAAOC,aAAe,YAAY,MAAM,QAAQ,KAAK,EAAE,OAAO;GAC5D;GACA;GACD,CAAC,CAAC,OAAO,UAAU,KAAK;;;;;;;;;;;;;;AC3B7B,SAAgB,WAAW,EAAE,MAAM,SAAqC;AACtE,SAAQ,OAAO,UAAU,SAAS;AAChC,MAAI,aAAa,OAAO,MAAM,MAAM,EAAE;GACpC,MAAM,cAAc,MAAM,OAAO,YAAY,aAAa;AAC1D,OAAI,CAAC,YACH,QAAO;AAET,UAAOC,eAAa,YAAY,CAAC,OAAO,UAAU,KAAK;SAClD;GACL,MAAM,WAAW,YAAY,MAAM,QAAQ,KAAK;AAChD,UAAOA,eAAa,UAAU,MAAM,CAAC,OAAO,UAAU,KAAK;;;;;;;;;;;;;;ACPjE,SAAgB,KAAK,SAA+B;AAClD,SAAQ,OAAO,aAAa;EAC1B,MAAM,EAAE,OAAO,QAAQ,MAAM;EAC7B,MAAM,QAAQ,MAAM,WAAW,IAAI;AACnC,MAAI,CAAC,MAAO,QAAO;EAEnB,MAAM,WAAW,YAAY,MAAM,QAAQ,QAAQ,YAAY,QAAQ,KAAK;EAC5E,MAAM,WAAW,aAAa,OAAO,UAAU,QAAQ,MAAM;AAC7D,MAAI,CAAC,SAAU,QAAO;AAEtB,aAAW,MAAM,GAAG,KAAK,OAAO,SAAS,CAAC;AAC1C,SAAO;;;;;;;;;;;;;;AChBX,SAAgB,WAAW,SAAqC;CAC9D,MAAM,EAAE,MAAM,UAAU;AAExB,SAAQ,OAAO,aAAa;AAC1B,MAAI,aAAa,OAAO,MAAM,MAAM,CAClC,QAAO,KAAK,OAAO,SAAS;AAG9B,SAAO,KAAK;GAAE;GAAM;GAAO,CAAC,CAAC,OAAO,SAAS;;;;;;;;;;;;ACNjD,SAAgB,eAAe,SAA0C;AACvE,SAAQ,OAAO,aAAa;EAC1B,MAAM,OAAO,SAAS,QAAQ,MAAM,UAAU;EAC9C,MAAM,KAAK,SAAS,MAAM,MAAM,UAAU;AAC1C,MAAI,OAAO,GAAI,QAAO;EAEtB,MAAM,KAAK,MAAM;AACjB,MAAI,mBAAmB,IAAI,MAAM,GAAG,EAAE;AACpC,cAAW,GAAG;AACd,UAAO;;AAET,SAAO;;;AAIX,SAAS,mBACP,IACA,MACA,IACS;CACT,MAAM,UAAU,GAAG,MAAM;AACzB,IAAG,IAAI,aAAa,MAAM,KAAK,MAAM,KAAK,QAAQ,UAAmB;AACnE,MAAI,CAAC,UAAU,CAAC,KAAK,YAAa,QAAO;EAEzC,MAAM,cAAc,OAAO,eAAe,MAAM,CAAC;AACjD,MACE,eACG,YAAY,eACZ,KAAK,SAAS,eACd,YAAY,aAAa,KAAK,QAAQ,EACzC;GACA,MAAM,UAAU,GAAG,QAAQ,MAAM,QAAQ;GACzC,MAAM,QAAQ,QAAQ,IAAI,KAAK,EAAE;GACjC,MAAM,MAAM,QAAQ,IAAI,MAAM,KAAK,UAAU,EAAE;GAC/C,MAAM,OAAO,IAAI,kBACf,OACA,KACA,QAAQ,GACR,MAAM,GACN,IAAI,MAAM,SAAS,KAAK,YAAY,QAAQ,CAAC,EAAE,GAAG,EAAE,EACpD,GACA,KACD;AACD,MAAG,KAAK,KAAK;;AAEf,SAAO;GACP;AACF,QAAO,GAAG,MAAM,SAAS;;;;;;;;;;ACtD3B,SAAgB,UAAU,SAAqC;AAC7D,SAAQ,OAAO,aAAa;EAC1B,MAAM,OAAO,SAAS,QAAQ,MAAM,UAAU;EAC9C,MAAM,KAAK,SAAS,MAAM,MAAM,UAAU;AAC1C,MAAI,OAAO,GAAI,QAAO;AAEtB,aAAW,MAAM,GAAG,WAAW,MAAM,GAAG,CAAC;AACzC,SAAO;;;;;;;;;;;;;;;;;;AChBX,SAAgB,aACd,WACA,UACG;CACH,MAAM,SAAS,MAAM,UAAU;AAC/B,QAAO,WAAW;AAClB,QAAO;;;;;;;;;;;;;ACGT,SAAgB,aACd,QAIgB;AAChB,KACE,kBAAkB,UACd,MAAM,QAAQ,OAAO,IAAI,OAAO,OAAO,MAAM,aAAa,OAAO,CAErE,QAAO,0BAA0B,OAAO;AAG1C,KAAI,OAAO,WAAW,WACpB,QAAO,oBAAoB,OAAO;AAGpC,OAAM,IAAI,UAAU,iBAAiB;;AAGvC,SAAS,oBAAoB,SAAwC;AACnE,QAAO,mBAAmB,aAAa,CAAC,QAAQ,CAAC;;;;;AAcnD,MAAaC,cAAkD,YAAY;CACzE,UAAU,aAA2B;AACnC,UAAQ,EAAE,aAAa;GACrB,MAAMC,UAA+B,EAAE;AAEvC,QAAK,MAAM,WAAW,SACpB,KAAI,mBAAmB,OACrB,SAAQ,KAAK,QAAQ;YAErB,MAAM,QAAQ,QAAQ,IACnB,QAAQ,OAAO,MAAM,aAAa,OAAO,CAE5C,SAAQ,KAAK,GAAG,QAAQ;YACf,OAAO,YAAY,WAC5B,SAAQ,KAAK,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC;OAE7C,OAAM,IAAI,cAAc,iBAAiB;AAQ7C,WAAQ,SAAS;AACjB,UAAO,EAAE,SAAS;;;CAGtB,QAAQ;CACT,CAAC;;;;AClDF,SAAS,cAAqC,UAA4E;AACxH,SAAQ,OAAU,SAAS,OAAO,aAAa,CAAC,QAAQ,MAAI,YAAY,QAAQC,KAAG,EAAE,GAAG;;AAG1F,SAAS,aAAoC,IAAO,SAAiC;AACnF,QAAO,UAAU,QAAQ,GAAG,GAAG;;AAGjC,IAAM,sBAAN,cAAkC,cAAc;CAC9C,YACE,OACA,OACA,AAAQC,0BACR,AAAQC,sBACR;AACA,QAAM,OAAO,MAAM;EAHX;EACA;;CAKV,AAAS,kBAAkB,GAAG,MAAoF;EAChH,MAAMC,MAAiC,GAAGC,WAAS,MAAM,kBAAkB,GAAGA,OAAK;AACnF,SAAO,aAAa,IAAI,KAAK,yBAAyB,CAAC,GAAG,KAAK;;CAGjE,AAAS,cAAc,GAAG,MAA4E;EACpG,MAAMC,MAA6B,GAAGD,WAAS,MAAM,cAAc,GAAGA,OAAK;AAC3E,SAAO,aAAa,IAAI,KAAK,qBAAqB,CAAC,GAAG,KAAK;;;AAI/D,SAAS,0BAA0B,QAAgB,SAAqC;CACtF,MAAME,mBAA4C,GAAG,SAAS,cAAc,gBAAgB,GAAG,KAAK;CACpG,MAAMC,mBAA4C,GAAG,SAAS,cAAc,gBAAgB,GAAG,KAAK;CACpG,MAAM,QAAQ,aAAa,iBAAiB,QAAQ,uBAAuB,CAAC,OAAO;CACnF,MAAM,QAAQ,aAAa,iBAAiB,QAAQ,uBAAuB,CAAC,OAAO;AACnF,QAAO,IAAI,oBAAoB,OAAO,OAAO,QAAQ,0BAA0B,QAAQ,qBAAqB;;AAG9G,MAAM,2BAA2B,YAAuD;CACtF,UAAU,WAAwD;EAChE,MAAMC,UAAsC;GAC1C,0BAA0B,cAAc,OAAO,KAAK,UAAU,MAAM,yBAAyB,CAAC;GAC9F,sBAAsB,cAAc,OAAO,KAAK,UAAU,MAAM,qBAAqB,CAAC;GACtF,wBAAwB,cAAc,OAAO,KAAK,UAAU,MAAM,uBAAuB,CAAC;GAC1F,wBAAwB,cAAc,OAAO,KAAK,UAAU,MAAM,uBAAuB,CAAC;GAC3F;AAED,UAAQ,EAAE,aAAa;GACrB,MAAM,sBAAsB,0BAA0B,QAAQ,QAAQ;AAEtE,UAAO,CACL,IAAI,kBAAkB;IACpB,KAAK,IAAI,UAAU,gCAAgC;IACnD,OAAO,EAAE,qBAAqB;IAC/B,CAAC,CACH;;;CAGL,WAAW;CACX,QAAQ;CACT,CAAC;;;;AAKF,SAAgB,0BAA0B,SAAqD;AAC7F,QAAO,mBAAmB,0BAA0B,CAAC,QAAQ,CAAC;;;;;;;;;;ACzFhE,SAAgB,WAAW,EAAE,MAAM,MAAM,MAAkC;AACzE,SAAQ,OAAO,aAAa;AAC1B,MAAI,KACF,YAAW,MAAM,GAAG,WAAW,MAAM,MAAM,GAAG,CAAC;AAEjD,SAAO;;;;;;;;;;;ACXX,SAAgB,YAAqB;AACnC,SAAQ,OAAO,aAAa;AAC1B,aAAW,MAAM,GAAG,aAAa,IAAI,aAAa,MAAM,IAAI,CAAC,CAAC;AAC9D,SAAO;;;;;;ACAX,MAAaC,eAAmD,YAAY;CAC1E,UAAU,WAAW;AAEnB,SAAO,EAAE,UADQ,OAAO,OAAO,EAAE,EAAE,GAAG,OAAO,EAC1B;;CAErB,QAAQ;CACR,WAAW;CACZ,CAAC;;;;ACkCF,SAAgB,eAGd,YAGC;AACD,QAAO,mBAAmB,cAAc,CAACC,WAAS,CAAC;;;;;;;AA+BrD,SAAgB,qBAA4C;AAC1D,QAAO,eAAe;EACpB;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EACD,CAAC;;;;;AC1GJ,MAAaC,kBAAiD,YAAY;CACxE,UAAU,UAAsB;EAC9B,IAAI,QAAQ,WAAW,KAAe,EAAE,CAAC;EACzC,IAAI,QAAQ,WAAW,KAAe,EAAE,CAAC;EACzC,IAAIC,UAA8B;AAElC,OAAK,MAAM,QAAQ,OAAO;AACxB,WAAQ,MAAM,OAAO,KAAK,MAAM;AAChC,WAAQ,MAAM,OAAO,KAAK,SAAS,EAAE,CAAC;AACtC,aAAU,WAAW,KAAK;;AAG5B,SAAO;GAAE;GAAO;GAAO;GAAS;;CAElC,QAAQ;CACR,WAAW;CACZ,CAAC;;;;AC3BF,SAAgB,QACd,OACA,aACyB;CACzB,MAAMC,SAAkC,EAAE;AAC1C,MAAK,MAAM,QAAQ,OAAO;EACxB,MAAM,MAAM,YAAY,KAAK;AAE7B,GADgB,OAAO,SAAS,EAAE,EAC3B,KAAK,KAAK;;AAEnB,QAAO;;AAGT,SAAgB,aACd,SAC6B;CAC7B,MAAMC,SAAsC,EAAE;AAC9C,MAAK,MAAM,CAAC,KAAK,UAAU,QAEzB,EADgB,OAAO,SAAS,EAAE,EAC3B,KAAK,MAAM;AAEpB,QAAO;;;;;ACvBT,SAAgB,sBAAwC,KAAW;CACjE,MAAM,SAAS,EAAE;AACjB,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,IAAI,CAC5C,KAAI,UAAU,OACZ,QAAO,OAAO;AAGlB,QAAO;;;;;ACJT,SAAgB,aACd,GAAG,SACS;CACZ,MAAM,kBAAkB,QACrB,OAAO,aAAa,CACpB,IAAI,sBAAsB;AAC7B,QAAO,OAAO,OAAO,EAAE,EAAE,GAAG,gBAAgB;;;;;ACA9C,SAAS,WACP,GACA,GACqB;CAGrB,MAAMC,QAAoB,EAAE;CAC5B,MAAM,YAAY,IAAI,IAAI,CACxB,GAAG,OAAO,KAAK,EAAE,SAAS,EAAE,CAAC,EAC7B,GAAG,OAAO,KAAK,EAAE,SAAS,EAAE,CAAC,CAC9B,CAAC;AACF,MAAK,MAAM,QAAQ,WAAW;EAC5B,MAAM,YAAY,EAAE,QAAQ;EAC5B,MAAM,YAAY,EAAE,QAAQ;EAC5B,MAAM,iBAAiB,aAAa,WAAW,UAAU;AACzD,MAAI,eACF,OAAM,QAAQ;;CAIlB,MAAMC,WAA0B,CAAC,GAAI,EAAE,YAAY,EAAE,EAAG,GAAI,EAAE,YAAY,EAAE,CAAE;AAE9E,QAAO,aAAgB,GAAG,GAAG;EAAE;EAAO;EAAU,CAAC;;;;;ACfnD,SAAgB,oBAId,OACA,SAC2C;AAC3C,SAAQ,MAAM,GAAG,SAAS;EACxB,MAAM,MAAM,MAAM,MAAM,GAAG,KAAK;EAChC,MAAM,QAAQ,QACX,KAAK,WAAW,OAAO,QAAQ,KAAK,MAAM,OAAO,MAAM,CAAC,CACxD,OAAO,aAAa;AACvB,SAAO,sBAAsB,KAAK,MAAM;;;AAI5C,SAAgB,sBACd,MACA,SACc;CACd,MAAM,mBAAmB,KAAK;CAC9B,MAAM,gBAAgB,KAAK;AAE3B,QAAO;EACL,GAAG;EACH,WAAW,QAAQ;GACjB,MAAM,YAAY,mBAAmB,IAAI,IAAI,iBAAiB,EAAE;AAEhE,OAAI,cAAc,SAAS,CAAC,OAAO,CAAC,cAAc,IAAI,CACpD,QAAO,aAAa;GAGtB,MAAMC,gBAAyC,EAAE;AAEjD,QAAK,MAAM,UAAU,QACnB,KAAI,OAAO,SACT,eAAc,OAAO,QAAQ,OAAO,SAAS,IAAI;AAIrD,UAAO;IAAE,GAAG;IAAW,GAAG;IAAe;;EAE5C;;AAGH,SAAgB,sBACd,KACA,OACe;AACf,KAAI,CAAC,IACH,QAAO;AAGT,KAAI,MAAM,QAAQ,IAAI,EAAE;EACtB,MAAM,OAAO,IAAI,MAAM,EAAE;EACzB,IAAIC;AAEJ,MAAI,KAAK,SAAS,MAAM,KAAK,MAAM,QAAQ,OAAO,KAAK,OAAO,UAC5D,YAAW,KAAK,OAAO;MAEvB,YAAW,EAAE;EAGf,MAAM,WAAW,oBAAoB,UAAU,MAAM;AACrD,SAAO;GAAC,IAAI;GAAI;GAAU,GAAG;GAAK;;AAGpC,KAAI,cAAc,IAAI,CACpB,QAAO,qBAAqB,KAAK,MAAM;AAGzC,KAAI,OAAO,QAAQ,YAAY,SAAS,OAAO,cAAc,IAAI,IAAI,CACnE,QAAO;EAAE,GAAG;EAAK,KAAK,qBAAqB,IAAI,KAAK,MAAM;EAAE;AAG9D,QAAO;;AAGT,SAAS,oBACP,KACA,OACyB;AACzB,OAAM,EAAE,GAAG,KAAK;AAChB,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO;EAChC,MAAM,WAAW,IAAI;AAIrB,MAAI,OAHa,QAAQ,UACrB,WAAW,OAAO,OAAO,aAAa,WAAW,WAAW,GAAG,GAC/D;;AAGN,QAAO;;AAGT,SAAS,qBACP,SACA,OACS;AACT,WAAU,QAAQ,UAAU,KAAK;AACjC,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO;EAChC,MAAM,WAAW,QAAQ,aAAa,IAAI;EAC1C,MAAM,WAAW,QAAQ,UACrB,WAAW,OAAO,OAAO,aAAa,WAAW,WAAW,GAAG,GAC/D;AACJ,UAAQ,aAAa,KAAK,SAAS;;AAErC,QAAO;;AAGT,SAAS,WAAW,GAAG,QAAkB;AACvC,QAAO,OACJ,KAAK,UAAU,MAAM,MAAM,CAAC,QAAQ,MAAM,GAAG,CAAC,CAC9C,OAAO,QAAQ,CACf,KAAK,KAAK;;;;;;;;;;AC7Bf,SAAgB,eAId,SAGC;AAED,QAAO,mBAAmB,eAAe,CADR,CAAC,SAAS,OAAU,CACH,CAAC;;;;;;;AAUrD,SAAgB,eAKd,SAGC;AAED,QAAO,mBAAmB,eAAe,CADR,CAAC,QAAW,QAAQ,CACH,CAAC;;AAUrD,MAAM,gBAAgB,YAAyC;CAC7D,UAAU,aAA4C;EACpD,IAAI,QAAQ,WAAW,KAAe,EAAE,CAAC;EACzC,IAAIC,cAAkC;EAEtC,MAAM,eAAe,SAAS,KAAK,UAAU,MAAM,GAAG,CAAC,OAAO,aAAa;EAC3E,MAAM,eAAe,SAAS,KAAK,UAAU,MAAM,GAAG,CAAC,OAAO,aAAa;AAE3E,OAAK,MAAM,EAAE,MAAM,QAAS,GAAG,UAAU,cAAc;AACrD,OAAI,QACF,eAAc;GAGhB,MAAM,WAAW,MAAM,IAAI,KAAK;AAChC,OAAI,SACF,SAAQ,MAAM,OAAO,MAAM,WAAW,UAAU,KAAK,CAAC;OAItD,SAAQ,MAAM,WAAW,MAAM,KAAK;;EAIxC,MAAM,eAAe,QAAQ,eAAe,YAAY,QAAQ,KAAK;AAErE,OAAK,MAAM,CAAC,MAAM,UAAU,OAAO,QAAQ,aAAa,EAAE;AACxD,OAAI,CAAC,MAAO;GAEZ,MAAM,YAAY,MAAM,IAAI,KAAK;AACjC,UAAO,WAAW,aAAa,KAAK,kBAAkB;GAEtD,MAAM,OAAO,MAAM,UAAU;AAE7B,OAAI,CAAC,KAAK,MACR,MAAK,QAAQ,EAAE;AAGjB,QAAK,MAAM,QAAQ,MACjB,MAAK,MAAM,KAAK,QAAQ;IACtB,SAAS,KAAK;IACd,UAAU,KAAK;IACf,YAAY,KAAK;IAClB;AAGH,OAAI,KAAK,MACP,MAAK,QAAQ,oBAAoB,KAAK,OAAO,MAAM;AAGrD,OAAI,KAAK,SACP,MAAK,WAAW,KAAK,SAAS,KAAK,SAAS,sBAAsB,MAAM,MAAM,CAAC;AAGjF,WAAQ,MAAM,OAAO,MAAM,KAAK;;AAGlC,SAAO;GAAE,OAAO;GAAO,SAAS;GAAa;;CAE/C,QAAQ;CACR,WAAW;CACZ,CAAC;;;;;;;;;;;;;AClLF,SAAgB,YAA0B;AACxC,SAAQ,KACN,qKACD;AAED,QAAO,eAAe;EACpB,MAAM;EACN,SAAS;EACT,SAAS;EACV,CAAC;;;;;;;;;;ACiBJ,SAAgB,mBAAmB,SAAuC;AACxE,QAAO,6BAA6B,CAAC,SAAS,QAAQ,CAAC;;;;;;;AAQzD,SAAgB,oBAAoB,SAAwC;AAC1E,QAAO,6BAA6B,CAAC,UAAU,QAAQ,CAAC;;;;;;;AAQ1D,SAAgB,qBAAqB,SAAyC;AAC5E,QAAO,6BAA6B,CAAC,WAAW,QAAQ,CAAC;;AAG3D,SAAS,6BACP,OACgB;AAChB,QAAO,mBAAmB,iBAAiB,CAAC,MAAM,CAAC;;AAQrD,MAAM,kBAAkB,YAAkD;CACxE,cAAc;EACZ,IAAIC,gBAAgC,EAAE;EACtC,IAAIC,iBAAkC,EAAE;EACxC,IAAIC,kBAAoC,EAAE;EAE1C,MAAM,SAAS,IAAI,kBAAkB;GACnC,KAAK;GACL,OAAO,SAAS;AAEd,kBAAc,SAAS,OAAO,GAAG,KAAK,CAAC;AAEvC,WAAO;KACL,SAAS,QAAM,cAAc;AAC3B,qBAAe,SAAS,OAAO,GAAGC,QAAM,UAAU,CAAC;;KAErD,eAAe;AACb,sBAAgB,SAAS,OAAO,IAAI,CAAC;;KAExC;;GAEJ,CAAC;EAEF,MAAM,YAAY,UAAmC;AACnD,mBAAgB,EAAE;AAClB,oBAAiB,EAAE;AACnB,qBAAkB,EAAE;AAEpB,QAAK,MAAM,QAAQ,MACjB,SAAQ,KAAK,IAAb;IACE,KAAK;AACH,mBAAc,KAAK,KAAK,GAAG;AAC3B;IACF,KAAK;AACH,oBAAe,KAAK,KAAK,GAAG;AAC5B;IACF,KAAK;AACH,qBAAgB,KAAK,KAAK,GAAG;AAC7B;;;AAKR,SAAO,SAAS,QAAQ,OAAgC;AACtD,YAAS,MAAM;AACf,UAAO;;;CAGX,QAAQ;CACR,WAAW;CACZ,CAAC;AAEF,MAAM,YAAY,IAAI,UAAU,+BAA+B;;;;;;;;;AC1G/D,SAAgB,uBACd,SACgB;AAChB,QAAO,qBAAqB,MAAM,cAAc;AAC9C,MAAI,CAAC,KAAK,MAAM,IAAI,GAAG,UAAU,IAAI,CACnC,SAAQ,MAAM,UAAU;GAE1B;;;;;AC9BJ,SAAgB,uBAMd;CACA,IAAIC,WAAsB,EAAE;CAE5B,SAAS,YAAY,eAAgC;AAEnD,aAAW,WAAW,cAAc;;CAGtC,SAAS,qBAAqB,GAAG,MAAqB;AACpD,OAAK,MAAM,WAAW,SACpB,KAAI,QAAQ,GAAG,KAAK,CAClB,QAAO;AAGX,SAAO;;AAGT,QAAO,CAAC,aAAa,qBAAqB;;;;;;;;ACc5C,SAAgB,2BACd,GAAG,UACa;AAChB,QAAO,mBACL,eACA,SACD;;;;;;;AAQH,SAAgB,sBACd,OACA,SACgB;AAChB,QAAO,2BAA2B,CAChC,OACA,QACD,CAAC;;;;;AAWJ,MAAMC,gBAAuD,YAC3D;CACE,cAAc;EACZ,MAAMC,iBAA4D,EAAE;EACpE,MAAMC,qBAAsD,EAAE;EAE9D,IAAIC;EAEJ,MAAM,UAAU,aAAsC;GACpD,IAAI,cAAc;AAElB,QAAK,MAAM,CAAC,UAAU,SACpB,KAAI,CAAC,eAAe,QAAQ;AAC1B,kBAAc;IACd,MAAM,CAAC,aAAa,mBAAmB,sBAAuC;AAC9E,mBAAe,SAAS;IACxB,MAAMC,KAAsB,MAAM,gBAAgB;AAChD,YAAO,gBAAgB,MAAM,YAAY;;AAE3C,uBAAmB,SAAS;;GAIhC,MAAMC,MAAqD,aAA0B,SAAS;AAC9F,QAAK,MAAM,CAAC,OAAO,gBAAgB,OAAO,QAAQ,eAAe,EAAE;IACjE,MAAM,WAAW,IAAI,UAAU,EAAE;AACjC,gBAAY,SAAS;;AAGvB,OAAI,YACF,UAAS,IAAI,kBAAkB;IAC7B,KAAK,IAAI,UAAU,6BAA6B;IAChD,OAAO,EAAE,iBAAiB,oBAAoB;IAC/C,CAAC;;AAIN,SAAO,SAAS,QAAQ,QAAQ;AAC9B,UAAO,OAAO;AACd,UAAO,UAAU,EAAE;;;CAGvB,QAAQ;CACR,WAAW;CACZ,CACF;;;;AC1BD,SAAS,wBAAwB,SAA6C;AAC5E,QAAO,mBAAmB,kBAAkB,CAAC,QAAQ,CAAC;;;;;;;AAQxD,SAAgB,qBAAqB,SAAyC;AAC5E,QAAO,wBAAwB,CAAC,WAAW,QAAQ,CAAC;;;;;;;AAOtD,SAAgB,sBACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,YAAY,QAAQ,CAAC;;;;;;;AAOvD,SAAgB,uBACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,aAAa,QAAQ,CAAC;;;;;;;AAOxD,SAAgB,qBAAqB,SAAyC;AAC5E,QAAO,wBAAwB,CAAC,WAAW,QAAQ,CAAC;;;;;;;AAOtD,SAAgB,mBAAmB,SAAuC;AACxE,QAAO,wBAAwB,CAAC,SAAS,QAAQ,CAAC;;;;;;;AAOpD,SAAgB,2BACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,iBAAiB,QAAQ,CAAC;;;;;;;AAO5D,SAAgB,yBACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,eAAe,QAAQ,CAAC;;;;;;;AAO1D,SAAgB,2BACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,iBAAiB,QAAQ,CAAC;;;;;;;AAO5D,SAAgB,yBACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,eAAe,QAAQ,CAAC;;;;;;;AAO1D,SAAgB,mBAAmB,SAAuC;AACxE,QAAO,wBAAwB,CAAC,SAAS,QAAQ,CAAC;;;;;;;AAOpD,SAAgB,kBAAkB,SAAsC;AACtE,QAAO,wBAAwB,CAAC,QAAQ,QAAQ,CAAC;;;;;;;AAOnD,SAAgB,+BACd,SACgB;AAChB,QAAO,wBAAwB,CAAC,qBAAqB,QAAQ,CAAC;;;;;AA0BhE,MAAaC,mBAA6D,YAA+C;CACvH,cAAc;EACZ,MAAM,CAAC,QAAQ,UAAU,wBAAwB;AAEjD,UAAQ,YAAY;AAClB,UAAO,QAAQ;AACf,UAAO;;;CAGX,QAAQ;CACR,WAAW;CACZ,CAAC;AAGF,SAAS,yBAAyB;CAChC,MAAM,CAAC,oBAAoB,iBAAiB,sBAAsC;CAClF,MAAM,CAAC,qBAAqB,kBAAkB,sBAAuC;CACrF,MAAM,CAAC,sBAAsB,mBAAmB,sBAAwC;CACxF,MAAM,CAAC,oBAAoB,iBAAiB,sBAAsC;CAClF,MAAM,CAAC,kBAAkB,eAAe,sBAAoC;CAC5E,MAAM,CAAC,0BAA0B,uBAAuB,sBAA4C;CACpG,MAAM,CAAC,wBAAwB,qBAAqB,sBAA0C;CAC9F,MAAM,CAAC,0BAA0B,uBAAuB,sBAA4C;CACpG,MAAM,CAAC,wBAAwB,qBAAqB,sBAA0C;CAC9F,MAAM,CAAC,kBAAkB,eAAe,sBAAoC;CAC5E,MAAM,CAAC,iBAAiB,cAAc,sBAAmC;CACzE,MAAM,CAAC,8BAA8B,2BAA2B,sBAAgD;CAEhH,MAAM,UAAU,YAAkC;EAChD,MAAM,MAAM,aAA6B,QAAQ;AAEjD,qBAAmB,IAAI,WAAW,EAAE,CAAC;AACrC,sBAAoB,IAAI,YAAY,EAAE,CAAC;AACvC,uBAAqB,IAAI,aAAa,EAAE,CAAC;AACzC,qBAAmB,IAAI,WAAW,EAAE,CAAC;AACrC,mBAAiB,IAAI,SAAS,EAAE,CAAC;AACjC,2BAAyB,IAAI,iBAAiB,EAAE,CAAC;AACjD,yBAAuB,IAAI,eAAe,EAAE,CAAC;AAC7C,2BAAyB,IAAI,iBAAiB,EAAE,CAAC;AACjD,yBAAuB,IAAI,eAAe,EAAE,CAAC;AAC7C,mBAAiB,IAAI,SAAS,EAAE,CAAC;AACjC,kBAAgB,IAAI,QAAQ,EAAE,CAAC;AAC/B,+BAA6B,IAAI,qBAAqB,EAAE,CAAC;;CAG3D,MAAM,SAAS,IAAI,kBAAkB;EACnC,KAAK,IAAI,UAAU,wBAAwB;EAC3C,OAAO;GACL;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACD;EACF,CAAC;AAEF,QAAO,CAAC,QAAQ,OAAO;;;;;;;;;;ACjRzB,SAAgB,yBACd,SACgB;CAChB,MAAM,oBAAoB,QAAQ,KAAK;CACvC,MAAM,mBAAmB,QAAQ,MAAM;AACvC,QAAO,2BACL,CAAC,SAAS,YAAY,EACtB,CAAC,QAAQ,WAAW,CACrB;;;;;;;;ACvBH,MAAaC,UAAmB,OAAO,cAAc,cACjD,qBAAqB,KAAK,UAAU,SAAS,GAC7C;;;;;;;AC4BJ,SAAgB,aAAa,UAAgC;AAC3D,QAAO,mBAAmB,aAAa,CAACC,SAAO,CAAC;;;;;AAWlD,MAAaC,cAAmD,YAG9D;CACA,cAAc;EAGZ,IAAIC;EAEJ,MAAMC,kBAA2B,MAAM,UAAU;AAC/C,OAAI,QAAS,QAAO,QAAQ,MAAM,MAAM;AACxC,UAAO;;EAGT,MAAM,SAAS,IAAI,OAAO;GACxB,KAAK;GACL,OAAO,EAAE,eAAe,gBAAgB;GACzC,CAAC;AAEF,UAAQ,YAAsB;AAC5B,aAAU,eACR,aAEE,WAAW,QAAQ,CACpB,CACF;AACD,UAAO;;;CAGX,QAAQ;CACR,WAAW;CACZ,CAAC;AAEF,SAAS,aAAa,SAA2B;CAC/C,MAAMC,WAAsC,EAAE;AAE9C,MAAK,MAAMJ,YAAU,QACnB,MAAK,MAAM,CAAC,KAAK,YAAY,OAAO,QAAQA,SAAO,CAEjD,EADiB,SAAS,SAAS,SAAS,OAAO,EAAE,GAC5C,KAAK,QAAQ;AAI1B,QAAO,UAAU,UAAU,cAAc;;AAG3C,SAAS,cAAc,YAA8B;AACnD,QAAO,cAAc,GAAGK,WAAS;;AAGnC,MAAM,kBAAkB,IAAI,UAAU,kBAAkB;;;;AC9ExD,MAAMC,SAAiB;CACrB,SAAS;CACT,eAAe;CAChB;AAED,IAAI,CAAC,QACH,QAAO,WAAW;AAGpB,MAAM,WAAW;CACf,YAAY;CACZ,YAAY;CACb;;;;;;;;AA0CD,SAAgB,cAAc,EAC5B,QAAQ,KACR,gBAAgB,QACE,EAAE,EAAoB;AACxC,QAAO,MACL,aAAa,QAAQ;EAAE;EAAO;EAAe,CAAC,CAAC,EAC/C,aAAa,OAAO,EACpB,eAAe,SAAS,CACzB;;;;;AC5DH,MAAM,cAAc,cAClB,eACA,qBACA,gBACA,qBACD;AAGD,MAAM,kBAAkB,cACtB,iBACA,uBACA,mBACD;AAED,MAAM,mBAAmB;CACvB,GAAG;CACH,OAAO;CACP,WAAW;CACZ;;;;;;AAYD,SAAgB,iBAAiB,SAOT;CACtB,MAAM,WAAW,SAAS,YAAY,SAAS;AAC/C,QAAO,aAAa,aAAa,iBAAiB,EAAE,SAAS;;;;;;;;ACsB/D,SAAgB,eAId,SAGC;AAED,QAAO,mBAAmB,eAAe,CADR,CAAC,SAAS,OAAU,CACH,CAAC;;;;;AAQrD,SAAgB,eAKd,SAGC;AAED,QAAO,mBAAmB,eAAe,CADR,CAAC,QAAW,QAAQ,CACH,CAAC;;AAUrD,MAAM,gBAAgB,YAAyC;CAC7D,UAAU,aAA4C;EACpD,IAAI,QAAQ,WAAW,KAAe,EAAE,CAAC;EAEzC,MAAM,eAAe,SAAS,KAAK,UAAU,MAAM,GAAG,CAAC,OAAO,aAAa;EAC3E,MAAM,eAAe,SAAS,KAAK,UAAU,MAAM,GAAG,CAAC,OAAO,aAAa;AAE3E,OAAK,MAAM,EAAE,KAAM,GAAG,UAAU,cAAc;GAC5C,MAAM,WAAW,MAAM,IAAI,KAAK;AAChC,OAAI,SACF,SAAQ,MAAM,OAAO,MAAM,WAAW,UAAU,KAAK,CAAC;OAItD,SAAQ,MAAM,WAAW,MAAM,KAAK;;EAIxC,MAAM,eAAe,QAAQ,eAAe,YAAY,QAAQ,KAAK;AAErE,OAAK,MAAM,CAAC,MAAM,UAAU,OAAO,QAAQ,aAAa,EAAE;AACxD,OAAI,CAAC,MAAO;GAEZ,MAAM,YAAY,MAAM,IAAI,KAAK;AACjC,UAAO,WAAW,aAAa,KAAK,kBAAkB;GACtD,MAAM,OAAO,MAAM,UAAU;AAE7B,OAAI,CAAC,KAAK,MACR,MAAK,QAAQ,EAAE;AAGjB,QAAK,MAAM,QAAQ,MACjB,MAAK,MAAM,KAAK,QAAQ;IACtB,SAAS,KAAK;IACd,UAAU,KAAK;IAChB;AAGH,OAAI,KAAK,MACP,MAAK,QAAQ,oBAAoB,KAAK,OAAO,MAAM;AAGrD,OAAI,KAAK,SACP,MAAK,WAAW,KAAK,SAAS,KAAK,SAAS,mBAAmB,MAAM,MAAM,CAAC;AAG9E,WAAQ,MAAM,OAAO,MAAM,KAAK;;AAGlC,SAAO;GAAE,OAAO;GAAO,OAAO,EAAE;GAAE;;CAEpC,QAAQ;CACR,WAAW;CACZ,CAAC;AAEF,SAAS,mBACP,MACA,OACW;AACX,KAAI,KAAK,IACP,QAAO,sBAAsB,MAAM,MAAM;AAE3C,QAAO;;;;;AC/JT,SAAgB,eAAe,SAAqC;AAClE,QAAO,mBAAmB,eAAe,CAAC,QAAQ,CAAC;;AAGrD,MAAM,gBAAgB,YAA4C;CAChE,UAAU,WAA6C;EACrD,MAAMC,YAAyD,EAAE;AAEjE,OAAK,MAAM,SAAS,OAClB,KAAI,CAAC,UAAU,MAAM,MACnB,WAAU,MAAM,QAAQ,MAAM;AAIlC,eAAa,CACX,IAAI,kBAAkB;GACpB,KAAK,IAAI,UAAU,qBAAqB;GACxC,OAAO,EAAE,WAAW;GACrB,CAAC,CACH;;CAEH,QAAQ;CACT,CAAC;;;;;;;ACDF,SAAgB,sBACd,SACW;AAEX,QAAO,mBAAmB,sBAAsB,CADZ,CAAC,SAAS,KAAK,CACI,CAAC;;;;;AAM1D,SAAgB,wBACd,SACW;AAEX,QAAO,mBAAmB,sBAAsB,CADZ,CAAC,MAAM,QAAQ,CACI,CAAC;;AAG1D,MAAMC,aAAW,OAAO,WAAW;AAEnC,MAAM,uBAAuB,YAAiD;CAC5E,UAAU,WAAkD;AAE1D,MAAIA,WAAU,QAAO,EAAE;EAEvB,MAAMC,YAAyD,EAAE;EAEjE,MAAM,YAAY,OAAO,KAAK,MAAM,EAAE,GAAG,CAAC,OAAO,aAAa;EAC9D,MAAM,UAAU,OAAO,KAAK,MAAM,EAAE,GAAG,CAAC,OAAO,aAAa;AAE5D,OAAK,MAAM,EAAE,OAAO,MAAM,UAAU,SAAS;GAC3C,MAAM,UAAU,UAAU,MAAM,cAAYC,UAAQ,UAAU,MAAM;AACpE,OAAI,CAAC,QAAS;AACd,aAAU,QAAQ,QAAQ,QAAQ,KAAK;;AAGzC,eAAa,CACX,IAAI,kBAAkB;GACpB,KAAK,IAAI,UAAU,4BAA4B;GAC/C,OAAO,EAAE,WAAW;GACrB,CAAC,CACH;;CAEH,QAAQ;CACT,CAAC;;;;AChEF,SAAgB,eAAe,SAAqC;AAClE,QAAO,mBAAmB,eAAe,CAAC,QAAQ,CAAC;;AAGrD,MAAM,gBAAgB,YAA4C;CAChE,UAAU,WAA6C;EACrD,MAAMC,YAAyD,EAAE;AAEjE,OAAK,MAAM,SAAS,OAClB,KAAI,CAAC,UAAU,MAAM,MACnB,WAAU,MAAM,QAAQ,MAAM;AAIlC,eAAa,CACX,IAAI,kBAAkB;GACpB,KAAK,IAAI,UAAU,qBAAqB;GACxC,OAAO,EAAE,WAAW;GACrB,CAAC,CACH;;CAEH,QAAQ;CACT,CAAC;;;;;;;ACDF,SAAgB,sBACd,SACW;AAEX,QAAO,mBAAmB,sBAAsB,CADZ,CAAC,SAAS,KAAK,CACI,CAAC;;;;;AAM1D,SAAgB,wBACd,SACW;AAEX,QAAO,mBAAmB,sBAAsB,CADZ,CAAC,MAAM,QAAQ,CACI,CAAC;;AAG1D,MAAM,WAAW,OAAO,WAAW;AAEnC,MAAM,uBAAuB,YAAiD;CAC5E,UAAU,WAAkD;AAE1D,MAAI,SAAU,QAAO,EAAE;EAEvB,MAAMC,YAAyD,EAAE;EAEjE,MAAM,YAAY,OAAO,KAAK,MAAM,EAAE,GAAG,CAAC,OAAO,aAAa;EAC9D,MAAM,UAAU,OAAO,KAAK,MAAM,EAAE,GAAG,CAAC,OAAO,aAAa;AAE5D,OAAK,MAAM,EAAE,OAAO,MAAM,UAAU,SAAS;GAC3C,MAAM,UAAU,UAAU,MAAM,cAAYC,UAAQ,UAAU,MAAM;AACpE,OAAI,CAAC,QAAS;AACd,aAAU,QAAQ,QAAQ,QAAQ,KAAK;;AAGzC,eAAa,CACX,IAAI,kBAAkB;GACpB,KAAK,IAAI,UAAU,4BAA4B;GAC/C,OAAO,EAAE,WAAW;GACrB,CAAC,CACH;;CAEH,QAAQ;CACT,CAAC;;;;;;;AChEF,SAAS,sBAA8C;AACrD,QAAO,eAAe;EACpB,MAAM;EACN,SAAS;EACT,OAAO;EACP,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;EACxB,QAAQ;AACN,UAAO,CAAC,KAAK,EAAE;;EAElB,CAAC;;;;;;;;;;;;;AAyBJ,SAAgB,kBAAsC;AACpD,SAAQ,KACN,uLACD;AAED,QAAO,aAAa,qBAAqB,EAAE,SAAS,QAAQ;;;;;;;;;;;;;;ACnC9D,SAAgB,aAA4B;AAC1C,SAAQ,KACN,wKACD;AAED,QAAO,eAAe;EACpB,MAAM;EACN,OAAO;EACR,CAAC;;;;;;;;AC3BJ,MAAaC,wBAAuC,WAAW;AAC7D,KAAI;AACF,SAAO,KAAK,QAAQ,IAAI,OAAO,WAAW,IAAI,EAAE,IAAI,KAAK;SACnD;AACN,SAAO;;EAET;;;;;;;;;;;ACFF,MAAaC,OAEC;;;;;;;;;;;ACCd,SAAgB,gBACd,QACmB;CACnB,MAAMC,WAA8B,EAAE;AACtC,MAAK,IAAI,IAAI,GAAG,IAAI,OAAO,YAAY,IACrC,UAAS,KAAK,OAAO,MAAM,EAAE,CAAC;AAEhC,QAAO;;;;;;;;;;;;ACET,SAAgB,aAAa,SAAyC;AACpE,KAAI,MAAM,QAAQ,QAAQ,CACxB,QAAO,QAAQ,QAAQ,aAAa;AAEtC,KAAI,mBAAmB,gBACrB,QAAO,CAAC,QAAQ;AAElB,KAAI,mBAAmB,qBAAqB;EAC1C,MAAMC,QAA2B,EAAE;AACnC,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,YAAY,IACtC,OAAM,KAAK,QAAQ,MAAM,EAAE,CAAC;AAE9B,SAAO;;AAET,OAAM,IAAI,cAAc,yBAAyB,OAAO,UAAU;;;;;;;;AC9BpE,SAAgB,mBACd,KACA,MACA,IACS;CACT,IAAI,QAAQ;AACZ,KAAI,aAAa,MAAM,KAAK,SAAS;AACnC,MAAI,MAAO,QAAO;AAClB,MAAI,KAAK,SAAU,SAAQ;GAC3B;AACF,QAAO;;;;;ACfT,IAAI,KAAK;;;;;;;;AAST,SAAgB,QAAgB;AAC9B,OAAM,KAAK,KAAK,OAAO;AACvB,QAAO,MAAM;;;;;;;;;;ACCf,SAAgB,eACd,OACA,MACoB;CAEpB,MAAM,EAAE,YAAY,MAAM;AAC1B,KACE,CAAC,YACG,OAAO,CAAC,KAAK,eAAe,YAAY,MAAM,GAAG,QAAQ,eAAe,GAE5E,QAAO;AAET,QAAO;;;;;ACrBT,SAAS,gBAAgB,MAAyB;AAChD,QAAO,CAAC,EAAE,KAAK,KAAK,QAAQ,KAAK;;;;;;;AAQnC,SAAgB,cAAc,WAA+B;AAC3D,QACE,gBAAgB,UAAU,MAAM,OAAO,KAAK,IACzC,gBAAgB,UAAU,IAAI,OAAO,KAAK;;;;;;;;ACZjD,SAAgB,SAGd,OAA2C,GAAG,MAAmB;AACjE,QAAO,OAAO,UAAU,aACnB,MAAmC,GAAG,KAAK,GAC5C;;;;;;;;ACNN,MAAa,+BAA+B;;;;;;;ACI5C,SAAgB,kBAAkB,SAA2B;AAC3D,SAAQ,OAAO,UAAU,SAAS;AAChC,MAAI,cAAc,MAAM,UAAU,CAChC,QAAO;AAET,SAAO,QAAQ,OAAO,UAAU,KAAK"}