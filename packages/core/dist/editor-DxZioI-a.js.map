{"version":3,"file":"editor-DxZioI-a.js","names":[],"sources":["../src/error.ts","../src/utils/get-mark-type.ts","../src/utils/assert.ts","../src/utils/get-node-type.ts","../src/utils/type-assertion.ts","../src/utils/attrs-match.ts","../src/utils/is-node-active.ts","../src/types/priority.ts","../src/facets/facet.ts","../src/facets/root.ts","../src/facets/schema.ts","../src/facets/base-extension.ts","../src/utils/array.ts","../src/facets/facet-node.ts","../src/facets/facet-extension.ts","../src/facets/state.ts","../src/utils/get-dom-api.ts","../src/utils/parse.ts","../src/utils/editor-content.ts","../src/extensions/default-state.ts","../src/utils/is-subset.ts","../src/utils/includes-mark.ts","../src/utils/is-mark-absent.ts","../src/utils/is-mark-active.ts","../src/editor/action.ts","../src/facets/union-extension.ts","../src/editor/union.ts","../src/editor/editor.ts"],"sourcesContent":["/**\n * Base class for all ProseKit errors.\n *\n * @internal\n */\nexport class ProseKitError extends Error {\n  constructor(message?: string, options?: ErrorOptions) {\n    if (typeof message === 'string' && !message.startsWith('[')) {\n      message = `[prosekit] ${message}`\n    }\n    super(message, options)\n  }\n}\n\n/**\n * @internal\n */\nexport class EditorNotFoundError extends ProseKitError {\n  constructor() {\n    super(\n      'Unable to find editor. Pass it as an argument or call this function inside a ProseKit component.',\n    )\n  }\n}\n\n/**\n * @internal\n */\nexport class DOMDocumentNotFoundError extends ProseKitError {\n  constructor() {\n    super(\n      'Unable to find browser Document. When not in the browser environment, you need to pass a DOM Document.',\n    )\n  }\n}\n","import type { MarkType, Schema } from '@prosekit/pm/model'\n\nimport { ProseKitError } from '../error.ts'\n\n/**\n * @internal\n */\nexport function getMarkType(schema: Schema, type: string | MarkType): MarkType {\n  if (typeof type === 'string') {\n    const markType = schema.marks[type]\n    if (!markType) {\n      throw new ProseKitError(`Cannot find mark type \"${type}\"`)\n    }\n    return markType\n  }\n  return type\n}\n","import { ProseKitError } from '../error.ts'\n\n/**\n * @internal\n */\nexport function assert(\n  condition: unknown,\n  message = 'Assertion failed',\n): asserts condition {\n  if (!condition) {\n    throw new ProseKitError(message)\n  }\n}\n","import type { NodeType, Schema } from '@prosekit/pm/model'\n\nimport { ProseKitError } from '../error.ts'\n\n/**\n * @internal\n */\nexport function getNodeType(schema: Schema, type: string | NodeType): NodeType {\n  if (typeof type === 'string') {\n    const nodeType = schema.nodes[type]\n    if (!nodeType) {\n      throw new ProseKitError(`Cannot find ProseMirror node type \"${type}\"`)\n    }\n    return nodeType\n  }\n  return type\n}\n","import { Fragment, Mark, ProseMirrorNode, Slice } from '@prosekit/pm/model'\nimport { AllSelection, NodeSelection, Selection, TextSelection } from '@prosekit/pm/state'\n\n/**\n * Checks if the given object is a {@link ProseMirrorNode} instance.\n */\nexport function isProseMirrorNode(value: unknown): value is ProseMirrorNode {\n  return value instanceof ProseMirrorNode\n}\n\n/**\n * Checks if the given object is a {@link Mark} instance.\n *\n * @public\n */\nexport function isMark(value: unknown): value is Mark {\n  return value instanceof Mark\n}\n\n/**\n * Checks if the given object is a {@link Fragment} instance.\n *\n * @public\n */\nexport function isFragment(value: unknown): value is Fragment {\n  return value instanceof Fragment\n}\n\n/**\n * Checks if the given object is a {@link Slice} instance.\n *\n * @public\n */\nexport function isSlice(value: unknown): value is Slice {\n  return value instanceof Slice\n}\n\n/**\n * Checks if the given object is a {@link Selection} instance.\n *\n * @public\n */\nexport function isSelection(value: unknown): value is Selection {\n  return value instanceof Selection\n}\n\n/**\n * Checks if the given object is a {@link TextSelection} instance.\n *\n * @public\n */\nexport function isTextSelection(value: Selection): value is TextSelection {\n  return value instanceof TextSelection\n}\n\n/**\n * Checks if the given object is a {@link NodeSelection} instance.\n *\n * @public\n */\nexport function isNodeSelection(value: Selection): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n\n/**\n * Checks if the given object is a {@link AllSelection} instance.\n *\n * @public\n */\nexport function isAllSelection(value: Selection): value is AllSelection {\n  return value instanceof AllSelection\n}\n","import type { Attrs, Mark, ProseMirrorNode } from '@prosekit/pm/model'\n\nexport function attrsMatch(\n  nodeOrMark: ProseMirrorNode | Mark,\n  attrs: Attrs,\n): boolean {\n  const currentAttrs = nodeOrMark.attrs\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (currentAttrs[key] !== value) {\n      return false\n    }\n  }\n\n  return true\n}\n","import type { Attrs, NodeType, ProseMirrorNode } from '@prosekit/pm/model'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport { attrsMatch } from './attrs-match.ts'\nimport { getNodeType } from './get-node-type.ts'\nimport { isNodeSelection } from './type-assertion.ts'\n\n/**\n * @internal\n */\nexport function isNodeActive(\n  state: EditorState,\n  type: string | NodeType,\n  attrs?: Attrs | null,\n): boolean {\n  const { selection, schema } = state\n  const $pos = selection.$from\n  const nodeType = getNodeType(schema, type)\n\n  if (isNodeSelection(selection) && checkNode(selection.node, nodeType, attrs)) {\n    return true\n  }\n\n  for (let depth = $pos.depth; depth >= 0; depth--) {\n    if (checkNode($pos.node(depth), nodeType, attrs)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkNode(node: ProseMirrorNode, nodeType: NodeType, attrs?: Attrs | null): boolean {\n  return node.type === nodeType && (!attrs || attrsMatch(node, attrs))\n}\n","/**\n * ProseKit extension priority.\n *\n * @public\n */\nexport enum Priority {\n  lowest = 0,\n  low = 1,\n  default = 2,\n  high = 3,\n  highest = 4,\n}\n","import { assert } from '../utils/assert.ts'\n\nimport type { FacetReducer } from './facet-types.ts'\n\nlet facetCount = 0\n\n/**\n * @internal\n */\nexport class Facet<Input, Output> {\n  /**\n   * @internal\n   */\n  readonly index: number = facetCount++\n  /**\n   * @internal\n   */\n  readonly parent: Facet<Output, any> | null\n  /**\n   * @internal\n   */\n  readonly singleton: boolean\n  /**\n   * A index path to retrieve the current facet in a tree from the root.\n   *\n   * @internal\n   */\n  readonly path: number[]\n\n  /**\n   * @internal\n   */\n  constructor(\n    parent: Facet<Output, any> | null,\n    singleton: boolean,\n    private _reducer?: FacetReducer<Input, Output> | undefined,\n    private _reduce?: () => FacetReducer<Input, Output>,\n  ) {\n    // Only one of _reducer or _reduce can be defined\n    assert((_reduce || _reducer) && !(_reduce && _reducer))\n\n    this.parent = parent\n    this.singleton = singleton\n    this.path = parent ? [...parent.path, this.index] : []\n  }\n\n  get reducer(): FacetReducer<Input, Output> {\n    return (this._reducer ?? this._reduce?.())!\n  }\n}\n\n/**\n * @internal\n */\nexport function defineFacet<Input, Output>(options: {\n  /**\n   * The parent facet in the tree.\n   */\n  parent: Facet<Output, any>\n\n  /**\n   * Set this to true if you only want to keep one facet payload. For example,\n   * this facet corresponds to a ProseMirror plugin with a key.\n   */\n  singleton?: boolean\n\n  /**\n   * A reducer is a function that accepts an array of input and produce a single\n   * output.\n   */\n  reducer?: FacetReducer<Input, Output>\n  /**\n   * A callback function that returns a reducer. This is useful if you want to\n   * store something in the closure.\n   */\n  reduce?: () => FacetReducer<Input, Output>\n}): Facet<Input, Output> {\n  return new Facet(\n    options.parent,\n    options.singleton ?? false,\n    options.reducer,\n    options.reduce,\n  )\n}\n","import type { Schema } from '@prosekit/pm/model'\nimport type { EditorStateConfig } from '@prosekit/pm/state'\nimport type { DirectEditorProps } from '@prosekit/pm/view'\n\nimport type { CommandCreators } from '../types/extension-command.ts'\n\nimport { Facet } from './facet.ts'\n\nexport type RootPayload = {\n  schema?: Schema | null\n  commands?: CommandCreators\n  state?: (ctx: { schema: Schema }) => EditorStateConfig\n  view?: Omit<DirectEditorProps, 'state'>\n}\n\nexport type RootOutput = {\n  schema?: Schema | null\n  commands?: CommandCreators\n  state?: EditorStateConfig\n  view?: Omit<DirectEditorProps, 'state'>\n}\n\nfunction rootReducer(inputs: RootPayload[]): RootOutput {\n  let schema: Schema | undefined\n  let commands: CommandCreators | undefined\n  let stateFunc: ((ctx: { schema: Schema }) => EditorStateConfig) | undefined\n  let view: Omit<DirectEditorProps, 'state'> | undefined\n\n  for (const input of inputs) {\n    schema = input.schema || schema\n    commands = input.commands || commands\n    stateFunc = input.state || stateFunc\n    view = input.view || view\n  }\n\n  const state = schema && (stateFunc?.({ schema }) ?? { schema })\n\n  return { schema, state, commands, view }\n}\n\nexport const rootFacet: Facet<RootPayload, RootOutput> = new Facet<\n  RootPayload,\n  RootOutput\n>(null, true, rootReducer)\n","import { Schema, type SchemaSpec } from '@prosekit/pm/model'\n\nimport { assert } from '../utils/assert.ts'\n\nimport { defineFacet, type Facet } from './facet.ts'\nimport { rootFacet, type RootPayload } from './root.ts'\n\nexport const schemaFacet: Facet<SchemaSpec, RootPayload> = defineFacet({\n  reducer: (specs) => {\n    assert(specs.length <= 1)\n    const spec = specs[0]\n    const schema = spec ? new Schema(spec) : null\n    return { schema }\n  },\n  parent: rootFacet,\n  singleton: true,\n})\n","import type { Schema } from '@prosekit/pm/model'\n\nimport type { Extension, ExtensionTyping } from '../types/extension.ts'\nimport { Priority } from '../types/priority.ts'\n\nimport type { FacetNode } from './facet-node.ts'\nimport type { Tuple5 } from './facet-types.ts'\nimport type { Facet } from './facet.ts'\nimport { schemaFacet } from './schema.ts'\n\n/**\n * @internal\n */\nexport abstract class BaseExtension<T extends ExtensionTyping = ExtensionTyping> implements Extension<T> {\n  abstract extension: Extension | Extension[]\n  priority?: Priority\n  _type?: T\n\n  private trees: Tuple5<FacetNode | null> = [null, null, null, null, null]\n\n  /**\n   * @internal\n   */\n  abstract createTree(priority: Priority): FacetNode\n\n  /**\n   * @internal\n   */\n  getTree(priority?: Priority): FacetNode {\n    const pri = priority ?? this.priority ?? Priority.default\n    return (this.trees[pri] ||= this.createTree(pri))\n  }\n\n  /**\n   * @internal\n   */\n  findFacetOutput<I, O>(facet: Facet<I, O>): Tuple5<O | null> | null {\n    let node: FacetNode | undefined = this.getTree()\n\n    for (const index of facet.path) {\n      node = node?.children.get(index)\n    }\n\n    return node?.getOutput() ?? null\n  }\n\n  get schema(): Schema | null {\n    const output = this.findFacetOutput(schemaFacet)\n    return output?.find(Boolean)?.schema ?? null\n  }\n}\n","export function uniqPush<T>(prev: readonly T[], next: readonly T[]): T[] {\n  const result = [...prev]\n\n  for (const item of next) {\n    if (!result.includes(item)) {\n      result.push(item)\n    }\n  }\n  return result\n}\n\n/**\n * @internal\n */\nexport function arraySubtract<T>(a: T[], b: T[]): T[] {\n  return a.filter((x) => !b.includes(x))\n}\n","import { isNotNullish } from '@ocavue/utils'\n\nimport { Priority } from '../types/priority.ts'\nimport { arraySubtract, uniqPush } from '../utils/array.ts'\nimport { assert } from '../utils/assert.ts'\n\nimport type { FacetReducer, Tuple5 } from './facet-types.ts'\nimport type { Facet } from './facet.ts'\nimport type { RootOutput } from './root.ts'\n\nfunction zip5<T>(\n  a: Tuple5<T>,\n  b: Tuple5<T>,\n  mapper: (a: T, b: T) => T,\n): Tuple5<T> {\n  return [\n    mapper(a[0], b[0]),\n    mapper(a[1], b[1]),\n    mapper(a[2], b[2]),\n    mapper(a[3], b[3]),\n    mapper(a[4], b[4]),\n  ]\n}\n\nfunction unionInput<T>(a: T[] | null, b: T[] | null): T[] | null {\n  if (!a && !b) return null\n  return uniqPush(a ?? [], b ?? [])\n}\n\nfunction subtractInput<T>(a: T[] | null, b: T[] | null): T[] | null {\n  if (!a) return null\n  if (!b) return [...a]\n  return arraySubtract(a, b)\n}\n\nfunction unionChildren(\n  a: Map<number, FacetNode>,\n  b: Map<number, FacetNode>,\n): Map<number, FacetNode> {\n  const merged = new Map(a)\n  for (const [key, valueB] of b.entries()) {\n    const valueA = a.get(key)\n    merged.set(key, valueA ? unionFacetNode(valueA, valueB) : valueB)\n  }\n  return merged\n}\n\nfunction subtractChildren(\n  a: Map<number, FacetNode>,\n  b: Map<number, FacetNode>,\n): Map<number, FacetNode> {\n  const merged = new Map(a)\n  for (const [key, valueB] of b.entries()) {\n    const valueA = a.get(key)\n    if (valueA) {\n      merged.set(key, subtractFacetNode(valueA, valueB))\n    }\n  }\n  return merged\n}\n\n/**\n * Takes two facet nodes and returns a new facet node containing inputs and\n * children from both nodes.\n *\n * The reducers of the first facet node will be reused.\n *\n * @internal\n */\nexport function unionFacetNode<I, O>(\n  a: FacetNode<I, O>,\n  b: FacetNode<I, O>,\n): FacetNode<I, O> {\n  assert(a.facet === b.facet)\n  return new FacetNode(\n    a.facet,\n    zip5(a.inputs, b.inputs, unionInput),\n    unionChildren(a.children, b.children),\n    a.reducers,\n  )\n}\n\n/**\n * Takes two facet nodes and returns a new facet node containing inputs and\n * children from the first node but not the second.\n *\n * The reducers of the first facet node will be reused.\n *\n * @internal\n */\nexport function subtractFacetNode<I, O>(\n  a: FacetNode<I, O>,\n  b: FacetNode<I, O>,\n): FacetNode<I, O> {\n  assert(a.facet === b.facet)\n  return new FacetNode(\n    a.facet,\n    zip5(a.inputs, b.inputs, subtractInput),\n    subtractChildren(a.children, b.children),\n    a.reducers,\n  )\n}\n\nexport class FacetNode<I = any, O = any> {\n  output: Tuple5<O | null> | null = null\n\n  constructor(\n    readonly facet: Facet<I, O>,\n    readonly inputs: Tuple5<I[] | null> = [null, null, null, null, null],\n    readonly children: Map<number, FacetNode> = new Map(),\n    readonly reducers: Tuple5<FacetReducer<I, O> | null> = [\n      null,\n      null,\n      null,\n      null,\n      null,\n    ],\n  ) {}\n\n  private calcOutput(): Tuple5<O | null> {\n    const inputs: Tuple5<I[] | null> = [null, null, null, null, null]\n    const output: Tuple5<O | null> = [null, null, null, null, null]\n\n    for (let pri = 0; pri < 5; pri++) {\n      const input = this.inputs[pri]\n      if (input) {\n        inputs[pri] = [...input]\n      }\n    }\n\n    for (const child of this.children.values()) {\n      const childOutput = child.getOutput()\n      for (let pri = 0; pri < 5; pri++) {\n        if (childOutput[pri]) {\n          const input = (inputs[pri] ||= [])\n          input.push(childOutput[pri] as I)\n        }\n      }\n    }\n\n    if (this.facet.singleton) {\n      const reducer = (this.reducers[Priority.default] ||= this.facet.reducer)\n      const input: I[] = inputs.filter(isNotNullish).flat()\n      output[Priority.default] = reducer(input)\n    } else {\n      for (let pri = 0; pri < 5; pri++) {\n        const input = inputs[pri]\n        if (input) {\n          const reducer = (this.reducers[pri] ||= this.facet.reducer)\n          output[pri] = reducer(input)\n        }\n      }\n    }\n\n    return output\n  }\n\n  getOutput(): Tuple5<O | null> {\n    if (!this.output) {\n      this.output = this.calcOutput()\n    }\n    return this.output\n  }\n\n  getSingletonOutput(): O | null {\n    assert(this.facet.singleton)\n    return this.getOutput()[Priority.default]\n  }\n\n  getRootOutput(): RootOutput {\n    assert(this.isRoot())\n    const output = this.getSingletonOutput()\n    assert(output)\n    return output\n  }\n\n  isRoot(): boolean {\n    return !this.facet.parent\n  }\n}\n","import type { Extension } from '../types/extension.ts'\nimport type { Priority } from '../types/priority.ts'\n\nimport { BaseExtension } from './base-extension.ts'\nimport { FacetNode } from './facet-node.ts'\nimport type { Tuple5 } from './facet-types.ts'\nimport type { Facet } from './facet.ts'\n\n/**\n * @internal\n */\nexport class FacetExtensionImpl<Input, Output> extends BaseExtension {\n  declare extension: Extension\n\n  /**\n   * @internal\n   */\n  constructor(\n    readonly facet: Facet<Input, Output>,\n    readonly payloads: Input[],\n  ) {\n    super()\n  }\n\n  /**\n   * @internal\n   */\n  createTree(priority: Priority): FacetNode {\n    const pri = this.priority ?? priority\n\n    const inputs: Tuple5<Input[] | null> = [null, null, null, null, null]\n    inputs[pri] = [...this.payloads]\n\n    let node: FacetNode = new FacetNode(this.facet, inputs)\n\n    while (node.facet.parent) {\n      const children = new Map([[node.facet.index, node]])\n      node = new FacetNode(node.facet.parent, undefined, children)\n    }\n\n    return node\n  }\n}\n\n/**\n * @internal\n */\nexport function defineFacetPayload<Input>(\n  facet: Facet<Input, any>,\n  payloads: Input[],\n): Extension {\n  return new FacetExtensionImpl(facet, payloads)\n}\n","import type { Mark, ProseMirrorNode, Schema } from '@prosekit/pm/model'\nimport type { EditorStateConfig, Plugin, Selection } from '@prosekit/pm/state'\n\nimport { assert } from '../utils/assert.ts'\n\nimport { defineFacet, type Facet } from './facet.ts'\nimport { rootFacet, type RootPayload } from './root.ts'\n\nexport type StatePayload = (ctx: { schema: Schema }) => EditorStateConfig\n\nexport const stateFacet: Facet<StatePayload, RootPayload> = defineFacet({\n  reduce: () => {\n    // An array of state payloads from lower to higher priority.\n    let callbacks: StatePayload[] = []\n\n    const state: StatePayload = (ctx) => {\n      let doc: ProseMirrorNode | undefined\n      let selection: Selection | undefined\n      let schema: Schema | undefined = ctx.schema\n      const markSet = new Set<Mark>()\n      const pluginSet = new Set<Plugin>()\n\n      // An array of state payloads from higher to lower priority. This matches the\n      // order of plugins required by ProseMirror.\n      const reversedCallbacks = [...callbacks].reverse()\n\n      for (const callback of reversedCallbacks) {\n        const config = callback(ctx)\n\n        doc ||= config.doc\n        selection ||= config.selection\n        schema ||= config.schema\n\n        for (const mark of (config.storedMarks ?? [])) {\n          markSet.add(mark)\n        }\n\n        for (const plugin of (config.plugins ?? [])) {\n          // `config.plugins` is an array of plugins from higher to lower priority.\n          pluginSet.add(plugin)\n        }\n      }\n\n      // If both doc and schema are provided, the schema is not needed.\n      if (doc && schema) {\n        schema = undefined\n      }\n\n      assert(\n        doc || schema,\n        \"Can't create state without a schema nor a document\",\n      )\n\n      return {\n        doc,\n        selection,\n        schema,\n        storedMarks: Array.from(markSet),\n        plugins: Array.from(pluginSet),\n      }\n    }\n\n    return function reducer(inputs) {\n      callbacks = inputs\n      return { state }\n    }\n  },\n  singleton: true,\n  parent: rootFacet,\n})\n","import { DOMDocumentNotFoundError } from '../error.ts'\n\nfunction findGlobalBrowserDocument() {\n  if (typeof document !== 'undefined') {\n    return document\n  }\n\n  if (typeof globalThis !== 'undefined' && globalThis.document) {\n    return globalThis.document\n  }\n}\n\nfunction findGlobalBrowserWindow() {\n  if (typeof window !== 'undefined') {\n    return window\n  }\n\n  if (typeof globalThis !== 'undefined' && globalThis.window) {\n    return globalThis.window\n  }\n}\n\nfunction findBrowserDocument(options?: { document?: Document }): Document | undefined {\n  return (\n    options?.document\n      ?? findGlobalBrowserDocument()\n      ?? findGlobalBrowserWindow()?.document\n  )\n}\n\nfunction findBrowserWindow(options?: {\n  document?: Document\n}): (Window & typeof globalThis) | undefined {\n  return (\n    options?.document?.defaultView\n      ?? findGlobalBrowserWindow()\n      ?? findBrowserDocument(options)?.defaultView\n      ?? undefined\n  )\n}\n\nexport function getBrowserDocument(options?: {\n  document?: Document\n}): Document {\n  const doc = findBrowserDocument(options)\n  if (doc) return doc\n  throw new DOMDocumentNotFoundError()\n}\n\nexport function getBrowserWindow(options?: {\n  document?: Document\n}): Window & typeof globalThis {\n  const win = findBrowserWindow(options)\n  if (win) return win\n  throw new DOMDocumentNotFoundError()\n}\n","import { DOMParser, DOMSerializer, type ParseOptions, type ProseMirrorNode, type Schema } from '@prosekit/pm/model'\nimport { EditorState } from '@prosekit/pm/state'\n\nimport type { DOMNode } from '../types/dom-node.ts'\nimport type { NodeJSON, StateJSON } from '../types/model.ts'\n\nimport { getBrowserDocument, getBrowserWindow } from './get-dom-api.ts'\n\n/** @public */\nexport interface DOMParserOptions extends ParseOptions {\n  DOMParser?: typeof DOMParser\n}\n\n/** @public */\nexport interface DOMSerializerOptions {\n  DOMSerializer?: { fromSchema: typeof DOMSerializer.fromSchema }\n}\n\n/** @public */\nexport interface DOMDocumentOptions {\n  /**\n   * The Document object to use for DOM operations. If not provided, defaults to\n   * the current browser's document object. Useful for server-side rendering or\n   * testing environments.\n   */\n  document?: Document\n}\n\n/** @public */\nexport interface JSONParserOptions {\n  /**\n   * The editor schema to use.\n   */\n  schema: Schema\n}\n\n/////////////// JSON <=> State ///////////////\n\n/**\n * Return a JSON object representing this state.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const state = editor.state\n * const json = jsonFromState(state)\n * ```\n */\nexport function jsonFromState(state: EditorState): StateJSON {\n  return state.toJSON() as StateJSON\n}\n\n/**\n * Parse a JSON object to a ProseMirror state.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { state: { type: 'doc', content: [{ type: 'paragraph' }], selection: { type: 'text', from: 1, to: 1 } } }\n * const state = stateFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function stateFromJSON(\n  json: StateJSON,\n  options: JSONParserOptions,\n): EditorState {\n  return EditorState.fromJSON({ schema: options.schema }, json)\n}\n\n/////////////// JSON <=> Node ///////////////\n\n/**\n * Return a JSON object representing this node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const node = editor.state.doc\n * const json = jsonFromNode(node)\n * ```\n */\nexport function jsonFromNode(node: ProseMirrorNode): NodeJSON {\n  return node.toJSON() as NodeJSON\n}\n\n/**\n * Parse a JSON object to a ProseMirror node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { type: 'doc', content: [{ type: 'paragraph' }] }\n * const node = nodeFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function nodeFromJSON(\n  json: NodeJSON,\n  options: JSONParserOptions,\n): ProseMirrorNode {\n  return options.schema.nodeFromJSON(json)\n}\n\n/////////////// Node <=> Element ///////////////\n\n/**\n * Parse a DOM node to a ProseMirror node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const element = document.getElementById('content')\n * const node = nodeFromElement(element, { schema: editor.schema })\n * ```\n */\nexport function nodeFromElement(\n  element: DOMNode,\n  options: DOMParserOptions & JSONParserOptions,\n): ProseMirrorNode {\n  const { DOMParser: CustomDOMParser, schema, ...parseOptions } = options\n  return (CustomDOMParser || DOMParser)\n    .fromSchema(schema)\n    .parse(element, parseOptions)\n}\n\n/**\n * Serialize a ProseMirror node to an HTML element.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const node = editor.state.doc\n * const element = elementFromNode(node)\n * ```\n */\nexport function elementFromNode(\n  node: ProseMirrorNode,\n  options?: DOMSerializerOptions & DOMDocumentOptions,\n): HTMLElement {\n  const Serializer = options?.DOMSerializer || DOMSerializer\n  const document = getBrowserDocument(options)\n  const schema = node.type.schema\n  const serializer = Serializer.fromSchema(schema)\n\n  if (schema.topNodeType !== node.type) {\n    return serializer.serializeNode(node, { document }) as HTMLElement\n  } else {\n    return serializer.serializeFragment(\n      node.content,\n      { document },\n      document.createElement('div'),\n    ) as HTMLElement\n  }\n}\n\n/////////////// Element <=> HTML ///////////////\n\n/**\n * Parse an HTML string to an HTML element.\n *\n * @internal\n */\nexport function elementFromHTML(\n  html: string,\n  options?: DOMDocumentOptions,\n): HTMLElement {\n  const win = getBrowserWindow(options)\n  const parser = new win.DOMParser()\n  return parser.parseFromString(`<body><div>${html}</div></body>`, 'text/html')\n    .body.firstElementChild as HTMLElement\n}\n\n/**\n * @internal\n */\nfunction htmlFromElement(element: HTMLElement): string {\n  return element.outerHTML\n}\n\n/////////////// Node <=> HTML ///////////////\n\n/**\n * Parse an HTML string to a ProseMirror node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const html = '<p>Hello, world!</p>'\n * const node = nodeFromHTML(html, { schema: editor.schema })\n * ```\n */\nexport function nodeFromHTML(\n  html: string,\n  options: DOMParserOptions & JSONParserOptions & DOMDocumentOptions,\n): ProseMirrorNode {\n  return nodeFromElement(elementFromHTML(html, options), options)\n}\n\n/**\n * Serialize a ProseMirror node to an HTML string\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const node = document.getElementById('content')\n * const html = htmlFromNode(node)\n * ```\n */\nexport function htmlFromNode(\n  node: ProseMirrorNode,\n  options?: DOMSerializerOptions & DOMDocumentOptions,\n): string {\n  return elementFromNode(node, options).outerHTML\n}\n\n/////////////// JSON <=> Element ///////////////\n\n/**\n * Serialize an HTML element to a ProseMirror document JSON object.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const element = document.getElementById('content')\n * const json = jsonFromElement(element, { schema: editor.schema })\n * ```\n */\nexport function jsonFromElement(\n  element: DOMNode,\n  options: DOMParserOptions & JSONParserOptions,\n): NodeJSON {\n  return jsonFromNode(nodeFromElement(element, options))\n}\n\n/**\n * Parse a ProseMirror document JSON object to an HTML element.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { type: 'doc', content: [{ type: 'paragraph' }] }\n * const element = elementFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function elementFromJSON(\n  json: NodeJSON,\n  options: JSONParserOptions & DOMSerializerOptions & DOMDocumentOptions,\n): HTMLElement {\n  return elementFromNode(nodeFromJSON(json, options), options)\n}\n\n/////////////// JSON <=> HTML ///////////////\n\n/**\n * Parse an HTML string to a ProseMirror document JSON object.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const html = '<p>Hello, world!</p>'\n * const json = jsonFromHTML(html, { schema: editor.schema })\n * ```\n */\nexport function jsonFromHTML(\n  html: string,\n  options: DOMDocumentOptions & DOMParserOptions & JSONParserOptions,\n): NodeJSON {\n  return jsonFromElement(elementFromHTML(html, options), options)\n}\n\n/**\n * Parse a ProseMirror document JSON object to an HTML string.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { type: 'doc', content: [{ type: 'paragraph' }] }\n * const html = htmlFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function htmlFromJSON(\n  json: NodeJSON,\n  options: JSONParserOptions & DOMSerializerOptions & DOMDocumentOptions,\n): string {\n  return htmlFromElement(elementFromJSON(json, options))\n}\n","import { isElementLike } from '@ocavue/utils'\nimport type { ProseMirrorNode, Schema } from '@prosekit/pm/model'\nimport { Selection } from '@prosekit/pm/state'\n\nimport type { NodeJSON, SelectionJSON } from '../types/model.ts'\n\nimport { assert } from './assert.ts'\nimport { jsonFromElement, jsonFromHTML } from './parse.ts'\nimport { isProseMirrorNode, isSelection } from './type-assertion.ts'\n\nexport function getEditorContentJSON(\n  schema: Schema,\n  content: NodeJSON | string | Element,\n): NodeJSON {\n  if (typeof content === 'string') {\n    return jsonFromHTML(content, { schema })\n  } else if (isElementLike(content)) {\n    return jsonFromElement(content, { schema })\n  } else {\n    return content\n  }\n}\n\nfunction getEditorContentNode(\n  schema: Schema,\n  content: NodeJSON | string | Element | ProseMirrorNode,\n): ProseMirrorNode {\n  if (isProseMirrorNode(content)) {\n    return content\n  }\n  return schema.nodeFromJSON(getEditorContentJSON(schema, content))\n}\n\nexport function getEditorContentDoc(\n  schema: Schema,\n  content: NodeJSON | string | Element | ProseMirrorNode,\n): ProseMirrorNode {\n  const doc = getEditorContentNode(schema, content)\n  assert(\n    doc.type.schema === schema,\n    'Document schema does not match editor schema',\n  )\n  assert(\n    doc.type === schema.topNodeType,\n    `Document type does not match editor top node type. Expected ${schema.topNodeType.name}, got ${doc.type.name}`,\n  )\n  return doc\n}\n\nexport function getEditorSelection(\n  doc: ProseMirrorNode,\n  selection: SelectionJSON | Selection | 'start' | 'end',\n): Selection {\n  if (isSelection(selection)) {\n    assert(selection.$head.doc === doc, 'Selection and doc do not match')\n    return selection\n  }\n  if (selection === 'start') {\n    return Selection.atStart(doc)\n  }\n  if (selection === 'end') {\n    return Selection.atEnd(doc)\n  }\n  return Selection.fromJSON(doc, selection)\n}\n","import { Selection, type EditorStateConfig } from '@prosekit/pm/state'\n\nimport { defineFacetPayload } from '../facets/facet-extension.ts'\nimport { stateFacet } from '../facets/state.ts'\nimport type { PlainExtension } from '../types/extension.ts'\nimport type { NodeJSON, SelectionJSON } from '../types/model.ts'\nimport { getEditorContentJSON } from '../utils/editor-content.ts'\n\n/**\n * @public\n */\nexport interface DefaultStateOptions {\n  /**\n   * The starting document to use when creating the editor. It can be a\n   * ProseMirror node JSON object, an HTML string, or a DOM element instance.\n   */\n  defaultContent?: NodeJSON | string | Element\n\n  /**\n   * A JSON object representing the starting selection to use when creating the\n   * editor. It's only used when `defaultContent` is also provided.\n   */\n  defaultSelection?: SelectionJSON\n}\n\n/**\n * Define a default state for the editor.\n *\n * @param options\n *\n * @public\n */\nexport function defineDefaultState({\n  defaultSelection,\n  defaultContent,\n}: DefaultStateOptions): PlainExtension {\n  return defineFacetPayload(stateFacet, [\n    ({ schema }) => {\n      const config: EditorStateConfig = {}\n      if (defaultContent) {\n        const json = getEditorContentJSON(schema, defaultContent)\n        config.doc = schema.nodeFromJSON(json)\n        if (defaultSelection) {\n          config.selection = Selection.fromJSON(config.doc, defaultSelection)\n        }\n      }\n      return config\n    },\n  ]) as PlainExtension\n}\n","/**\n * Check if `subset` is a subset of `superset`.\n *\n * @internal\n */\nexport function isSubset(\n  subset: Record<string, unknown>,\n  superset: Record<string, unknown>,\n): boolean {\n  return Object.keys(subset).every((key) => subset[key] === superset[key])\n}\n","import type { Attrs, Mark, MarkType } from '@prosekit/pm/model'\n\nimport { isSubset } from './is-subset.ts'\n\nexport function includesMark(\n  marks: readonly Mark[],\n  markType: MarkType,\n  attrs?: Attrs | null,\n): boolean {\n  attrs = attrs || {}\n  return marks.some((mark) => {\n    return mark.type === markType && isSubset(attrs, mark.attrs)\n  })\n}\n","import type { Attrs, MarkType, ProseMirrorNode } from '@prosekit/pm/model'\n\nimport { includesMark } from './includes-mark.ts'\n\n/**\n * Returns true if the given mark is missing in some part of the range.\n * Returns false if the entire range has the given mark.\n * Returns true if the mark is not allowed in the range.\n *\n * @internal\n */\nexport function isMarkAbsent(\n  node: ProseMirrorNode,\n  from: number,\n  to: number,\n  markType: MarkType,\n  attrs?: Attrs | null,\n): boolean {\n  let missing = false\n  let available = false\n\n  node.nodesBetween(from, to, (node, pos, parent) => {\n    if (missing) {\n      return false\n    }\n\n    const allowed = parent?.type.allowsMarkType(markType)\n      && !node.marks.some((m) => m.type !== markType && m.type.excludes(markType))\n\n    if (allowed) {\n      available = true\n      if (!includesMark(node.marks, markType, attrs)) {\n        missing = true\n      }\n    }\n  })\n  return available ? missing : true\n}\n","import type { Attrs, MarkType } from '@prosekit/pm/model'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport { getMarkType } from './get-mark-type.ts'\nimport { includesMark } from './includes-mark.ts'\nimport { isMarkAbsent } from './is-mark-absent.ts'\n\n/**\n * @internal\n */\nexport function isMarkActive(\n  state: EditorState,\n  type: string | MarkType,\n  attrs?: Attrs | null,\n): boolean {\n  const { from, $from, to, empty } = state.selection\n  const markType = getMarkType(state.schema, type)\n  if (empty) {\n    const marks = state.storedMarks || $from.marks()\n    return includesMark(marks, markType, attrs)\n  } else {\n    return !isMarkAbsent(state.doc, from, to, markType, attrs)\n  }\n}\n","import { mapValues } from '@ocavue/utils'\nimport type { Attrs, Mark, MarkType, NodeType, ProseMirrorNode, Schema } from '@prosekit/pm/model'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport { ProseKitError } from '../error.ts'\nimport type { AnyAttrs } from '../types/attrs.ts'\nimport { assert } from '../utils/assert.ts'\nimport { isMarkActive } from '../utils/is-mark-active.ts'\nimport { isNodeActive } from '../utils/is-node-active.ts'\nimport { isProseMirrorNode } from '../utils/type-assertion.ts'\n\n/**\n * Available children parameters for {@link NodeAction} and {@link MarkAction}.\n *\n * @public\n */\nexport type NodeChild = ProseMirrorNode | string | NodeChild[]\n\n/**\n * A function for creating a node with optional attributes and any number of\n * children.\n *\n * It also has a `isActive` method for checking if the node is active in the\n * current editor selection.\n *\n * @public\n */\nexport interface NodeAction<Attrs extends AnyAttrs = AnyAttrs> {\n  /**\n   * Creates a node with attributes and any number of children.\n   */\n  (attrs: Attrs | null, ...children: NodeChild[]): ProseMirrorNode\n\n  /**\n   * Creates a node with any number of children.\n   */\n  (...children: NodeChild[]): ProseMirrorNode\n\n  /**\n   * Checks if the node is active in the current editor selection. If the\n   * optional `attrs` parameter is provided, it will check if the node is active\n   * with the given attributes.\n   */\n  isActive: (attrs?: Attrs) => boolean\n}\n\n/**\n * A function for applying a mark with optional attributes and any number of\n * children.\n *\n * It also has a `isActive` method for checking if the mark is active in the\n * current editor selection.\n *\n * @public\n */\nexport interface MarkAction<Attrs extends AnyAttrs = AnyAttrs> {\n  /**\n   * Applies a mark with attributes and any number of children.\n   */\n  (attrs: Attrs | null, ...children: NodeChild[]): ProseMirrorNode[]\n\n  /**\n   * Applies a mark with any number of children.\n   */\n  (...children: NodeChild[]): ProseMirrorNode[]\n\n  /**\n   * Checks if the mark is active in the current editor selection. If the\n   * optional `attrs` parameter is provided, it will check if the mark is active\n   * with the given attributes.\n   */\n  isActive: (attrs?: Attrs) => boolean\n}\n\n/**\n * @internal\n */\nexport function createNodeActions(\n  schema: Schema,\n  getState: GetStateFunction,\n  createNode: CreateNodeFunction = defaultCreateNode,\n): Record<string, NodeAction> {\n  return mapValues(schema.nodes, (type) => createNodeAction(type, getState, createNode))\n}\n\nfunction createNodeAction(\n  type: NodeType,\n  getState: GetStateFunction,\n  createNode: CreateNodeFunction,\n): NodeAction {\n  const action = (\n    ...args: [Attrs | NodeChild | null | undefined, ...NodeChild[]]\n  ) => buildNode(type, args, createNode)\n  action.isActive = (attrs?: Attrs) => {\n    const state = getState()\n    return state ? isNodeActive(state, type, attrs) : false\n  }\n  return action\n}\n\n/**\n * @internal\n */\nexport function createMarkActions(\n  schema: Schema,\n  getState: GetStateFunction,\n  applyMark: ApplyMarkFunction = defaultApplyMark,\n): Record<string, MarkAction> {\n  return mapValues(schema.marks, (type) => createMarkAction(type, getState, applyMark))\n}\n\nfunction createMarkAction(\n  type: MarkType,\n  getState: GetStateFunction,\n  applyMark: ApplyMarkFunction,\n): MarkAction {\n  const action = (\n    ...args: [Attrs | NodeChild | null | undefined, ...NodeChild[]]\n  ) => buildMark(type, args, applyMark)\n  action.isActive = (attrs?: Attrs) => {\n    const state = getState()\n    return state ? isMarkActive(state, type, attrs) : false\n  }\n  return action\n}\n\nfunction buildMark(\n  type: MarkType,\n  args: [Attrs | NodeChild | null | undefined, ...NodeChild[]],\n  applyMark: ApplyMarkFunction,\n): ProseMirrorNode[] {\n  const [attrs, children] = normalizeArgs(args)\n  const mark = type.create(attrs)\n  return applyMark(mark, flattenChildren(type.schema, children))\n}\n\n/**\n * @internal\n */\nexport type ApplyMarkFunction = (\n  mark: Mark,\n  children: ProseMirrorNode[],\n) => ProseMirrorNode[]\n\nconst defaultApplyMark: ApplyMarkFunction = (\n  mark: Mark,\n  children: ProseMirrorNode[],\n): ProseMirrorNode[] => {\n  return children.map((node) => node.mark(mark.addToSet(node.marks)))\n}\n\nfunction buildNode(\n  type: NodeType,\n  args: [Attrs | NodeChild | null | undefined, ...NodeChild[]],\n  createNode: CreateNodeFunction,\n): ProseMirrorNode {\n  const [attrs, children] = normalizeArgs(args)\n  return createNode(type, attrs, flattenChildren(type.schema, children))\n}\n\n/**\n * @internal\n */\nexport type CreateNodeFunction = (\n  type: NodeType,\n  attrs: Attrs | null,\n  children: ProseMirrorNode[],\n) => ProseMirrorNode\n\ntype GetStateFunction = () => EditorState | null | undefined\n\nconst defaultCreateNode: CreateNodeFunction = (\n  type: NodeType,\n  attrs: Attrs | null,\n  children: ProseMirrorNode[],\n) => {\n  const node = type.createAndFill(attrs, children)\n  assert(node, `Failed to create node ${type.name}`)\n  return node\n}\n\nfunction flattenChildren(\n  schema: Schema,\n  children: NodeChild[],\n): Array<ProseMirrorNode> {\n  const nodes: Array<ProseMirrorNode> = []\n\n  for (const child of children) {\n    if (typeof child === 'string') {\n      if (child) {\n        nodes.push(schema.text(child, null))\n      }\n    } else if (Array.isArray(child)) {\n      nodes.push(...flattenChildren(schema, child))\n    } else if (isProseMirrorNode(child)) {\n      nodes.push(child)\n    } else {\n      throw new ProseKitError(`Invalid node child: ${typeof child}`)\n    }\n  }\n\n  return nodes\n}\n\nfunction normalizeArgs(\n  args: [Attrs | NodeChild | null | undefined, ...NodeChild[]],\n): [Attrs | null, NodeChild[]] {\n  const [attrs, ...children] = args\n  if (isNodeChild(attrs)) {\n    children.unshift(attrs)\n    return [null, children]\n  } else if (typeof attrs === 'object') {\n    return [attrs, children]\n  } else {\n    return [null, children]\n  }\n}\n\nfunction isNodeChild(\n  value: Attrs | NodeChild | null | undefined,\n): value is NodeChild {\n  if (!value) {\n    return false\n  }\n\n  return (\n    typeof value === 'string'\n    || Array.isArray(value)\n    || isProseMirrorNode(value)\n  )\n}\n","import type { Extension, ExtensionTyping } from '../types/extension.ts'\nimport type { Priority } from '../types/priority.ts'\nimport { assert } from '../utils/assert.ts'\n\nimport { BaseExtension } from './base-extension.ts'\nimport { unionFacetNode, type FacetNode } from './facet-node.ts'\n\nexport class UnionExtensionImpl<T extends ExtensionTyping = ExtensionTyping> extends BaseExtension<T> implements Extension<T> {\n  /**\n   * @internal\n   */\n  constructor(public extension: BaseExtension[] = []) {\n    super()\n  }\n\n  /**\n   * @internal\n   */\n  createTree(priority: Priority): FacetNode {\n    const pri = this.priority ?? priority\n\n    const extensions = [...this.extension]\n    extensions.sort((a, b) => (a.priority ?? pri) - (b.priority ?? pri))\n\n    const children: FacetNode[] = extensions.map((ext) => ext.getTree(pri))\n\n    assert(children.length > 0)\n\n    let node = children[0]\n    for (let i = 1; i < children.length; i++) {\n      node = unionFacetNode(node, children[i])\n    }\n    return node\n  }\n}\n","import type { BaseExtension } from '../facets/base-extension.ts'\nimport { UnionExtensionImpl } from '../facets/union-extension.ts'\nimport type { Extension, Union } from '../types/extension.ts'\nimport { assert } from '../utils/assert.ts'\n\n/**\n * Merges multiple extensions into one. You can pass multiple extensions as\n * arguments or a single array containing multiple extensions.\n *\n * @throws If no extensions are provided.\n *\n * @example\n *\n * ```ts\n * function defineFancyNodes() {\n *   return union(\n *     defineFancyParagraph(),\n *     defineFancyHeading(),\n *   )\n * }\n * ```\n *\n * @example\n *\n * ```ts\n * function defineFancyNodes() {\n *   return union([\n *     defineFancyParagraph(),\n *     defineFancyHeading(),\n *   ])\n * }\n * ```\n *\n * @public\n */\nfunction union<const E extends readonly Extension[]>(...exts: E): Union<E>\nfunction union<const E extends readonly Extension[]>(exts: E): Union<E>\nfunction union(...exts: Array<Extension | Extension[]>): Extension {\n  const extensions: Extension[] = exts.flat()\n  assert(extensions.length > 0, 'At least one extension is required')\n  return new UnionExtensionImpl(extensions as BaseExtension[]) as Extension\n}\n\nexport { union }\n","import { isDeepEqual } from '@ocavue/utils'\nimport type { ProseMirrorNode, Schema } from '@prosekit/pm/model'\nimport { EditorState, type Command, type Plugin, type Selection, type Transaction } from '@prosekit/pm/state'\nimport { EditorView, type DirectEditorProps, type EditorProps } from '@prosekit/pm/view'\n\nimport { ProseKitError } from '../error.ts'\nimport { defineDefaultState } from '../extensions/default-state.ts'\nimport type { BaseExtension } from '../facets/base-extension.ts'\nimport { subtractFacetNode, unionFacetNode, type FacetNode } from '../facets/facet-node.ts'\nimport type { CommandAction, CommandCreator } from '../types/extension-command.ts'\nimport type {\n  Extension,\n  ExtractCommandActions,\n  ExtractMarkActions,\n  ExtractMarkNames,\n  ExtractNodeActions,\n  ExtractNodeNames,\n} from '../types/extension.ts'\nimport type { NodeJSON, SelectionJSON } from '../types/model.ts'\nimport { assert } from '../utils/assert.ts'\nimport { getEditorContentDoc, getEditorSelection } from '../utils/editor-content.ts'\nimport { htmlFromNode, jsonFromNode, type DOMDocumentOptions } from '../utils/parse.ts'\n\nimport { createMarkActions, createNodeActions, type MarkAction, type NodeAction } from './action.ts'\nimport { union } from './union.ts'\n\n/**\n * @public\n */\nexport interface EditorOptions<E extends Extension> {\n  /**\n   * The extension to use when creating the editor.\n   */\n  extension: E\n\n  /**\n   * The starting document to use when creating the editor. It can be a\n   * ProseMirror node JSON object, an HTML string, or a DOM element instance.\n   */\n  defaultContent?: NodeJSON | string | Element\n\n  /**\n   * A JSON object representing the starting selection to use when creating the\n   * editor. It's only used when `defaultContent` is also provided.\n   */\n  defaultSelection?: SelectionJSON\n}\n\n/**\n * @public\n */\nexport interface getDocHTMLOptions extends DOMDocumentOptions {}\n\n/**\n * @internal\n */\nexport function setupEditorExtension<E extends Extension>(\n  options: EditorOptions<E>,\n): E {\n  if (options.defaultContent) {\n    return union(\n      options.extension,\n      defineDefaultState(options),\n    ) as Extension as E\n  }\n  return options.extension\n}\n\n/**\n * @public\n */\nexport function createEditor<E extends Extension>(\n  options: EditorOptions<E>,\n): Editor<E> {\n  const extension = setupEditorExtension(options)\n  const instance = new EditorInstance(extension)\n  return new Editor(instance)\n}\n\n/**\n * An internal class to make TypeScript generic type easier to use.\n *\n * @internal\n */\nexport class EditorInstance {\n  view: EditorView | null = null\n  schema: Schema\n  nodes: Record<string, NodeAction>\n  marks: Record<string, MarkAction>\n  commands: Record<string, CommandAction> = {}\n\n  private tree: FacetNode\n  private directEditorProps: DirectEditorProps\n  private afterMounted: Array<VoidFunction> = []\n\n  constructor(extension: Extension) {\n    this.tree = (extension as BaseExtension).getTree()\n\n    const payload = this.tree.getRootOutput()\n    const schema = payload.schema\n    const stateConfig = payload.state\n\n    assert(schema && stateConfig, 'Schema must be defined')\n\n    const state = EditorState.create(stateConfig)\n\n    if (payload.commands) {\n      for (const [name, commandCreator] of Object.entries(payload.commands)) {\n        this.defineCommand(name, commandCreator)\n      }\n    }\n\n    this.nodes = createNodeActions(state.schema, this.getState)\n    this.marks = createMarkActions(state.schema, this.getState)\n\n    this.schema = state.schema\n    this.directEditorProps = { state, ...payload.view }\n  }\n\n  public getState = (): EditorState => {\n    return this.view?.state || this.directEditorProps.state\n  }\n\n  private getDoc(): ProseMirrorNode {\n    return this.getState().doc\n  }\n\n  private getProp<PropName extends keyof EditorProps>(propName: PropName): Partial<EditorProps>[PropName] {\n    return this.view?.someProp(propName) ?? this.directEditorProps[propName]\n  }\n\n  public updateState(state: EditorState): void {\n    if (this.view) {\n      this.view.updateState(state)\n    } else {\n      this.directEditorProps.state = state\n    }\n  }\n\n  private dispatch = (tr: Transaction): void => {\n    if (this.view) {\n      this.view.dispatch(tr)\n    } else {\n      this.directEditorProps.state = this.directEditorProps.state.apply(tr)\n    }\n  }\n\n  public setContent(\n    content: NodeJSON | string | Element | ProseMirrorNode,\n    selection?: SelectionJSON | Selection | 'start' | 'end',\n  ): void {\n    const doc = getEditorContentDoc(this.schema, content)\n    doc.check()\n    const sel = getEditorSelection(doc, selection || 'start')\n\n    const oldState = this.getState()\n    if (doc.eq(oldState.doc) && (!selection || sel.eq(oldState.selection))) {\n      return\n    }\n\n    const newState = EditorState.create({\n      doc,\n      selection: sel,\n      plugins: oldState.plugins,\n    })\n    this.updateState(newState)\n  }\n\n  /**\n   * Return a JSON object representing the editor's current document.\n   */\n  public getDocJSON = (): NodeJSON => {\n    const state = this.getState()\n    return jsonFromNode(state.doc)\n  }\n\n  /**\n   * Return an HTML string representing the editor's current document.\n   */\n  public getDocHTML = (options?: getDocHTMLOptions): string => {\n    const serializer = this.getProp('clipboardSerializer')\n    const DOMSerializer = serializer ? { fromSchema: () => serializer } : undefined\n    const doc = this.getDoc()\n    return htmlFromNode(doc, { ...options, DOMSerializer })\n  }\n\n  private updateExtension(extension: Extension, add: boolean): void {\n    const view = this.view\n\n    // Don't update the extension if the editor is already unmounted\n    if (!view || view.isDestroyed) {\n      return\n    }\n\n    const tree = (extension as BaseExtension).getTree()\n    const payload = tree.getRootOutput()\n\n    if (payload?.schema) {\n      throw new ProseKitError('Schema cannot be changed')\n    }\n\n    if (payload?.view) {\n      throw new ProseKitError('View cannot be changed')\n    }\n\n    const oldPayload = this.tree.getRootOutput()\n    const oldPlugins = [...(view.state?.plugins ?? [])]\n\n    this.tree = add\n      ? unionFacetNode(this.tree, tree)\n      : subtractFacetNode(this.tree, tree)\n\n    const newPayload = this.tree.getRootOutput()\n    const newPlugins = [...(newPayload?.state?.plugins ?? [])]\n\n    if (!isDeepEqual(oldPlugins, newPlugins)) {\n      const state = view.state.reconfigure({ plugins: newPlugins })\n      view.updateState(state)\n    }\n\n    if (\n      newPayload?.commands\n      && !isDeepEqual(oldPayload?.commands, newPayload?.commands)\n    ) {\n      const commands = newPayload.commands\n      const names = Object.keys(commands)\n      for (const name of names) {\n        this.defineCommand(name, commands[name])\n      }\n    }\n  }\n\n  public use(extension: Extension): VoidFunction {\n    if (!this.mounted) {\n      let canceled = false\n      let lazyRemove: VoidFunction | null = null\n\n      const lazyCreate = () => {\n        if (!canceled) {\n          lazyRemove = this.use(extension)\n        }\n      }\n\n      this.afterMounted.push(lazyCreate)\n\n      return () => {\n        canceled = true\n        lazyRemove?.()\n      }\n    }\n\n    this.updateExtension(extension, true)\n    return () => this.updateExtension(extension, false)\n  }\n\n  public mount(place: HTMLElement): void {\n    if (this.view) {\n      // If the editor is already mounted to the same DOM element, do nothing\n      if (this.view.dom === place) return\n      // If the editor is already mounted to a different element, throw an error\n      throw new ProseKitError('Editor is already mounted')\n    }\n    this.view = new EditorView({ mount: place }, this.directEditorProps)\n    this.afterMounted.forEach((callback) => callback())\n    this.afterMounted.length = 0\n  }\n\n  public unmount(): void {\n    // If the editor is not mounted, do nothing\n    if (!this.view) return\n\n    this.directEditorProps.state = this.view.state\n    this.view.destroy()\n    this.view = null\n  }\n\n  get mounted(): boolean {\n    return !!this.view && !this.view.isDestroyed\n  }\n\n  public get assertView(): EditorView {\n    if (!this.view) {\n      throw new ProseKitError('Editor is not mounted')\n    }\n    return this.view\n  }\n\n  public definePlugins(plugins: readonly Plugin[]): void {\n    const view = this.assertView\n    const state = view.state\n    const newPlugins = [...plugins, ...state.plugins]\n    const newState = state.reconfigure({ plugins: newPlugins })\n    view.setProps({ state: newState })\n  }\n\n  public removePlugins(plugins: readonly Plugin[]): void {\n    const view = this.view\n    if (!view) return\n\n    const state = view.state\n    const newPlugins = state.plugins.filter((p) => !plugins.includes(p))\n    const newState = state.reconfigure({ plugins: newPlugins })\n    view.setProps({ state: newState })\n  }\n\n  exec(command: Command): boolean {\n    const state = this.getState()\n    return command(state, this.dispatch, this.view ?? undefined)\n  }\n\n  canExec(command: Command): boolean {\n    const state = this.getState()\n    return command(state, undefined, this.view ?? undefined)\n  }\n\n  public defineCommand<Args extends any[] = any[]>(\n    name: string,\n    commandCreator: CommandCreator<Args>,\n  ): void {\n    const action: CommandAction<Args> = (...args: Args) => {\n      const command = commandCreator(...args)\n      return this.exec(command)\n    }\n\n    const canExec = (...args: Args) => {\n      const command = commandCreator(...args)\n      return this.canExec(command)\n    }\n\n    action.canExec = canExec\n\n    this.commands[name] = action as CommandAction\n  }\n\n  public removeCommand(name: string): void {\n    delete this.commands[name]\n  }\n}\n\n/**\n * @public\n */\nexport class Editor<E extends Extension = any> {\n  private instance: EditorInstance\n\n  /**\n   * @internal\n   */\n  constructor(instance: EditorInstance) {\n    if (!(instance instanceof EditorInstance)) {\n      throw new TypeError('Invalid EditorInstance')\n    }\n    this.instance = instance\n  }\n\n  /**\n   * Whether the editor is mounted.\n   */\n  get mounted(): boolean {\n    return this.instance.mounted\n  }\n\n  /**\n   * The editor view.\n   */\n  get view(): EditorView {\n    return this.instance.assertView\n  }\n\n  /**\n   * The editor schema.\n   */\n  get schema(): Schema<ExtractNodeNames<E>, ExtractMarkNames<E>> {\n    return this.instance.schema\n  }\n\n  /**\n   * The editor's current state.\n   */\n  get state(): EditorState {\n    return this.instance.getState()\n  }\n\n  /**\n   * Whether the editor is focused.\n   */\n  get focused(): boolean {\n    return this.instance.view?.hasFocus() ?? false\n  }\n\n  /**\n   * Mount the editor to the given HTML element. Pass `null` or `undefined` to\n   * unmount the editor. When an element is passed, this method returns a\n   * function to unmount the editor.\n   */\n  mount = (place: HTMLElement | null | undefined): void | VoidFunction => {\n    if (place) {\n      this.instance.mount(place)\n      return this.unmount\n    } else {\n      this.instance.unmount()\n    }\n  }\n\n  /**\n   * Unmount the editor. This is equivalent to `mount(null)`.\n   */\n  unmount = (): void => {\n    this.instance.unmount()\n  }\n\n  /**\n   * Focus the editor.\n   */\n  focus = (): void => {\n    this.instance.view?.focus()\n  }\n\n  /**\n   * Blur the editor.\n   */\n  blur = (): void => {\n    this.instance.view?.dom.blur()\n  }\n\n  /**\n   * Register an extension to the editor. Return a function to unregister the\n   * extension.\n   */\n  use = (extension: Extension): VoidFunction => {\n    return this.instance.use(extension)\n  }\n\n  /**\n   * Update the editor's state.\n   *\n   * @remarks\n   *\n   * This is an advanced method. Use it only if you have a specific reason to\n   * directly manipulate the editor's state.\n   */\n  updateState = (state: EditorState): void => {\n    this.instance.updateState(state)\n  }\n\n  /**\n   * Update the editor's document and selection.\n   *\n   * @param content - The new document to set. It can be one of the following:\n   *   - A ProseMirror node instance\n   *   - A ProseMirror node JSON object\n   *   - An HTML string\n   *   - A DOM element instance\n   * @param selection - Optional. Specifies the new selection. It can be one of the following:\n   *   - A ProseMirror selection instance\n   *   - A ProseMirror selection JSON object\n   *   - The string \"start\" (to set selection at the beginning, default value)\n   *   - The string \"end\" (to set selection at the end)\n   */\n  setContent = (\n    content: ProseMirrorNode | NodeJSON | string | Element,\n    selection?: SelectionJSON | Selection | 'start' | 'end',\n  ): void => {\n    return this.instance.setContent(content, selection)\n  }\n\n  /**\n   * Return a JSON object representing the editor's current document.\n   */\n  public getDocJSON = (): NodeJSON => {\n    return this.instance.getDocJSON()\n  }\n\n  /**\n   * Return an HTML string representing the editor's current document.\n   */\n  public getDocHTML = (options?: getDocHTMLOptions): string => {\n    return this.instance.getDocHTML(options)\n  }\n\n  /**\n   * Execute the given command. Return `true` if the command was successfully\n   * executed, otherwise `false`.\n   */\n  exec = (command: Command): boolean => {\n    return this.instance.exec(command)\n  }\n\n  /**\n   * Check if the given command can be executed. Return `true` if the command\n   * can be executed, otherwise `false`.\n   */\n  canExec = (command: Command): boolean => {\n    return this.instance.canExec(command)\n  }\n\n  /**\n   * All {@link CommandAction}s defined by the editor.\n   */\n  get commands(): ExtractCommandActions<E> {\n    return this.instance.commands as ExtractCommandActions<E>\n  }\n\n  /**\n   * All {@link NodeAction}s defined by the editor.\n   */\n  get nodes(): ExtractNodeActions<E> {\n    return this.instance.nodes as ExtractNodeActions<E>\n  }\n\n  /**\n   * All {@link MarkAction}s defined by the editor.\n   */\n  get marks(): ExtractMarkActions<E> {\n    return this.instance.marks as ExtractMarkActions<E>\n  }\n}\n"],"mappings":"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"}