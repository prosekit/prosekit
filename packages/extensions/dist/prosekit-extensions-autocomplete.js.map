{"version":3,"file":"prosekit-extensions-autocomplete.js","names":["pluginKey: PluginKey<PredictionPluginState>","parentOffset: number","rules: AutocompleteRule[]"],"sources":["../src/autocomplete/autocomplete-helpers.ts","../src/autocomplete/autocomplete-plugin.ts","../src/autocomplete/autocomplete.ts","../src/autocomplete/autocomplete-rule.ts"],"sourcesContent":["import type { ResolvedPos } from '@prosekit/pm/model'\nimport {\n  PluginKey,\n  type EditorState,\n  type Transaction,\n} from '@prosekit/pm/state'\n\nimport type { AutocompleteRule } from './autocomplete-rule'\n\nexport function defaultCanMatch({ state }: { state: EditorState }): boolean {\n  const $pos = state.selection.$from\n  return !isInsideCodeBlock($pos) && !isInsideCodeMark($pos)\n}\n\nfunction isInsideCodeBlock($pos: ResolvedPos): boolean {\n  for (let d = $pos.depth; d > 0; d--) {\n    if ($pos.node(d).type.spec.code) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction isInsideCodeMark($pos: ResolvedPos): boolean {\n  for (const mark of $pos.marks()) {\n    if (mark.type.spec.code) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @internal\n */\nexport interface PredictionPluginMatching {\n  rule: AutocompleteRule\n  from: number\n  to: number\n  match: RegExpExecArray\n}\n\n/**\n * @internal\n */\nexport interface PredictionPluginState {\n  /**\n   * The matching positions that should be ignored.\n   */\n  ignores: Array<number>\n\n  /**\n   * The current active matching.\n   */\n  matching: PredictionPluginMatching | null\n}\n\n/**\n * @internal\n */\nexport type PredictionTransactionMeta = {\n  type: 'enter'\n  matching: PredictionPluginMatching\n} | {\n  type: 'leave'\n}\n\nexport function getPluginState(state: EditorState): PredictionPluginState | undefined {\n  return pluginKey.getState(state)\n}\n\nexport function getTrMeta(tr: Transaction): PredictionTransactionMeta | undefined {\n  return tr.getMeta(pluginKey) as PredictionTransactionMeta | undefined\n}\n\nexport function setTrMeta(\n  tr: Transaction,\n  meta: PredictionTransactionMeta,\n): Transaction {\n  return tr.setMeta(pluginKey, meta)\n}\n\nexport const pluginKey: PluginKey<PredictionPluginState> = new PluginKey<PredictionPluginState>('prosekit-autocomplete')\n","import { OBJECT_REPLACEMENT_CHARACTER } from '@prosekit/core'\nimport type {\n  ProseMirrorNode,\n  ResolvedPos,\n} from '@prosekit/pm/model'\nimport {\n  Plugin,\n  type EditorState,\n  type Transaction,\n} from '@prosekit/pm/state'\nimport type { Mapping } from '@prosekit/pm/transform'\nimport type { EditorView } from '@prosekit/pm/view'\nimport {\n  Decoration,\n  DecorationSet,\n} from '@prosekit/pm/view'\n\nimport {\n  getPluginState,\n  getTrMeta,\n  pluginKey,\n  setTrMeta,\n  type PredictionPluginMatching,\n  type PredictionPluginState,\n  type PredictionTransactionMeta,\n} from './autocomplete-helpers'\nimport type { AutocompleteRule } from './autocomplete-rule'\n\n/**\n * Creates a plugin that handles autocomplete functionality.\n *\n * Workflow:\n *\n * 1. {@link handleTextInput}: called when text is going to be input, but the\n *    transaction is not yet created. Injects a new matching as a transaction\n *    meta if applicable. This is the only place to create a new matching if\n *    there is no existing matching.\n * 2. {@link handleTransaction}: called when a transaction is going to be\n *    applied. Updates the plugin state based on the transaction. This step\n *    determines if a matching should be created, updated or removed.\n * 3. {@link handleUpdate}: called when the editor state is updated. This is the\n *    place to call `onMatch` and register `deleteMatch` and `ignoreMatch`\n *    callbacks.\n * 4. {@link getDecorations}: creates the decorations for the current matching.\n */\nexport function createAutocompletePlugin({\n  getRules,\n}: {\n  getRules: () => AutocompleteRule[]\n}): Plugin {\n  return new Plugin<PredictionPluginState>({\n    key: pluginKey,\n\n    state: {\n      init: (): PredictionPluginState => {\n        return { ignores: [], matching: null }\n      },\n      apply: (tr, prevValue, oldState, newState): PredictionPluginState => {\n        return handleTransaction(tr, prevValue, oldState, newState, getRules)\n      },\n    },\n\n    view: () => ({\n      update: handleUpdate,\n    }),\n\n    props: {\n      handleTextInput: (view, from, to, textAdded, getTr) => {\n        const meta = handleTextInput(view, from, to, textAdded, getRules)\n        if (meta) {\n          const tr = getTr()\n          setTrMeta(tr, meta)\n          view.dispatch(tr)\n          return true\n        }\n        return false\n      },\n      decorations: getDecorations,\n    },\n  })\n}\n\nfunction handleTextInput(\n  view: EditorView,\n  from: number,\n  to: number,\n  textAdded: string,\n  getRules: () => AutocompleteRule[],\n): PredictionTransactionMeta | undefined {\n  // Only handle insertions\n  if (from !== to) {\n    return\n  }\n\n  const textBackward = getTextBackward(view.state.doc.resolve(from))\n  const textFull = textBackward + textAdded\n  const textTo = to + textAdded.length\n  const textFrom = textTo - textFull.length\n\n  const pluginState = getPluginState(view.state)\n  const ignores = pluginState?.ignores ?? []\n\n  const currMatching = matchRule(\n    view.state,\n    getRules(),\n    textFull,\n    textFrom,\n    textTo,\n    ignores,\n  )\n\n  if (currMatching) {\n    return { type: 'enter', matching: currMatching }\n  }\n}\n\nfunction handleTransaction(\n  tr: Transaction,\n  prevValue: PredictionPluginState,\n  oldState: EditorState,\n  newState: EditorState,\n  getRules: () => AutocompleteRule[],\n): PredictionPluginState {\n  const meta = getTrMeta(tr)\n\n  if (\n    !meta\n    && !tr.docChanged\n    && oldState.selection.eq(newState.selection)\n  ) {\n    // No changes\n    return prevValue\n  }\n\n  // Handle position mapping changes\n  const ignoreSet = new Set<number>()\n  for (const ignore of prevValue.ignores) {\n    const result = tr.mapping.mapResult(ignore)\n    if (!result.deletedBefore && !result.deletedAfter) {\n      ignoreSet.add(result.pos)\n    }\n  }\n  const ignores = Array.from(ignoreSet)\n\n  const prevMatching = prevValue.matching && mapMatching(prevValue.matching, tr.mapping)\n\n  // If there is no new matching from `handleTextInput`\n  if (!meta) {\n    if (!prevMatching) {\n      return { matching: null, ignores }\n    }\n\n    const { selection } = newState\n    // If the text selection is before the matching or after the matching,\n    // we leave the matching\n    if (selection.to < prevMatching.from || selection.from > prevMatching.to) {\n      ignores.push(prevMatching.from)\n      return { matching: null, ignores }\n    }\n\n    // Get the text between the existing matching\n    const text = getTextBetween(newState.doc, prevMatching.from, prevMatching.to)\n    // Check the text again to see if it still matches the rule\n    const currMatching = matchRule(\n      newState,\n      getRules(),\n      text,\n      prevMatching.from,\n      prevMatching.to,\n      ignores,\n    )\n    return { matching: currMatching ?? null, ignores }\n  }\n\n  // If a new matching is being entered from `handleTextInput`\n  if (meta.type === 'enter') {\n    // Ignore the previous matching if it is not the same as the new matching\n    if (prevMatching && prevMatching.from !== meta.matching.from) {\n      ignores.push(prevMatching.from)\n    }\n\n    // Return the new matching\n    return { matching: meta.matching, ignores }\n  }\n\n  // If a matching is being exited\n  if (meta.type === 'leave') {\n    if (prevMatching) {\n      ignores.push(prevMatching.from)\n    }\n    return { matching: null, ignores }\n  }\n\n  throw new Error(`Invalid transaction meta: ${meta satisfies never}`)\n}\n\nfunction handleUpdate(view: EditorView, prevState: EditorState): void {\n  const prevValue = getPluginState(prevState)\n  const currValue = getPluginState(view.state)\n\n  if (!prevValue || !currValue) {\n    // Should not happen\n    return\n  }\n\n  const prevMatching = prevValue.matching\n  const currMatching = currValue.matching\n\n  // Deactivate the previous rule\n  if (prevMatching && prevMatching.rule !== currMatching?.rule) {\n    prevMatching.rule.onLeave?.()\n  }\n\n  // Activate the current rule\n  if (currMatching) {\n    const { from, to, match, rule } = currMatching\n\n    const textSnapshot = getTextBetween(view.state.doc, from, to)\n\n    const deleteMatch = () => {\n      if (getTextBetween(view.state.doc, from, to) === textSnapshot) {\n        view.dispatch(view.state.tr.delete(from, to))\n      }\n    }\n\n    const ignoreMatch = () => {\n      view.dispatch(\n        setTrMeta(view.state.tr, { type: 'leave' }),\n      )\n    }\n\n    rule.onMatch({\n      state: view.state,\n      match,\n      from,\n      to,\n      deleteMatch,\n      ignoreMatch,\n    })\n  }\n}\n\nfunction getDecorations(state: EditorState): DecorationSet | null {\n  const pluginState = getPluginState(state)\n  if (pluginState?.matching) {\n    const { from, to, match } = pluginState.matching\n    const deco = Decoration.inline(from, to, {\n      'class': 'prosekit-autocomplete-match',\n      'data-autocomplete-match-text': match[0],\n    })\n    return DecorationSet.create(state.doc, [deco])\n  }\n  return null\n}\n\nconst MAX_MATCH = 200\n\n/** Get the text before the given position at the current block. */\nfunction getTextBackward($pos: ResolvedPos): string {\n  const parentOffset: number = $pos.parentOffset\n  return getTextBetween(\n    $pos.parent,\n    Math.max(0, parentOffset - MAX_MATCH),\n    parentOffset,\n  )\n}\n\nfunction getTextBetween(node: ProseMirrorNode, from: number, to: number): string {\n  return node.textBetween(\n    from,\n    to,\n    null,\n    OBJECT_REPLACEMENT_CHARACTER,\n  )\n}\n\nfunction matchRule(\n  state: EditorState,\n  rules: AutocompleteRule[],\n  text: string,\n  textFrom: number,\n  textTo: number,\n  ignores: Array<number>,\n): PredictionPluginMatching | undefined {\n  // Find the rightmost ignore point within the text range\n  let maxIgnore = -1\n  for (const ignore of ignores) {\n    if (ignore >= textFrom && ignore < textTo && ignore > maxIgnore) {\n      maxIgnore = ignore\n    }\n  }\n\n  // If an ignore point is within the text range, we ignore the text to the left\n  // of the ignore point (including the character right after the ignore point).\n  if (maxIgnore >= 0) {\n    const cut = maxIgnore + 1 - textFrom\n    text = text.slice(cut)\n    textFrom += cut\n  }\n\n  if (textFrom >= textTo || !text) {\n    return\n  }\n\n  for (const rule of rules) {\n    if (!rule.canMatch({ state })) {\n      continue\n    }\n\n    rule.regex.lastIndex = 0\n    const match = rule.regex.exec(text)\n    if (!match) {\n      continue\n    }\n\n    const matchTo = textTo\n    const matchFrom = textFrom + match.index\n\n    return { rule, match, from: matchFrom, to: matchTo }\n  }\n}\n\nfunction mapMatching(matching: PredictionPluginMatching, mapping: Mapping): PredictionPluginMatching {\n  return {\n    rule: matching.rule,\n    match: matching.match,\n    from: mapping.map(matching.from),\n    to: mapping.map(matching.to, -1),\n  }\n}\n","import {\n  defineFacet,\n  defineFacetPayload,\n  pluginFacet,\n  type Extension,\n  type PluginPayload,\n} from '@prosekit/core'\n\nimport { createAutocompletePlugin } from './autocomplete-plugin'\nimport type { AutocompleteRule } from './autocomplete-rule'\n\n/**\n * Defines an autocomplete extension that executes logic when the text before\n * the cursor matches the given regular expression.\n *\n * When a match is found, an inline decoration is applied to the matched text\n * with the class `prosekit-autocomplete-match` and a `data-autocomplete-match-text`\n * attribute containing the full matched string.\n */\nexport function defineAutocomplete(rule: AutocompleteRule): Extension {\n  return defineFacetPayload(autocompleteFacet, [rule])\n}\n\nconst autocompleteFacet = defineFacet<AutocompleteRule, PluginPayload>({\n  reduce: () => {\n    let rules: AutocompleteRule[] = []\n    const getRules = () => rules\n    const plugin = createAutocompletePlugin({ getRules })\n\n    return function reducer(inputs) {\n      rules = inputs\n      return plugin\n    }\n  },\n  parent: pluginFacet,\n  singleton: true,\n})\n","import type { EditorState } from '@prosekit/pm/state'\n\nimport { defaultCanMatch } from './autocomplete-helpers'\n\n/**\n * Options for the {@link MatchHandler} callback.\n */\nexport interface MatchHandlerOptions {\n  /**\n   * The editor state.\n   */\n  state: EditorState\n\n  /**\n   * The result of `RegExp.exec`.\n   */\n  match: RegExpExecArray\n\n  /**\n   * The start position of the matched text.\n   */\n  from: number\n\n  /**\n   * The end position of the matched text.\n   */\n  to: number\n\n  /**\n   * Call this function to ignore the match. You probably want to call this\n   * function when the user presses the `Escape` key.\n   */\n  ignoreMatch: () => void\n\n  /**\n   * Call this function to delete the matched text. For example, in a slash\n   * menu, you might want to delete the matched text first then do something\n   * else when the user presses the `Enter` key.\n   */\n  deleteMatch: () => void\n}\n\n/**\n * A callback that is called when the rule starts to match, and also on\n * subsequent updates while the rule continues to match.\n */\nexport type MatchHandler = (options: MatchHandlerOptions) => void\n\n/**\n * Options for the {@link CanMatchPredicate} callback.\n */\nexport interface CanMatchOptions {\n  /**\n   * The editor state.\n   */\n  state: EditorState\n}\n\n/**\n * A predicate to determine if the rule can be applied in the current editor state.\n */\nexport type CanMatchPredicate = (options: CanMatchOptions) => boolean\n\n/**\n * Options for creating an {@link AutocompleteRule}\n */\nexport interface AutocompleteRuleOptions {\n  /**\n   * The regular expression to match against the text before the cursor. The\n   * last match before the cursor is used.\n   *\n   * For a slash menu, you might use `/(?<!\\S)\\/(\\S.*)?$/u`.\n   * For a mention, you might use `/@\\w*$/`\n   */\n  regex: RegExp\n\n  /**\n   * A callback that is called when the rule starts to match, and also on\n   * subsequent updates while the rule continues to match.\n   */\n  onEnter: MatchHandler\n\n  /**\n   * A callback that is called when the rule stops matching.\n   */\n  onLeave?: VoidFunction\n\n  /**\n   * A predicate to determine if the rule can be applied in the current editor\n   * state. If not provided, it defaults to only allowing matches that are not\n   * inside a code block or code mark.\n   */\n  canMatch?: CanMatchPredicate\n}\n\n/**\n * An autocomplete rule that can be used to create an autocomplete extension.\n *\n * @public\n */\nexport class AutocompleteRule {\n  /** @internal */\n  readonly regex: RegExp\n  /** @internal */\n  readonly onMatch: MatchHandler\n  /** @internal */\n  readonly onLeave?: VoidFunction\n  /** @internal */\n  readonly canMatch: (options: { state: EditorState }) => boolean\n\n  constructor(options: AutocompleteRuleOptions) {\n    this.regex = options.regex\n    this.onMatch = options.onEnter\n    this.onLeave = options.onLeave\n    this.canMatch = options.canMatch ?? defaultCanMatch\n  }\n}\n"],"mappings":"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"}