{"version":3,"file":"prosekit-extensions-autocomplete.js","names":["pluginKey: PluginKey<PredictionPluginState>","parentOffset: number","textBefore: string","rules: AutocompleteRule[]"],"sources":["../src/autocomplete/autocomplete-helpers.ts","../src/autocomplete/autocomplete-plugin.ts","../src/autocomplete/autocomplete.ts","../src/autocomplete/autocomplete-rule.ts"],"sourcesContent":["import type { ResolvedPos } from '@prosekit/pm/model'\nimport {\n  PluginKey,\n  type EditorState,\n  type Transaction,\n} from '@prosekit/pm/state'\n\nimport type { AutocompleteRule } from './autocomplete-rule'\n\nexport function defaultCanMatch({ state }: { state: EditorState }): boolean {\n  return state.selection.empty && !isInsideCode(state.selection.$from)\n}\n\nfunction isInsideCode($pos: ResolvedPos): boolean {\n  for (let d = $pos.depth; d > 0; d--) {\n    if ($pos.node(d).type.spec.code) {\n      return true\n    }\n  }\n\n  return $pos.marks().some((mark) => mark.type.name === 'code')\n}\n\n/**\n * @internal\n */\nexport interface PredictionPluginMatching {\n  rule: AutocompleteRule\n  from: number\n  to: number\n  match: RegExpExecArray\n}\n\n/**\n * @internal\n */\nexport interface PredictionPluginState {\n  /**\n   * The matching positions that should be ignored.\n   */\n  ignores: number[]\n\n  /**\n   * The current active matching.\n   */\n  matching: PredictionPluginMatching | null\n}\n\n/**\n * @internal\n */\ninterface PredictionTransactionMeta {\n  /**\n   * The from position that should be ignored.\n   */\n  ignore: number\n}\n\nexport function getPluginState(state: EditorState): PredictionPluginState | undefined {\n  return pluginKey.getState(state)\n}\n\nexport function getTrMeta(tr: Transaction): PredictionTransactionMeta | undefined {\n  return tr.getMeta(pluginKey) as PredictionTransactionMeta | undefined\n}\n\nexport function setTrMeta(\n  tr: Transaction,\n  meta: PredictionTransactionMeta,\n): Transaction {\n  return tr.setMeta(pluginKey, meta)\n}\n\nexport const pluginKey: PluginKey<PredictionPluginState> = new PluginKey<PredictionPluginState>('prosekit-autocomplete')\n","import { OBJECT_REPLACEMENT_CHARACTER } from '@prosekit/core'\nimport {\n  Plugin,\n  type EditorState,\n  type Transaction,\n} from '@prosekit/pm/state'\nimport {\n  Decoration,\n  DecorationSet,\n} from '@prosekit/pm/view'\n\nimport {\n  getPluginState,\n  getTrMeta,\n  pluginKey,\n  setTrMeta,\n  type PredictionPluginMatching,\n  type PredictionPluginState,\n} from './autocomplete-helpers'\nimport type { AutocompleteRule } from './autocomplete-rule'\n\nexport function createAutocompletePlugin({\n  getRules,\n}: {\n  getRules: () => AutocompleteRule[]\n}): Plugin {\n  return new Plugin<PredictionPluginState>({\n    key: pluginKey,\n\n    state: {\n      init: (): PredictionPluginState => {\n        return { ignores: [], matching: null }\n      },\n      apply: (\n        tr: Transaction,\n        prevValue: PredictionPluginState,\n        oldState: EditorState,\n        newState: EditorState,\n      ): PredictionPluginState => {\n        const meta = getTrMeta(tr)\n\n        // No changes\n        if (\n          !tr.docChanged\n          && oldState.selection.eq(newState.selection)\n          && !meta\n        ) {\n          return prevValue\n        }\n\n        // Receiving a meta means that we are ignoring a match\n        if (meta) {\n          let ignores = prevValue.ignores\n          if (!ignores.includes(meta.ignore)) {\n            ignores = [...ignores, meta.ignore]\n          }\n          return { matching: null, ignores }\n        }\n\n        // Calculate the new ignores\n        const ignoreSet = new Set(prevValue.ignores.map(pos => tr.mapping.map(pos)))\n\n        // Calculate the new matching\n        let matching = calcPluginStateMatching(newState, getRules())\n\n        // Check if the matching should be ignored\n        if (matching && ignoreSet.has(matching.from)) {\n          matching = null\n        }\n\n        // Return the new matching and ignores\n        return { matching, ignores: Array.from(ignoreSet) }\n      },\n    },\n\n    view: () => ({\n      update: (view, prevState) => {\n        const prevValue = getPluginState(prevState)\n        const currValue = getPluginState(view.state)\n\n        if (\n          prevValue?.matching\n          && prevValue.matching.rule !== currValue?.matching?.rule\n        ) {\n          // Deactivate the previous rule\n          prevValue.matching.rule.onLeave?.()\n        }\n\n        if (\n          currValue?.matching\n          && !currValue.ignores.includes(currValue.matching.from)\n        ) {\n          // Activate the current rule\n\n          const { from, to, match, rule } = currValue.matching\n\n          const textContent = view.state.doc.textBetween(\n            from,\n            to,\n            null,\n            OBJECT_REPLACEMENT_CHARACTER,\n          )\n\n          const deleteMatch = () => {\n            if (\n              view.state.doc.textBetween(\n                from,\n                to,\n                null,\n                OBJECT_REPLACEMENT_CHARACTER,\n              ) === textContent\n            ) {\n              view.dispatch(view.state.tr.delete(from, to))\n            }\n          }\n\n          const ignoreMatch = () => {\n            view.dispatch(\n              setTrMeta(view.state.tr, { ignore: from }),\n            )\n          }\n\n          rule.onMatch({\n            state: view.state,\n            match,\n            from,\n            to,\n            deleteMatch,\n            ignoreMatch,\n          })\n        }\n      },\n    }),\n\n    props: {\n      decorations: (state: EditorState) => {\n        const pluginState = getPluginState(state)\n        if (pluginState?.matching) {\n          const { from, to } = pluginState.matching\n          const deco = Decoration.inline(from, to, {\n            class: 'prosemirror-prediction-match',\n          })\n          return DecorationSet.create(state.doc, [deco])\n        }\n        return null\n      },\n    },\n  })\n}\n\nconst MAX_MATCH = 200\n\nfunction calcPluginStateMatching(\n  state: EditorState,\n  rules: AutocompleteRule[],\n): PredictionPluginMatching | null {\n  const $pos = state.selection.$from\n\n  const parentOffset: number = $pos.parentOffset\n\n  const textBefore: string = $pos.parent.textBetween(\n    Math.max(0, parentOffset - MAX_MATCH),\n    parentOffset,\n    null,\n    OBJECT_REPLACEMENT_CHARACTER,\n  )\n\n  for (const rule of rules) {\n    if (!rule.canMatch({ state })) {\n      continue\n    }\n\n    rule.regex.lastIndex = 0\n    const match = rule.regex.exec(textBefore)\n    if (!match) {\n      continue\n    }\n\n    const to = $pos.pos\n    const from = to - textBefore.length + match.index\n\n    return { rule, match, from, to }\n  }\n\n  return null\n}\n","import {\n  defineFacet,\n  defineFacetPayload,\n  pluginFacet,\n  type Extension,\n  type PluginPayload,\n} from '@prosekit/core'\n\nimport { createAutocompletePlugin } from './autocomplete-plugin'\nimport type { AutocompleteRule } from './autocomplete-rule'\n\nexport function defineAutocomplete(rule: AutocompleteRule): Extension {\n  return defineFacetPayload(autocompleteFacet, [rule])\n}\n\nconst autocompleteFacet = defineFacet<AutocompleteRule, PluginPayload>({\n  reduce: () => {\n    let rules: AutocompleteRule[] = []\n    const getRules = () => rules\n    const plugin = createAutocompletePlugin({ getRules })\n\n    return function reducer(inputs) {\n      rules = inputs\n      return plugin\n    }\n  },\n  parent: pluginFacet,\n  singleton: true,\n})\n","import type { EditorState } from '@prosekit/pm/state'\n\nimport { defaultCanMatch } from './autocomplete-helpers'\n\n/**\n * Options for the {@link MatchHandler} callback.\n */\nexport interface MatchHandlerOptions {\n  /**\n   * The editor state.\n   */\n  state: EditorState\n\n  /**\n   * The result of `RegExp.exec`.\n   */\n  match: RegExpExecArray\n\n  /**\n   * The start position of the matched text.\n   */\n  from: number\n\n  /**\n   * The end position of the matched text.\n   */\n  to: number\n\n  /**\n   * Call this function to ignore the match. You probably want to call this\n   * function when the user presses the `Escape` key.\n   */\n  ignoreMatch: () => void\n\n  /**\n   * Call this function to delete the matched text. For example, in a slash\n   * menu, you might want to delete the matched text first then do something\n   * else when the user presses the `Enter` key.\n   */\n  deleteMatch: () => void\n}\n\n/**\n * A callback that is called when the rule starts to match, and also on\n * subsequent updates while the rule continues to match.\n */\nexport type MatchHandler = (options: MatchHandlerOptions) => void\n\n/**\n * Options for the {@link CanMatchPredicate} callback.\n */\nexport interface CanMatchOptions {\n  /**\n   * The editor state.\n   */\n  state: EditorState\n}\n\n/**\n * A predicate to determine if the rule can be applied in the current editor state.\n */\nexport type CanMatchPredicate = (options: CanMatchOptions) => boolean\n\n/**\n * Options for creating an {@link AutocompleteRule}\n */\nexport interface AutocompleteRuleOptions {\n  /**\n   * The regular expression to match against the text before the cursor. The\n   * last match before the cursor is used.\n   *\n   * For a slash menu, you might use `/(?<!\\S)\\/(|\\S.*)$/u`.\n   * For a mention, you might use `/@\\w*$/`\n   */\n  regex: RegExp\n\n  /**\n   * A callback that is called when the rule starts to match, and also on\n   * subsequent updates while the rule continues to match.\n   */\n  onEnter: MatchHandler\n\n  /**\n   * A callback that is called when the rule stops matching.\n   */\n  onLeave?: VoidFunction\n\n  /**\n   * A predicate to determine if the rule can be applied in the current editor\n   * state. If not provided, it defaults to only allowing matches in empty\n   * selections that are not inside a code block or code mark.\n   */\n  canMatch?: CanMatchPredicate\n}\n\n/**\n * An autocomplete rule that can be used to create an autocomplete extension.\n *\n * @public\n */\nexport class AutocompleteRule {\n  /** @internal */\n  readonly regex: RegExp\n  /** @internal */\n  readonly onMatch: MatchHandler\n  /** @internal */\n  readonly onLeave?: VoidFunction\n  /** @internal */\n  readonly canMatch: (options: { state: EditorState }) => boolean\n\n  constructor(options: AutocompleteRuleOptions) {\n    this.regex = options.regex\n    this.onMatch = options.onEnter\n    this.onLeave = options.onLeave\n    this.canMatch = options.canMatch ?? defaultCanMatch\n  }\n}\n"],"mappings":"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"}