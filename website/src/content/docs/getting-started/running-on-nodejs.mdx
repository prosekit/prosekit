---
title: Running on Node.js
sidebar:
  order: 60
---

import { Aside } from '@astrojs/starlight/components';

ProseKit's core works in a Node.js runtime for background jobs, CLI tools, or Server-Side Rendering (SSR). The only limitation is that **any API that touches the DOM is unavailable** unless you provide a DOM implementation yourself.

## Create an editor in Node.js

You can create an editor and run commands exactly as you would in the browser:

```ts twoslash
import { createEditor } from 'prosekit/core'
import { defineBasicExtension } from 'prosekit/basic'

const extension = defineBasicExtension()
const editor = createEditor({ extension })

// Set content with JSON
editor.setContent({
  type: 'doc',
  content: [
    { type: 'paragraph', content: [{ type: 'text', text: 'Hello, Node.js!' }] },
  ],
})

// Run commands
editor.commands.insertImage({
  src: 'https://example.com/logo.png',
  width: 120,
  height: 60,
})

// Get the document as JSON
const json = editor.getDocJSON()
console.log(json)
```

## DOM-related APIs are off-limits

In a raw Node.js process there is **no DOM**, so helper methods that depend on it throw immediately:

```ts twoslash
import { createEditor } from 'prosekit/core'
import { defineBasicExtension } from 'prosekit/basic'

const extension = defineBasicExtension()
const editor = createEditor({ extension })

// ---cut---
// ❌ Mounting doesn't work
editor.mount(document.createElement('div'))
// ❌ ProseKit cannot serialize HTML without DOM APIs
editor.getDocHTML()
// ❌ ProseKit cannot parse HTML without DOM APIs
editor.setContent('<p>HTML input</p>')
```

The following two strategies show how to work around the lack of DOM APIs on the server.

## SSR strategy 1: pre-render in the browser

The simplest way to render ProseKit content on the server is **not to render it on the server at all**: let the browser convert the document to HTML and store that string.

```ts twoslash
import { createEditor } from 'prosekit/core'
import { defineBasicExtension } from 'prosekit/basic'

const extension = defineBasicExtension()
const editor = createEditor({ extension })

// ---cut---
// Browser code
const html = editor.getDocHTML()
await fetch('/api/save', { method: 'POST', body: html })
```

On the backend you simply serve that static HTML—no DOM required.

## SSR strategy 2: simulate a DOM on the server

If you need to convert JSON ⇢ HTML inside Node.js, you can plug in a *headless* DOM such as **jsdom** or **happy-dom**.

### Using jsdom

```ts
import { JSDOM } from 'jsdom'

// Set up a virtual DOM
const dom = new JSDOM('')
const document = dom.window.document

editor.setContent({
  type: 'doc',
  content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Foo' }] }],
})
editor.commands.insertText({ text: 'Bar' })

// Pass the `document` to `getDocHTML`
const html = editor.getDocHTML({ document })
console.log(html) // => <div><p>BarFoo</p></div>
```

### Using happy-dom

```ts
import { Window } from 'happy-dom'

// Set up a virtual DOM
const window = new Window()
const document = window.document

const editor = createEditor({ extension: defineBasicExtension() })
editor.setContent({
  type: 'doc',
  content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Foo' }] }],
})
editor.commands.insertText({ text: 'Bar' })

// Pass the `document` to `getDocHTML`
const html = editor.getDocHTML({ document })
console.log(html) // => <div><p>BarFoo</p></div>
```

<Aside type="note">
  A headless DOM is *good enough* for most use cases but may not perfectly match how browsers render the same document.
</Aside> 
