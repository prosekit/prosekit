{"version":3,"file":"paste-rule-DIEJKIje.js","names":["handlers: PasteRulePayload[]","chunks: Array<[string, RegExpExecArray | undefined]>","match: RegExpExecArray | null","children: ProseMirrorNode[]","newChildren: ProseMirrorNode[]","nodes: ProseMirrorNode[]","text"],"sources":["../src/paste-rule/paste-rule-plugin.ts","../src/paste-rule/paste-rule.ts","../src/paste-rule/split-text-by-regex.ts","../src/paste-rule/mark-paste-rule.ts"],"sourcesContent":["import {\n  defineFacet,\n  defineFacetPayload,\n  pluginFacet,\n  type PlainExtension,\n  type PluginPayload,\n} from '@prosekit/core'\nimport type { Slice } from '@prosekit/pm/model'\nimport {\n  PluginKey,\n  ProseMirrorPlugin,\n} from '@prosekit/pm/state'\nimport type { EditorView } from '@prosekit/pm/view'\n\ntype PasteRulePayload = (options: { slice: Slice; view: EditorView; plain: boolean }) => Slice\n\n/**\n * @internal\n */\nconst pasteRuleFacet = defineFacet<PasteRulePayload, PluginPayload>({\n  reduce: () => {\n    let handlers: PasteRulePayload[] = []\n\n    const transformPasted = (slice: Slice, view: EditorView, plain: boolean): Slice => {\n      for (const handler of handlers) {\n        slice = handler({ slice, view, plain })\n      }\n      return slice\n    }\n\n    const plugin = new ProseMirrorPlugin({\n      key: new PluginKey('prosekit-paste-rule'),\n      props: {\n        transformPasted,\n      },\n    })\n\n    return (inputs: PasteRulePayload[]) => {\n      // Last added rule (highest priority) is applied first\n      handlers = [...inputs].reverse()\n      return plugin\n    }\n  },\n  singleton: true,\n  parent: pluginFacet,\n})\n\n/**\n * @internal\n */\nexport function definePasteRulePlugin(payload: PasteRulePayload): PlainExtension {\n  return defineFacetPayload(pasteRuleFacet, [payload]) as PlainExtension\n}\n","import type { PlainExtension } from '@prosekit/core'\nimport type { Slice } from '@prosekit/pm/model'\nimport type { EditorView } from '@prosekit/pm/view'\n\nimport { definePasteRulePlugin } from './paste-rule-plugin'\n\n/**\n * @public\n *\n * Options for {@link PasteRuleHandler}.\n */\nexport interface PasteRuleHandlerOptions {\n  /**\n   * The slice to be pasted.\n   */\n  slice: Slice\n\n  /**\n   * The editor view.\n   */\n  view: EditorView\n\n  /**\n   * Whether the pasted content is treated as plain text. This is true when the\n   * `Shift` key is held when pasting.\n   */\n  plain: boolean\n}\n\n/**\n * @public\n *\n * Can be used to transform pasted or dragged-and-dropped content before it is\n * applied to the document.\n */\nexport type PasteRuleHandler = (options: PasteRuleHandlerOptions) => Slice\n\n/**\n * Options for {@link definePasteRule}.\n *\n * @public\n */\nexport interface PasteRuleOptions {\n  /**\n   * A function to be called when a paste rule is triggered.\n   */\n  handler: PasteRuleHandler\n}\n\n/**\n * Defines a paste rule. This rule allows you to modify pasted or dragged\n * content before it is inserted into the document.\n *\n * @param options\n *\n * @public\n */\nexport function definePasteRule({ handler }: PasteRuleOptions): PlainExtension {\n  return definePasteRulePlugin(handler)\n}\n","/**\n * Splits text into chunks based on regex matches, preserving both matched and unmatched segments.\n * Returns an array of tuples where each tuple contains a text segment and either the match data\n * (for matched segments) or undefined (for unmatched segments).\n */\nexport function splitTextByRegex(\n  text: string,\n  regex: RegExp,\n): Array<[string, RegExpExecArray | undefined]> | undefined {\n  regex.lastIndex = 0\n\n  const chunks: Array<[string, RegExpExecArray | undefined]> = []\n  let lastIndex = 0\n  let match: RegExpExecArray | null\n  let matched = false\n\n  while ((match = regex.exec(text))) {\n    const start = match.index\n    const end = regex.lastIndex\n\n    // Push the unmatched prefix, if any.\n    if (start > lastIndex) {\n      chunks.push([text.slice(lastIndex, start), undefined])\n    }\n\n    // Push the matched segment.\n    chunks.push([text.slice(start, end), match])\n    matched = true\n\n    if (lastIndex === end) {\n      // Safeguard against zero-width matches that would otherwise cause an infinite loop.\n      return\n    }\n    lastIndex = end\n  }\n\n  if (matched && lastIndex < text.length) {\n    chunks.push([text.slice(lastIndex), undefined])\n  }\n\n  regex.lastIndex = 0\n\n  return matched ? chunks : undefined\n}\n","import {\n  getMarkType,\n  type PlainExtension,\n} from '@prosekit/core'\nimport type {\n  Attrs,\n  MarkType,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\nimport {\n  Fragment,\n  Slice,\n} from '@prosekit/pm/model'\n\nimport { definePasteRule } from './paste-rule'\nimport { splitTextByRegex } from './split-text-by-regex'\n\n/**\n * The options for {@link defineMarkPasteRule}.\n *\n * @public\n */\nexport interface MarkPasteRuleOptions {\n  /**\n   * The regular expression to match against. It must have a `g` flag to match\n   * all instances of the mark.\n   */\n  regex: RegExp\n\n  /**\n   * The mark type to apply to the matched text.\n   */\n  type: string | MarkType\n\n  /**\n   * A function used to compute attributes to set on the mark created by this\n   * rule. When it returns `false`, the rule won't match. When it returns `null`\n   * or `undefined`, that is interpreted as an empty/default set of attributes.\n   * @default null\n   */\n  getAttrs?: (match: RegExpExecArray) => Attrs | null | undefined | false\n\n  /**\n   * Optional function to determine if a text node should be skipped.\n   * Default behavior: skip code nodes and nodes that already have the target mark.\n   */\n  shouldSkip?: (node: ProseMirrorNode) => boolean\n}\n\n/**\n * Defines a paste rule that applies marks based on regex patterns.\n *\n * @public\n */\nexport function defineMarkPasteRule(options: MarkPasteRuleOptions): PlainExtension {\n  return definePasteRule({\n    handler: ({ slice, view, plain }) => {\n      if (plain) {\n        return slice\n      }\n\n      const markType = getMarkType(view.state.schema, options.type)\n\n      return replaceMarkInSlice({\n        markType,\n        regex: options.regex,\n        getAttrs: options.getAttrs,\n        shouldSkip: options.shouldSkip,\n      }, slice)\n    },\n  })\n}\n\ninterface MarkPasteRuleHandlerOptions {\n  markType: MarkType\n  regex: RegExp\n  getAttrs?: (match: RegExpExecArray) => Attrs | null | undefined | false\n  shouldSkip?: (node: ProseMirrorNode) => boolean\n}\n\nfunction replaceMarkInSlice(options: MarkPasteRuleHandlerOptions, slice: Slice): Slice {\n  const newFragment = replaceMarkInFragment(options, slice.content)\n  if (!newFragment) {\n    return slice\n  }\n  return new Slice(newFragment, slice.openStart, slice.openEnd)\n}\n\nfunction replaceMarkInFragment(options: MarkPasteRuleHandlerOptions, fragment: Fragment): Fragment | undefined {\n  let changed = false\n  let children: ProseMirrorNode[] = []\n\n  for (const child of fragment.content) {\n    const newChild = replaceMarkInNode(options, child)\n    if (newChild) {\n      changed = true\n    }\n    children.push(newChild || child)\n  }\n\n  if (changed) {\n    return Fragment.from(children)\n  }\n\n  return\n}\n\nfunction replaceMarkInNode(options: MarkPasteRuleHandlerOptions, node: ProseMirrorNode): ProseMirrorNode | undefined {\n  if (node.type.spec.code) {\n    return\n  }\n  if (node.type.isInline) {\n    return\n  }\n  if (node.type.isTextblock) {\n    return replaceMarkInTextblockNode(options, node)\n  }\n\n  const newChildren = replaceMarkInFragment(options, node.content)\n  if (!newChildren) {\n    return\n  }\n  return node.copy(newChildren)\n}\n\nfunction replaceMarkInTextblockNode(options: MarkPasteRuleHandlerOptions, node: ProseMirrorNode): ProseMirrorNode | undefined {\n  const newChildren: ProseMirrorNode[] = []\n  let changed = false\n\n  for (const inlineNode of node.content.content) {\n    const newInlineNodes = replaceMarkInInlineNode(options, inlineNode)\n    if (newInlineNodes) {\n      changed = true\n      newChildren.push(...newInlineNodes)\n    } else {\n      newChildren.push(inlineNode)\n    }\n  }\n  if (changed) {\n    return node.copy(Fragment.from(newChildren))\n  }\n  return\n}\n\nfunction replaceMarkInInlineNode(options: MarkPasteRuleHandlerOptions, node: ProseMirrorNode): ProseMirrorNode[] | undefined {\n  const text = node.text\n  if (!text) {\n    return\n  }\n\n  const { markType, shouldSkip } = options\n\n  // Use custom skip logic if provided, otherwise use default\n  if (shouldSkip) {\n    if (shouldSkip(node)) {\n      return\n    }\n  } else {\n    // Default skip logic: skip if already has the target mark or has code mark\n    if (node.marks.some((mark) => mark.type === markType)) {\n      return\n    }\n    if (node.marks.some((mark) => mark.type.spec.code)) {\n      return\n    }\n  }\n\n  const chunks = splitTextByRegex(text, options.regex)\n  if (!chunks) {\n    return\n  }\n\n  const schema = node.type.schema\n  const nodes: ProseMirrorNode[] = []\n\n  for (const [text, match] of chunks) {\n    if (!text) {\n      continue\n    }\n    if (match) {\n      const attrs = options.getAttrs?.(match) ?? null\n      if (attrs !== false) {\n        const mark = markType.create(attrs)\n        nodes.push(schema.text(text, [...node.marks, mark]))\n      } else {\n        nodes.push(schema.text(text, node.marks))\n      }\n    } else {\n      nodes.push(schema.text(text, node.marks))\n    }\n  }\n\n  return nodes\n}\n"],"mappings":"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"}