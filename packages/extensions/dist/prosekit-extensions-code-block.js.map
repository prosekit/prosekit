{"version":3,"file":"prosekit-extensions-code-block.js","names":[],"sources":["../src/code-block/code-block-commands.ts","../src/code-block/code-block-highlight.ts","../src/code-block/code-block-input-rule.ts","../src/code-block/code-block-keymap.ts","../src/code-block/shiki-highlighter.ts","../src/code-block/shiki-parser.ts","../src/code-block/code-block-shiki.ts","../src/code-block/code-block-spec.ts","../src/code-block/code-block.ts"],"sourcesContent":["import { defineCommands, insertNode, setBlockType, setNodeAttrs, toggleNode, type Extension } from '@prosekit/core'\n\nimport type { CodeBlockAttrs } from './code-block-types.ts'\n\n/**\n * @internal\n */\nexport type CodeBlockCommandsExtension = Extension<{\n  Commands: {\n    setCodeBlock: [attrs?: CodeBlockAttrs]\n    insertCodeBlock: [attrs?: CodeBlockAttrs]\n    toggleCodeBlock: [attrs?: CodeBlockAttrs]\n    setCodeBlockAttrs: [attrs: CodeBlockAttrs]\n  }\n}>\n\n/**\n * Adds commands for working with `codeBlock` nodes.\n *\n * @public\n */\nexport function defineCodeBlockCommands(): CodeBlockCommandsExtension {\n  return defineCommands({\n    setCodeBlock: (attrs?: CodeBlockAttrs) => {\n      return setBlockType({ type: 'codeBlock', attrs })\n    },\n    insertCodeBlock: (attrs?: CodeBlockAttrs) => {\n      return insertNode({ type: 'codeBlock', attrs })\n    },\n    toggleCodeBlock: (attrs?: CodeBlockAttrs) => {\n      return toggleNode({ type: 'codeBlock', attrs })\n    },\n    setCodeBlockAttrs: (attrs: CodeBlockAttrs) => {\n      return setNodeAttrs({ type: 'codeBlock', attrs })\n    },\n  })\n}\n","import { definePlugin, type Extension } from '@prosekit/core'\nimport { createHighlightPlugin, type Parser } from 'prosemirror-highlight'\n\n/**\n * @public\n *\n * An alias for the `Parser` type from the `prosemirror-highlight` package.\n */\nexport type HighlightParser = Parser\n\n/**\n * @public\n */\nexport type CodeBlockHighlightOptions = {\n  /**\n   * A parser instance from the `prosemirror-highlight` package.\n   */\n  parser: HighlightParser\n  /**\n   * ProseMirror node types to highlight.\n   *\n   * @default ['codeBlock', 'mathBlock']\n   */\n  nodeTypes?: string[]\n}\n\n/**\n * Adds syntax highlighting to code blocks. This function requires a `Parser`\n * instance from the `prosemirror-highlight` package. See the\n * [documentation](https://github.com/ocavue/prosemirror-highlight) for more\n * information.\n *\n * @param options\n *\n * @public\n */\nexport function defineCodeBlockHighlight({\n  parser,\n  nodeTypes = ['codeBlock', 'mathBlock'],\n}: CodeBlockHighlightOptions): Extension {\n  return definePlugin(\n    createHighlightPlugin({ parser, nodeTypes }),\n  )\n}\n","import type { PlainExtension } from '@prosekit/core'\n\nimport { defineTextBlockEnterRule } from '../enter-rule/index.ts'\nimport { defineTextBlockInputRule } from '../input-rule/index.ts'\n\nimport type { CodeBlockAttrs } from './code-block-types.ts'\n\n/**\n * Adds input rules for `codeBlock` nodes.\n *\n * @public\n */\nexport function defineCodeBlockInputRule(): PlainExtension {\n  return defineTextBlockInputRule({\n    regex: /^```(\\S*)\\s$/,\n    type: 'codeBlock',\n    attrs: getAttrs,\n  })\n}\n\n/**\n * Adds enter rules for `codeBlock` nodes.\n *\n * @public\n */\nexport function defineCodeBlockEnterRule(): PlainExtension {\n  return defineTextBlockEnterRule({\n    regex: /^```(\\S*)$/,\n    type: 'codeBlock',\n    attrs: getAttrs,\n  })\n}\n\nfunction getAttrs(match: RegExpMatchArray): CodeBlockAttrs {\n  return { language: match[1] || '' }\n}\n","import { defaultBlockAt, defineKeymap, type PlainExtension } from '@prosekit/core'\nimport { TextSelection, type Command } from '@prosekit/pm/state'\n\n/**\n * Defines the keymap for code blocks.\n */\nexport function defineCodeBlockKeymap(): PlainExtension {\n  return defineKeymap({\n    Enter: existCodeBlock,\n  })\n}\n\n/**\n * Exit a code block and insert a default block below if the cursor is at the\n * end of the code block and the code block is ended with two new lines.\n */\nconst existCodeBlock: Command = (state, dispatch) => {\n  if (!state.selection.empty) {\n    return false\n  }\n\n  const { $head } = state.selection\n  const parent = $head.parent\n  if (\n    parent.isTextblock\n    && parent.type.spec.code\n    && $head.parentOffset === parent.content.size\n    && parent.textContent.endsWith('\\n\\n')\n  ) {\n    const grandParent = $head.node(-1)\n    const insertIndex = $head.indexAfter(-1)\n    const type = defaultBlockAt(grandParent.contentMatchAt(insertIndex))\n\n    if (!type || !grandParent.canReplaceWith(insertIndex, insertIndex, type)) {\n      return false\n    }\n\n    if (dispatch) {\n      const { tr } = state\n      tr.delete($head.pos - 2, $head.pos)\n      const pos = tr.selection.$head.after()\n      const node = type.createAndFill()\n      if (node) {\n        tr.replaceWith(pos, pos, node)\n        tr.setSelection(TextSelection.near(tr.doc.resolve(pos), 1))\n        dispatch(tr.scrollIntoView())\n      }\n    }\n\n    return true\n  }\n\n  return false\n}\n","import type { HighlighterOptions, HighlighterResult } from './shiki-highlighter-chunk.ts'\n\nlet loaded: ((options: HighlighterOptions) => HighlighterResult) | undefined\n\nasync function load() {\n  const { createOrGetHighlighter } = await import('./shiki-highlighter-chunk.ts')\n  loaded = createOrGetHighlighter\n}\n\nexport function createOrGetHighlighter(\n  options: HighlighterOptions,\n): HighlighterResult {\n  if (!loaded) {\n    return { promise: load() }\n  }\n  return loaded(options)\n}\n\nexport type { HighlighterOptions }\n","import type { Parser } from 'prosemirror-highlight'\nimport { createParser } from 'prosemirror-highlight/shiki'\n\nimport type { ShikiBundledLanguage } from './shiki-bundle.ts'\nimport { createOrGetHighlighter, type HighlighterOptions } from './shiki-highlighter.ts'\n\n/**\n * @internal\n */\nexport function createLazyParser(\n  highlighterOptions: HighlighterOptions,\n): Parser {\n  let parser: Parser | undefined\n\n  return function lazyParser(options) {\n    const language = (options.language || '') as ShikiBundledLanguage\n    const { highlighter, promise } = createOrGetHighlighter({\n      ...highlighterOptions,\n      langs: [language],\n    })\n\n    if (!highlighter) {\n      return promise\n    }\n\n    if (!parser) {\n      parser = createParser(highlighter, {\n        theme: highlighterOptions.themes[0],\n      })\n    }\n    return parser(options)\n  }\n}\n","import type { Extension } from '@prosekit/core'\nimport type { SpecialLanguage } from 'shiki'\n\nimport { defineCodeBlockHighlight } from './code-block-highlight.ts'\nimport type { ShikiBundledLanguage, ShikiBundledTheme } from './shiki-bundle.ts'\nimport type { ShikiHighlighterOptions } from './shiki-highlighter-chunk.ts'\nimport { createLazyParser } from './shiki-parser.ts'\n\n/**\n * The options to configure the Shiki highlighter.\n *\n * @public\n */\nexport interface CodeBlockShikiOptions extends Omit<ShikiHighlighterOptions, 'themes' | 'langs' | 'engine'> {\n  /**\n   * ProseMirror node types to highlight.\n   *\n   * @default ['codeBlock', 'mathBlock']\n   */\n  nodeTypes?: string[]\n\n  /**\n   * A list of Shiki themes to pre-load. The first theme in the list will be\n   * used to render the code block.\n   *\n   * @default ['one-dark-pro']\n   */\n  themes?: ShikiBundledTheme[]\n\n  /**\n   * A list of Shiki languages to pre-load.\n   *\n   * @default ['text']\n   */\n  langs?: (ShikiBundledLanguage | SpecialLanguage)[]\n\n  /**\n   * The RegExp engine to use. By default, the JavaScript engine is used.\n   */\n  engine?: ShikiHighlighterOptions['engine']\n}\n\n/**\n * Adds syntax highlighting to code blocks using the [Shiki](https://github.com/shikijs/shiki) package.\n *\n * It will set two CSS variables on the code block elements:\n *\n * - `--prosemirror-highlight`: sets text color\n * - `--prosemirror-highlight-bg`: sets background color\n *\n * @param options - The options to configure the Shiki highlighter.\n *\n * @public\n */\nexport function defineCodeBlockShiki({\n  nodeTypes,\n  themes = ['one-dark-pro'],\n  langs = ['text'],\n  ...rest\n}: CodeBlockShikiOptions = {}): Extension {\n  const parser = createLazyParser({ themes, langs, ...rest })\n  return defineCodeBlockHighlight({ parser, nodeTypes })\n}\n","import { defineNodeSpec, type Extension } from '@prosekit/core'\n\nimport type { CodeBlockAttrs } from './code-block-types.ts'\n\n/**\n * @internal\n */\nexport type CodeBlockSpecExtension = Extension<{\n  Nodes: {\n    codeBlock: CodeBlockAttrs\n  }\n}>\n\n/**\n * Defines the `codeBlock` node spec.\n *\n * @public\n */\nexport function defineCodeBlockSpec(): CodeBlockSpecExtension {\n  return defineNodeSpec({\n    name: 'codeBlock',\n    content: 'text*',\n    group: 'block',\n    code: true,\n    defining: true,\n    marks: '',\n    attrs: { language: { default: '', validate: 'string' } },\n    parseDOM: [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n        getAttrs: (node): CodeBlockAttrs => {\n          const language = extractLanguageFromElement(node)\n            || extractLanguageFromElement(node.querySelector('code'))\n          return { language }\n        },\n      },\n    ],\n    toDOM(node) {\n      const { language } = node.attrs as CodeBlockAttrs\n      return [\n        'pre',\n        { 'data-language': language || undefined },\n        // `class: language-${language}` is used by remark-rehype to highlight the code block\n        ['code', { class: language ? `language-${language}` : undefined }, 0],\n      ]\n    },\n  })\n}\n\nfunction extractLanguageFromElement(element: HTMLElement | null | undefined): string {\n  if (!element) {\n    return ''\n  }\n\n  const attr = element.getAttribute('data-language')\n  if (attr) {\n    return attr\n  }\n\n  const className = element.className\n  const match = className.match(/language-(\\w+)/)\n  if (match) {\n    return match[1]\n  }\n\n  return ''\n}\n","import { union, type Union } from '@prosekit/core'\n\nimport { defineCodeBlockCommands, type CodeBlockCommandsExtension } from './code-block-commands.ts'\nimport { defineCodeBlockEnterRule, defineCodeBlockInputRule } from './code-block-input-rule.ts'\nimport { defineCodeBlockKeymap } from './code-block-keymap.ts'\nimport { defineCodeBlockSpec, type CodeBlockSpecExtension } from './code-block-spec.ts'\n\n/**\n * @internal\n */\nexport type CodeBlockExtension = Union<\n  [CodeBlockSpecExtension, CodeBlockCommandsExtension]\n>\n\n/**\n * Adds `codeBlock` nodes to the editor. This includes the following extensions:\n *\n * - {@link defineCodeBlockSpec}\n * - {@link defineCodeBlockInputRule}\n * - {@link defineCodeBlockEnterRule}\n * - {@link defineCodeBlockKeymap}\n * - {@link defineCodeBlockCommands}.\n *\n * @public\n */\nexport function defineCodeBlock(): CodeBlockExtension {\n  return union(\n    defineCodeBlockSpec(),\n    defineCodeBlockInputRule(),\n    defineCodeBlockEnterRule(),\n    defineCodeBlockKeymap(),\n    defineCodeBlockCommands(),\n  )\n}\n"],"mappings":"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"}