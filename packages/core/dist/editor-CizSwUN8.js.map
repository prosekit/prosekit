{"version":3,"file":"editor-CizSwUN8.js","names":["_reducer?: FacetReducer<Input, Output> | undefined","_reduce?: () => FacetReducer<Input, Output>","schema: Schema | undefined","commands: CommandCreators | undefined","stateFunc: ((ctx: { schema: Schema }) => EditorStateConfig) | undefined","view: Omit<DirectEditorProps, 'state'> | undefined","rootFacet: Facet<RootPayload, RootOutput>","schemaFacet: Facet<SchemaSpec, RootPayload>","node: FacetNode | undefined","facet: Facet<I, O>","inputs: Tuple5<I[] | null>","children: Map<number, FacetNode>","reducers: Tuple5<FacetReducer<I, O> | null>","output: Tuple5<O | null>","input: I[]","facet: Facet<Input, Output>","payloads: Input[]","inputs: Tuple5<Input[] | null>","node: FacetNode","stateFacet: Facet<StatePayload, RootPayload>","callbacks: StatePayload[]","state: StatePayload","config: EditorStateConfig","document","config: EditorStateConfig","node","defaultApplyMark: ApplyMarkFunction","defaultCreateNode: CreateNodeFunction","nodes: Array<ProseMirrorNode>","extension: BaseExtension[]","children: FacetNode[]","extensions: Extension[]","state","DOMSerializer","lazyRemove: VoidFunction | null","action: CommandAction<Args>"],"sources":["../src/error.ts","../src/utils/get-mark-type.ts","../src/utils/assert.ts","../src/utils/get-node-type.ts","../src/utils/attrs-match.ts","../src/utils/is-node-active.ts","../src/types/priority.ts","../src/facets/facet.ts","../src/facets/root.ts","../src/facets/schema.ts","../src/facets/base-extension.ts","../src/utils/array.ts","../src/utils/type-assertion.ts","../src/facets/facet-node.ts","../src/facets/facet-extension.ts","../src/facets/state.ts","../src/utils/get-dom-api.ts","../src/utils/parse.ts","../src/utils/editor-content.ts","../src/extensions/default-state.ts","../src/utils/deep-equals.ts","../src/utils/is-subset.ts","../src/utils/includes-mark.ts","../src/utils/is-mark-absent.ts","../src/utils/is-mark-active.ts","../src/editor/action.ts","../src/facets/union-extension.ts","../src/editor/union.ts","../src/editor/editor.ts"],"sourcesContent":["/**\n * Base class for all ProseKit errors.\n *\n * @internal\n */\nexport class ProseKitError extends Error {}\n\n/**\n * @internal\n */\nexport class EditorNotFoundError extends ProseKitError {\n  constructor() {\n    super(\n      'Unable to find editor. Pass it as an argument or call this function inside a ProseKit component.',\n    )\n  }\n}\n\n/**\n * @internal\n */\nexport class DOMDocumentNotFoundError extends ProseKitError {\n  constructor() {\n    super(\n      'Unable to find browser Document. When not in the browser environment, you need to pass a DOM Document.',\n    )\n  }\n}\n","import type {\n  MarkType,\n  Schema,\n} from '@prosekit/pm/model'\n\nimport { ProseKitError } from '../error'\n\n/**\n * @internal\n */\nexport function getMarkType(schema: Schema, type: string | MarkType): MarkType {\n  if (typeof type === 'string') {\n    const markType = schema.marks[type]\n    if (!markType) {\n      throw new ProseKitError(`Cannot find mark type \"${type}\"`)\n    }\n    return markType\n  }\n  return type\n}\n","import { ProseKitError } from '../error'\n\n/**\n * @internal\n */\nexport function assert(\n  condition: unknown,\n  message = 'Assertion failed',\n): asserts condition {\n  if (!condition) {\n    throw new ProseKitError(message)\n  }\n}\n","import type {\n  NodeType,\n  Schema,\n} from '@prosekit/pm/model'\n\nimport { ProseKitError } from '../error'\n\n/**\n * @internal\n */\nexport function getNodeType(schema: Schema, type: string | NodeType): NodeType {\n  if (typeof type === 'string') {\n    const nodeType = schema.nodes[type]\n    if (!nodeType) {\n      throw new ProseKitError(`Cannot find ProseMirror node type \"${type}\"`)\n    }\n    return nodeType\n  }\n  return type\n}\n","import type {\n  Attrs,\n  Mark,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\n\nexport function attrsMatch(\n  nodeOrMark: ProseMirrorNode | Mark,\n  attrs: Attrs,\n): boolean {\n  const currentAttrs = nodeOrMark.attrs\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (currentAttrs[key] !== value) {\n      return false\n    }\n  }\n\n  return true\n}\n","import type {\n  Attrs,\n  NodeType,\n} from '@prosekit/pm/model'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport { attrsMatch } from './attrs-match'\nimport { getNodeType } from './get-node-type'\n\nexport function isNodeActive(\n  state: EditorState,\n  type: string | NodeType,\n  attrs?: Attrs | null,\n): boolean {\n  const $pos = state.selection.$from\n  const nodeType = getNodeType(state.schema, type)\n\n  for (let depth = $pos.depth; depth >= 0; depth--) {\n    const node = $pos.node(depth)\n    if (node.type === nodeType && (!attrs || attrsMatch(node, attrs))) {\n      return true\n    }\n  }\n  return false\n}\n","/**\n * ProseKit extension priority.\n *\n * @public\n */\nexport enum Priority {\n  lowest = 0,\n  low = 1,\n  default = 2,\n  high = 3,\n  highest = 4,\n}\n","import { assert } from '../utils/assert'\n\nimport type { FacetReducer } from './facet-types'\n\nlet facetCount = 0\n\n/**\n * @internal\n */\nexport class Facet<Input, Output> {\n  /**\n   * @internal\n   */\n  readonly index: number = facetCount++\n  /**\n   * @internal\n   */\n  readonly parent: Facet<Output, any> | null\n  /**\n   * @internal\n   */\n  readonly singleton: boolean\n  /**\n   * A index path to retrieve the current facet in a tree from the root.\n   *\n   * @internal\n   */\n  readonly path: number[]\n\n  /**\n   * @internal\n   */\n  constructor(\n    parent: Facet<Output, any> | null,\n    singleton: boolean,\n    private _reducer?: FacetReducer<Input, Output> | undefined,\n    private _reduce?: () => FacetReducer<Input, Output>,\n  ) {\n    // Only one of _reducer or _reduce can be defined\n    assert((_reduce || _reducer) && !(_reduce && _reducer))\n\n    this.parent = parent\n    this.singleton = singleton\n    this.path = parent ? [...parent.path, this.index] : []\n  }\n\n  get reducer(): FacetReducer<Input, Output> {\n    return (this._reducer ?? this._reduce?.())!\n  }\n}\n\n/**\n * @internal\n */\nexport function defineFacet<Input, Output>(options: {\n  /**\n   * The parent facet in the tree.\n   */\n  parent: Facet<Output, any>\n\n  /**\n   * Set this to true if you only want to keep one facet payload. For example,\n   * this facet corresponds to a ProseMirror plugin with a key.\n   */\n  singleton?: boolean\n\n  /**\n   * A reducer is a function that accepts an array of input and produce a single\n   * output.\n   */\n  reducer?: FacetReducer<Input, Output>\n  /**\n   * A callback function that returns a reducer. This is useful if you want to\n   * store something in the closure.\n   */\n  reduce?: () => FacetReducer<Input, Output>\n}): Facet<Input, Output> {\n  return new Facet(\n    options.parent,\n    options.singleton ?? false,\n    options.reducer,\n    options.reduce,\n  )\n}\n","import type { Schema } from '@prosekit/pm/model'\nimport type { EditorStateConfig } from '@prosekit/pm/state'\nimport type { DirectEditorProps } from '@prosekit/pm/view'\n\nimport type { CommandCreators } from '../types/extension-command'\n\nimport { Facet } from './facet'\n\nexport type RootPayload = {\n  schema?: Schema | null\n  commands?: CommandCreators\n  state?: (ctx: { schema: Schema }) => EditorStateConfig\n  view?: Omit<DirectEditorProps, 'state'>\n}\n\nexport type RootOutput = {\n  schema?: Schema | null\n  commands?: CommandCreators\n  state?: EditorStateConfig\n  view?: Omit<DirectEditorProps, 'state'>\n}\n\nfunction rootReducer(inputs: RootPayload[]): RootOutput {\n  let schema: Schema | undefined\n  let commands: CommandCreators | undefined\n  let stateFunc: ((ctx: { schema: Schema }) => EditorStateConfig) | undefined\n  let view: Omit<DirectEditorProps, 'state'> | undefined\n\n  for (const input of inputs) {\n    schema = input.schema || schema\n    commands = input.commands || commands\n    stateFunc = input.state || stateFunc\n    view = input.view || view\n  }\n\n  const state = schema && (stateFunc?.({ schema }) ?? { schema })\n\n  return { schema, state, commands, view }\n}\n\nexport const rootFacet: Facet<RootPayload, RootOutput> = new Facet<\n  RootPayload,\n  RootOutput\n>(null, true, rootReducer)\n","import {\n  Schema,\n  type SchemaSpec,\n} from '@prosekit/pm/model'\n\nimport { assert } from '../utils/assert'\n\nimport {\n  defineFacet,\n  type Facet,\n} from './facet'\nimport {\n  rootFacet,\n  type RootPayload,\n} from './root'\n\nexport const schemaFacet: Facet<SchemaSpec, RootPayload> = defineFacet({\n  reducer: (specs) => {\n    assert(specs.length <= 1)\n    const spec = specs[0]\n    const schema = spec ? new Schema(spec) : null\n    return { schema }\n  },\n  parent: rootFacet,\n  singleton: true,\n})\n","import type { Schema } from '@prosekit/pm/model'\n\nimport type {\n  Extension,\n  ExtensionTyping,\n} from '../types/extension'\nimport { Priority } from '../types/priority'\n\nimport type { Facet } from './facet'\nimport type { FacetNode } from './facet-node'\nimport type { Tuple5 } from './facet-types'\nimport { schemaFacet } from './schema'\n\n/**\n * @internal\n */\nexport abstract class BaseExtension<T extends ExtensionTyping = ExtensionTyping> implements Extension<T> {\n  abstract extension: Extension | Extension[]\n  priority?: Priority\n  _type?: T\n\n  private trees: Tuple5<FacetNode | null> = [null, null, null, null, null]\n\n  /**\n   * @internal\n   */\n  abstract createTree(priority: Priority): FacetNode\n\n  /**\n   * @internal\n   */\n  getTree(priority?: Priority): FacetNode {\n    const pri = priority ?? this.priority ?? Priority.default\n    return (this.trees[pri] ||= this.createTree(pri))\n  }\n\n  /**\n   * @internal\n   */\n  findFacetOutput<I, O>(facet: Facet<I, O>): Tuple5<O | null> | null {\n    let node: FacetNode | undefined = this.getTree()\n\n    for (const index of facet.path) {\n      node = node?.children.get(index)\n    }\n\n    return node?.getOutput() ?? null\n  }\n\n  get schema(): Schema | null {\n    const output = this.findFacetOutput(schemaFacet)\n    return output?.find(Boolean)?.schema ?? null\n  }\n}\n","export function uniqPush<T>(prev: readonly T[], next: readonly T[]): T[] {\n  const result = [...prev]\n\n  for (const item of next) {\n    if (!result.includes(item)) {\n      result.push(item)\n    }\n  }\n  return result\n}\n\n/**\n * @internal\n */\nexport function arraySubtract<T>(a: T[], b: T[]): T[] {\n  return a.filter((x) => !b.includes(x))\n}\n\nexport function toReversed<T>(arr: T[]): T[] {\n  return arr.toReversed?.() ?? [...arr].reverse()\n}\n","import {\n  Fragment,\n  Mark,\n  ProseMirrorNode,\n  Slice,\n} from '@prosekit/pm/model'\nimport {\n  AllSelection,\n  NodeSelection,\n  Selection,\n  TextSelection,\n} from '@prosekit/pm/state'\n\n/**\n * Checks if the given object is a {@link ProseMirrorNode} instance.\n */\nexport function isProseMirrorNode(value: unknown): value is ProseMirrorNode {\n  return value instanceof ProseMirrorNode\n}\n\n/**\n * Checks if the given object is a {@link Mark} instance.\n *\n * @public\n */\nexport function isMark(value: unknown): value is Mark {\n  return value instanceof Mark\n}\n\n/**\n * Checks if the given object is a {@link Fragment} instance.\n *\n * @public\n */\nexport function isFragment(value: unknown): value is Fragment {\n  return value instanceof Fragment\n}\n\n/**\n * Checks if the given object is a {@link Slice} instance.\n *\n * @public\n */\nexport function isSlice(value: unknown): value is Slice {\n  return value instanceof Slice\n}\n\n/**\n * Checks if the given object is a {@link Selection} instance.\n *\n * @public\n */\nexport function isSelection(value: unknown): value is Selection {\n  return value instanceof Selection\n}\n\n/**\n * Checks if the given object is a {@link TextSelection} instance.\n *\n * @public\n */\nexport function isTextSelection(value: Selection): value is TextSelection {\n  return value instanceof TextSelection\n}\n\n/**\n * Checks if the given object is a {@link NodeSelection} instance.\n *\n * @public\n */\nexport function isNodeSelection(value: Selection): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n\n/**\n * Checks if the given object is a {@link AllSelection} instance.\n *\n * @public\n */\nexport function isAllSelection(value: Selection): value is AllSelection {\n  return value instanceof AllSelection\n}\n\n/**\n * @internal\n */\nexport function isNotNullish<T>(\n  value: T | null | undefined,\n): value is T {\n  return value != null\n}\n","import { Priority } from '../types/priority'\nimport {\n  arraySubtract,\n  uniqPush,\n} from '../utils/array'\nimport { assert } from '../utils/assert'\nimport { isNotNullish } from '../utils/type-assertion'\n\nimport type { Facet } from './facet'\nimport type {\n  FacetReducer,\n  Tuple5,\n} from './facet-types'\nimport type { RootOutput } from './root'\n\nfunction zip5<T>(\n  a: Tuple5<T>,\n  b: Tuple5<T>,\n  mapper: (a: T, b: T) => T,\n): Tuple5<T> {\n  return [\n    mapper(a[0], b[0]),\n    mapper(a[1], b[1]),\n    mapper(a[2], b[2]),\n    mapper(a[3], b[3]),\n    mapper(a[4], b[4]),\n  ]\n}\n\nfunction unionInput<T>(a: T[] | null, b: T[] | null): T[] | null {\n  if (!a && !b) return null\n  return uniqPush(a ?? [], b ?? [])\n}\n\nfunction subtractInput<T>(a: T[] | null, b: T[] | null): T[] | null {\n  if (!a) return null\n  if (!b) return [...a]\n  return arraySubtract(a, b)\n}\n\nfunction unionChildren(\n  a: Map<number, FacetNode>,\n  b: Map<number, FacetNode>,\n): Map<number, FacetNode> {\n  const merged = new Map(a)\n  for (const [key, valueB] of b.entries()) {\n    const valueA = a.get(key)\n    merged.set(key, valueA ? unionFacetNode(valueA, valueB) : valueB)\n  }\n  return merged\n}\n\nfunction subtractChildren(\n  a: Map<number, FacetNode>,\n  b: Map<number, FacetNode>,\n): Map<number, FacetNode> {\n  const merged = new Map(a)\n  for (const [key, valueB] of b.entries()) {\n    const valueA = a.get(key)\n    if (valueA) {\n      merged.set(key, subtractFacetNode(valueA, valueB))\n    }\n  }\n  return merged\n}\n\n/**\n * Takes two facet nodes and returns a new facet node containing inputs and\n * children from both nodes.\n *\n * The reducers of the first facet node will be reused.\n *\n * @internal\n */\nexport function unionFacetNode<I, O>(\n  a: FacetNode<I, O>,\n  b: FacetNode<I, O>,\n): FacetNode<I, O> {\n  assert(a.facet === b.facet)\n  return new FacetNode(\n    a.facet,\n    zip5(a.inputs, b.inputs, unionInput),\n    unionChildren(a.children, b.children),\n    a.reducers,\n  )\n}\n\n/**\n * Takes two facet nodes and returns a new facet node containing inputs and\n * children from the first node but not the second.\n *\n * The reducers of the first facet node will be reused.\n *\n * @internal\n */\nexport function subtractFacetNode<I, O>(\n  a: FacetNode<I, O>,\n  b: FacetNode<I, O>,\n): FacetNode<I, O> {\n  assert(a.facet === b.facet)\n  return new FacetNode(\n    a.facet,\n    zip5(a.inputs, b.inputs, subtractInput),\n    subtractChildren(a.children, b.children),\n    a.reducers,\n  )\n}\n\nexport class FacetNode<I = any, O = any> {\n  output: Tuple5<O | null> | null = null\n\n  constructor(\n    readonly facet: Facet<I, O>,\n    readonly inputs: Tuple5<I[] | null> = [null, null, null, null, null],\n    readonly children: Map<number, FacetNode> = new Map(),\n    readonly reducers: Tuple5<FacetReducer<I, O> | null> = [\n      null,\n      null,\n      null,\n      null,\n      null,\n    ],\n  ) {}\n\n  private calcOutput(): Tuple5<O | null> {\n    const inputs: Tuple5<I[] | null> = [null, null, null, null, null]\n    const output: Tuple5<O | null> = [null, null, null, null, null]\n\n    for (let pri = 0; pri < 5; pri++) {\n      const input = this.inputs[pri]\n      if (input) {\n        inputs[pri] = [...input]\n      }\n    }\n\n    for (const child of this.children.values()) {\n      const childOutput = child.getOutput()\n      for (let pri = 0; pri < 5; pri++) {\n        if (childOutput[pri]) {\n          const input = (inputs[pri] ||= [])\n          input.push(childOutput[pri] as I)\n        }\n      }\n    }\n\n    if (this.facet.singleton) {\n      const reducer = (this.reducers[Priority.default] ||= this.facet.reducer)\n      const input: I[] = inputs.filter(isNotNullish).flat()\n      output[Priority.default] = reducer(input)\n    } else {\n      for (let pri = 0; pri < 5; pri++) {\n        const input = inputs[pri]\n        if (input) {\n          const reducer = (this.reducers[pri] ||= this.facet.reducer)\n          output[pri] = reducer(input)\n        }\n      }\n    }\n\n    return output\n  }\n\n  getOutput(): Tuple5<O | null> {\n    if (!this.output) {\n      this.output = this.calcOutput()\n    }\n    return this.output\n  }\n\n  getSingletonOutput(): O | null {\n    assert(this.facet.singleton)\n    return this.getOutput()[Priority.default]\n  }\n\n  getRootOutput(): RootOutput {\n    assert(this.isRoot())\n    const output = this.getSingletonOutput()\n    assert(output)\n    return output\n  }\n\n  isRoot(): boolean {\n    return !this.facet.parent\n  }\n}\n","import type { Extension } from '../types/extension'\nimport type { Priority } from '../types/priority'\n\nimport { BaseExtension } from './base-extension'\nimport type { Facet } from './facet'\nimport { FacetNode } from './facet-node'\nimport type { Tuple5 } from './facet-types'\n\n/**\n * @internal\n */\nexport class FacetExtensionImpl<Input, Output> extends BaseExtension {\n  declare extension: Extension\n\n  /**\n   * @internal\n   */\n  constructor(\n    readonly facet: Facet<Input, Output>,\n    readonly payloads: Input[],\n  ) {\n    super()\n  }\n\n  /**\n   * @internal\n   */\n  createTree(priority: Priority): FacetNode {\n    const pri = this.priority ?? priority\n\n    const inputs: Tuple5<Input[] | null> = [null, null, null, null, null]\n    inputs[pri] = [...this.payloads]\n\n    let node: FacetNode = new FacetNode(this.facet, inputs)\n\n    while (node.facet.parent) {\n      const children = new Map([[node.facet.index, node]])\n      node = new FacetNode(node.facet.parent, undefined, children)\n    }\n\n    return node\n  }\n}\n\n/**\n * @internal\n */\nexport function defineFacetPayload<Input>(\n  facet: Facet<Input, any>,\n  payloads: Input[],\n): Extension {\n  return new FacetExtensionImpl(facet, payloads)\n}\n","import type { Schema } from '@prosekit/pm/model'\nimport type { EditorStateConfig } from '@prosekit/pm/state'\n\nimport { uniqPush } from '../utils/array'\nimport { assert } from '../utils/assert'\n\nimport {\n  defineFacet,\n  type Facet,\n} from './facet'\nimport {\n  rootFacet,\n  type RootPayload,\n} from './root'\n\nexport type StatePayload = (ctx: { schema: Schema }) => EditorStateConfig\n\nexport const stateFacet: Facet<StatePayload, RootPayload> = defineFacet({\n  reduce: () => {\n    let callbacks: StatePayload[] = []\n\n    const state: StatePayload = (ctx) => {\n      const configs = callbacks.map((cb) => cb(ctx))\n      const config: EditorStateConfig = {\n        schema: ctx.schema,\n        storedMarks: [],\n        plugins: [],\n      }\n\n      for (const c of configs) {\n        config.schema = config.schema ?? c.schema\n        config.doc = config.doc ?? c.doc\n        config.selection = config.selection ?? c.selection\n        config.storedMarks = [...config.storedMarks!, ...(c.storedMarks ?? [])]\n        config.plugins = uniqPush(config.plugins ?? [], c.plugins ?? [])\n      }\n\n      assert(\n        config.doc || config.schema,\n        \"Can't create state without a schema nor a document\",\n      )\n\n      if (config.doc) {\n        config.schema = undefined\n      }\n\n      return config\n    }\n\n    return function reducer(inputs) {\n      callbacks = inputs\n      return { state }\n    }\n  },\n  singleton: true,\n  parent: rootFacet,\n})\n","import { DOMDocumentNotFoundError } from '../error'\n\nfunction findGlobalBrowserDocument() {\n  if (typeof document !== 'undefined') {\n    return document\n  }\n\n  if (typeof globalThis !== 'undefined' && globalThis.document) {\n    return globalThis.document\n  }\n}\n\nfunction findGlobalBrowserWindow() {\n  if (typeof window !== 'undefined') {\n    return window\n  }\n\n  if (typeof globalThis !== 'undefined' && globalThis.window) {\n    return globalThis.window\n  }\n}\n\nfunction findBrowserDocument(options?: { document?: Document }): Document | undefined {\n  return (\n    options?.document\n      ?? findGlobalBrowserDocument()\n      ?? findGlobalBrowserWindow()?.document\n  )\n}\n\nfunction findBrowserWindow(options?: {\n  document?: Document\n}): (Window & typeof globalThis) | undefined {\n  return (\n    options?.document?.defaultView\n      ?? findGlobalBrowserWindow()\n      ?? findBrowserDocument(options)?.defaultView\n      ?? undefined\n  )\n}\n\nexport function getBrowserDocument(options?: {\n  document?: Document\n}): Document {\n  const doc = findBrowserDocument(options)\n  if (doc) return doc\n  throw new DOMDocumentNotFoundError()\n}\n\nexport function getBrowserWindow(options?: {\n  document?: Document\n}): Window & typeof globalThis {\n  const win = findBrowserWindow(options)\n  if (win) return win\n  throw new DOMDocumentNotFoundError()\n}\n","import {\n  DOMParser,\n  DOMSerializer,\n  type ParseOptions,\n  type ProseMirrorNode,\n  type Schema,\n} from '@prosekit/pm/model'\nimport { EditorState } from '@prosekit/pm/state'\n\nimport type { DOMNode } from '../types/dom-node'\nimport type {\n  NodeJSON,\n  StateJSON,\n} from '../types/model'\n\nimport {\n  getBrowserDocument,\n  getBrowserWindow,\n} from './get-dom-api'\n\n/** @public */\nexport interface DOMParserOptions extends ParseOptions {\n  DOMParser?: typeof DOMParser\n}\n\n/** @public */\nexport interface DOMSerializerOptions {\n  DOMSerializer?: { fromSchema: typeof DOMSerializer.fromSchema }\n}\n\n/** @public */\nexport interface DOMDocumentOptions {\n  /**\n   * The Document object to use for DOM operations. If not provided, defaults to\n   * the current browser's document object. Useful for server-side rendering or\n   * testing environments.\n   */\n  document?: Document\n}\n\n/** @public */\nexport interface JSONParserOptions {\n  /**\n   * The editor schema to use.\n   */\n  schema: Schema\n}\n\n/////////////// JSON <=> State ///////////////\n\n/**\n * Return a JSON object representing this state.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const state = editor.state\n * const json = jsonFromState(state)\n * ```\n */\nexport function jsonFromState(state: EditorState): StateJSON {\n  return state.toJSON() as StateJSON\n}\n\n/**\n * Parse a JSON object to a ProseMirror state.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { state: { type: 'doc', content: [{ type: 'paragraph' }], selection: { type: 'text', from: 1, to: 1 } } }\n * const state = stateFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function stateFromJSON(\n  json: StateJSON,\n  options: JSONParserOptions,\n): EditorState {\n  return EditorState.fromJSON({ schema: options.schema }, json)\n}\n\n/////////////// JSON <=> Node ///////////////\n\n/**\n * Return a JSON object representing this node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const node = editor.state.doc\n * const json = jsonFromNode(node)\n * ```\n */\nexport function jsonFromNode(node: ProseMirrorNode): NodeJSON {\n  return node.toJSON() as NodeJSON\n}\n\n/**\n * Parse a JSON object to a ProseMirror node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { type: 'doc', content: [{ type: 'paragraph' }] }\n * const node = nodeFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function nodeFromJSON(\n  json: NodeJSON,\n  options: JSONParserOptions,\n): ProseMirrorNode {\n  return options.schema.nodeFromJSON(json)\n}\n\n/////////////// Node <=> Element ///////////////\n\n/**\n * Parse a HTML element to a ProseMirror node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const element = document.getElementById('content')\n * const node = nodeFromElement(element, { schema: editor.schema })\n * ```\n */\nexport function nodeFromElement(\n  element: DOMNode,\n  options: DOMParserOptions & JSONParserOptions,\n): ProseMirrorNode {\n  const { DOMParser: CustomDOMParser, schema, ...parseOptions } = options\n  return (CustomDOMParser || DOMParser)\n    .fromSchema(schema)\n    .parse(element, parseOptions)\n}\n\n/**\n * Serialize a ProseMirror node to a HTML element.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const node = editor.state.doc\n * const element = elementFromNode(node)\n * ```\n */\nexport function elementFromNode(\n  node: ProseMirrorNode,\n  options?: DOMSerializerOptions & DOMDocumentOptions,\n): HTMLElement {\n  const Serializer = options?.DOMSerializer || DOMSerializer\n  const document = getBrowserDocument(options)\n  const schema = node.type.schema\n  const serializer = Serializer.fromSchema(schema)\n\n  if (schema.topNodeType !== node.type) {\n    return serializer.serializeNode(node, { document }) as HTMLElement\n  } else {\n    return serializer.serializeFragment(\n      node.content,\n      { document },\n      document.createElement('div'),\n    ) as HTMLElement\n  }\n}\n\n/////////////// Element <=> HTML ///////////////\n\n/**\n * Parse a HTML string to a HTML element.\n *\n * @internal\n */\nexport function elementFromHTML(\n  html: string,\n  options?: DOMDocumentOptions,\n): HTMLElement {\n  const win = getBrowserWindow(options)\n  const parser = new win.DOMParser()\n  return parser.parseFromString(`<body><div>${html}</div></body>`, 'text/html')\n    .body.firstElementChild as HTMLElement\n}\n\n/**\n * @internal\n */\nfunction htmlFromElement(element: HTMLElement): string {\n  return element.outerHTML\n}\n\n/////////////// Node <=> HTML ///////////////\n\n/**\n * Parse a HTML string to a ProseMirror node.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const html = '<p>Hello, world!</p>'\n * const node = nodeFromHTML(html, { schema: editor.schema })\n * ```\n */\nexport function nodeFromHTML(\n  html: string,\n  options: DOMParserOptions & JSONParserOptions & DOMDocumentOptions,\n): ProseMirrorNode {\n  return nodeFromElement(elementFromHTML(html, options), options)\n}\n\n/**\n * Serialize a ProseMirror node to a HTML string\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const node = document.getElementById('content')\n * const html = htmlFromNode(node)\n * ```\n */\nexport function htmlFromNode(\n  node: ProseMirrorNode,\n  options?: DOMSerializerOptions & DOMDocumentOptions,\n): string {\n  return elementFromNode(node, options).outerHTML\n}\n\n/////////////// JSON <=> Element ///////////////\n\n/**\n * Serialize a HTML element to a ProseMirror document JSON object.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const element = document.getElementById('content')\n * const json = jsonFromElement(element, { schema: editor.schema })\n * ```\n */\nexport function jsonFromElement(\n  element: DOMNode,\n  options: DOMParserOptions & JSONParserOptions,\n): NodeJSON {\n  return jsonFromNode(nodeFromElement(element, options))\n}\n\n/**\n * Parse a ProseMirror document JSON object to a HTML element.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { type: 'doc', content: [{ type: 'paragraph' }] }\n * const element = elementFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function elementFromJSON(\n  json: NodeJSON,\n  options: JSONParserOptions & DOMSerializerOptions & DOMDocumentOptions,\n): HTMLElement {\n  return elementFromNode(nodeFromJSON(json, options), options)\n}\n\n/////////////// JSON <=> HTML ///////////////\n\n/**\n * Parse a HTML string to a ProseMirror document JSON object.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const html = '<p>Hello, world!</p>'\n * const json = jsonFromHTML(html, { schema: editor.schema })\n * ```\n */\nexport function jsonFromHTML(\n  html: string,\n  options: DOMDocumentOptions & DOMParserOptions & JSONParserOptions,\n): NodeJSON {\n  return jsonFromElement(elementFromHTML(html, options), options)\n}\n\n/**\n * Parse a ProseMirror document JSON object to a HTML string.\n *\n * @public\n *\n * @example\n *\n * ```ts\n * const json = { type: 'doc', content: [{ type: 'paragraph' }] }\n * const html = htmlFromJSON(json, { schema: editor.schema })\n * ```\n */\nexport function htmlFromJSON(\n  json: NodeJSON,\n  options: JSONParserOptions & DOMSerializerOptions & DOMDocumentOptions,\n): string {\n  return htmlFromElement(elementFromJSON(json, options))\n}\n","import { isElementLike } from '@ocavue/utils'\nimport type {\n  ProseMirrorNode,\n  Schema,\n} from '@prosekit/pm/model'\nimport { Selection } from '@prosekit/pm/state'\n\nimport type {\n  NodeJSON,\n  SelectionJSON,\n} from '../types/model'\n\nimport { assert } from './assert'\nimport {\n  jsonFromElement,\n  jsonFromHTML,\n} from './parse'\nimport {\n  isProseMirrorNode,\n  isSelection,\n} from './type-assertion'\n\nexport function getEditorContentJSON(\n  schema: Schema,\n  content: NodeJSON | string | HTMLElement,\n): NodeJSON {\n  if (typeof content === 'string') {\n    return jsonFromHTML(content, { schema })\n  } else if (isElementLike(content)) {\n    return jsonFromElement(content, { schema })\n  } else {\n    return content\n  }\n}\n\nfunction getEditorContentNode(\n  schema: Schema,\n  content: NodeJSON | string | HTMLElement | ProseMirrorNode,\n): ProseMirrorNode {\n  if (isProseMirrorNode(content)) {\n    return content\n  }\n  return schema.nodeFromJSON(getEditorContentJSON(schema, content))\n}\n\nexport function getEditorContentDoc(\n  schema: Schema,\n  content: NodeJSON | string | HTMLElement | ProseMirrorNode,\n): ProseMirrorNode {\n  const doc = getEditorContentNode(schema, content)\n  assert(\n    doc.type.schema === schema,\n    'Document schema does not match editor schema',\n  )\n  assert(\n    doc.type === schema.topNodeType,\n    `Document type does not match editor top node type. Expected ${schema.topNodeType.name}, got ${doc.type.name}`,\n  )\n  return doc\n}\n\nexport function getEditorSelection(\n  doc: ProseMirrorNode,\n  selection: SelectionJSON | Selection | 'start' | 'end',\n): Selection {\n  if (isSelection(selection)) {\n    assert(selection.$head.doc === doc, 'Selection and doc do not match')\n    return selection\n  }\n  if (selection === 'start') {\n    return Selection.atStart(doc)\n  }\n  if (selection === 'end') {\n    return Selection.atEnd(doc)\n  }\n  return Selection.fromJSON(doc, selection)\n}\n","import {\n  Selection,\n  type EditorStateConfig,\n} from '@prosekit/pm/state'\n\nimport { defineFacetPayload } from '../facets/facet-extension'\nimport { stateFacet } from '../facets/state'\nimport type { PlainExtension } from '../types/extension'\nimport type {\n  NodeJSON,\n  SelectionJSON,\n} from '../types/model'\nimport { getEditorContentJSON } from '../utils/editor-content'\n\n/**\n * @public\n */\nexport interface DefaultStateOptions {\n  /**\n   * The starting document to use when creating the editor. It can be a\n   * ProseMirror node JSON object, a HTML string, or a HTML element instance.\n   */\n  defaultContent?: NodeJSON | string | HTMLElement\n\n  /**\n   * A JSON object representing the starting document to use when creating the\n   * editor.\n   *\n   * @deprecated Use `defaultContent` instead.\n   */\n  defaultDoc?: NodeJSON\n\n  /**\n   * A HTML element or a HTML string representing the starting document to use\n   * when creating the editor.\n   *\n   * @deprecated Use `defaultContent` instead.\n   */\n  defaultHTML?: string | HTMLElement\n\n  /**\n   * A JSON object representing the starting selection to use when creating the\n   * editor. It's only used when `defaultContent` is also provided.\n   */\n  defaultSelection?: SelectionJSON\n}\n\n/**\n * Define a default state for the editor.\n *\n * @param options\n *\n * @public\n */\nexport function defineDefaultState({\n  defaultSelection,\n  defaultContent,\n  defaultDoc,\n  defaultHTML,\n}: DefaultStateOptions): PlainExtension {\n  const defaultDocContent = defaultContent || defaultDoc || defaultHTML\n\n  return defineFacetPayload(stateFacet, [\n    ({ schema }) => {\n      const config: EditorStateConfig = {}\n      if (defaultDocContent) {\n        const json = getEditorContentJSON(schema, defaultDocContent)\n        config.doc = schema.nodeFromJSON(json)\n        if (defaultSelection) {\n          config.selection = Selection.fromJSON(config.doc, defaultSelection)\n        }\n      }\n      return config\n    },\n  ]) as PlainExtension\n}\n","import OrderedMap from 'orderedmap'\n\nexport function deepEquals<T>(a: T, b: T): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (!a || !b) {\n    return false\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((x, i) => deepEquals(x, b[i]))\n  }\n\n  if (a instanceof OrderedMap && b instanceof OrderedMap) {\n    return a.size === b.size && deepEquals(a.toObject(), b.toObject())\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    return (\n      aKeys.length === bKeys.length\n      && aKeys.every((key) => deepEquals(a[key as keyof T], b[key as keyof T]))\n    )\n  }\n  return false\n}\n","/**\n * Check if `subset` is a subset of `superset`.\n *\n * @internal\n */\nexport function isSubset(\n  subset: Record<string, unknown>,\n  superset: Record<string, unknown>,\n): boolean {\n  return Object.keys(subset).every((key) => subset[key] === superset[key])\n}\n","import type {\n  Attrs,\n  Mark,\n  MarkType,\n} from '@prosekit/pm/model'\n\nimport { isSubset } from './is-subset'\n\nexport function includesMark(\n  marks: readonly Mark[],\n  markType: MarkType,\n  attrs?: Attrs | null,\n): boolean {\n  attrs = attrs || {}\n  return marks.some((mark) => {\n    return mark.type === markType && isSubset(attrs, mark.attrs)\n  })\n}\n","import type {\n  Attrs,\n  MarkType,\n  ProseMirrorNode,\n} from '@prosekit/pm/model'\n\nimport { includesMark } from './includes-mark'\n\n/**\n * Returns true if the given mark is missing in some part of the range.\n * Returns false if the entire range has the given mark.\n * Returns true if the mark is not allowed in the range.\n *\n * @internal\n */\nexport function isMarkAbsent(\n  node: ProseMirrorNode,\n  from: number,\n  to: number,\n  markType: MarkType,\n  attrs?: Attrs | null,\n): boolean {\n  let missing = false\n  let available = false\n\n  node.nodesBetween(from, to, (node, pos, parent) => {\n    if (missing) {\n      return false\n    }\n\n    const allowed = parent?.type.allowsMarkType(markType)\n      && !node.marks.some((m) => m.type !== markType && m.type.excludes(markType))\n\n    if (allowed) {\n      available = true\n      if (!includesMark(node.marks, markType, attrs)) {\n        missing = true\n      }\n    }\n  })\n  return available ? missing : true\n}\n","import type {\n  Attrs,\n  MarkType,\n} from '@prosekit/pm/model'\nimport type { EditorState } from '@prosekit/pm/state'\n\nimport { getMarkType } from './get-mark-type'\nimport { includesMark } from './includes-mark'\nimport { isMarkAbsent } from './is-mark-absent'\n\n/**\n * @internal\n */\nexport function isMarkActive(\n  state: EditorState,\n  type: string | MarkType,\n  attrs?: Attrs | null,\n): boolean {\n  const { from, $from, to, empty } = state.selection\n  const markType = getMarkType(state.schema, type)\n  if (empty) {\n    const marks = state.storedMarks || $from.marks()\n    return includesMark(marks, markType, attrs)\n  } else {\n    return !isMarkAbsent(state.doc, from, to, markType, attrs)\n  }\n}\n","import type {\n  Attrs,\n  Mark,\n  MarkType,\n  NodeType,\n  ProseMirrorNode,\n  Schema,\n} from '@prosekit/pm/model'\nimport type { EditorState } from '@prosekit/pm/state'\nimport mapValues from 'just-map-values'\n\nimport { ProseKitError } from '../error'\nimport type { AnyAttrs } from '../types/attrs'\nimport { assert } from '../utils/assert'\nimport { isMarkActive } from '../utils/is-mark-active'\nimport { isNodeActive } from '../utils/is-node-active'\nimport { isProseMirrorNode } from '../utils/type-assertion'\n\n/**\n * Available children parameters for {@link NodeAction} and {@link MarkAction}.\n *\n * @public\n */\nexport type NodeChild = ProseMirrorNode | string | NodeChild[]\n\n/**\n * A function for creating a node with optional attributes and any number of\n * children.\n *\n * It also has a `isActive` method for checking if the node is active in the\n * current editor selection.\n *\n * @public\n */\nexport interface NodeAction<Attrs extends AnyAttrs = AnyAttrs> {\n  /**\n   * Creates a node with attributes and any number of children.\n   */\n  (attrs: Attrs | null, ...children: NodeChild[]): ProseMirrorNode\n\n  /**\n   * Creates a node with any number of children.\n   */\n  (...children: NodeChild[]): ProseMirrorNode\n\n  /**\n   * Checks if the node is active in the current editor selection. If the\n   * optional `attrs` parameter is provided, it will check if the node is active\n   * with the given attributes.\n   */\n  isActive: (attrs?: Attrs) => boolean\n}\n\n/**\n * A function for applying a mark with optional attributes and any number of\n * children.\n *\n * It also has a `isActive` method for checking if the mark is active in the\n * current editor selection.\n *\n * @public\n */\nexport interface MarkAction<Attrs extends AnyAttrs = AnyAttrs> {\n  /**\n   * Applies a mark with attributes and any number of children.\n   */\n  (attrs: Attrs | null, ...children: NodeChild[]): ProseMirrorNode[]\n\n  /**\n   * Applies a mark with any number of children.\n   */\n  (...children: NodeChild[]): ProseMirrorNode[]\n\n  /**\n   * Checks if the mark is active in the current editor selection. If the\n   * optional `attrs` parameter is provided, it will check if the mark is active\n   * with the given attributes.\n   */\n  isActive: (attrs?: Attrs) => boolean\n}\n\n/**\n * @deprecated Use type {@link NodeAction} instead.\n */\nexport type NodeBuilder = NodeAction\n\n/**\n * @deprecated Use type {@link MarkAction} instead.\n */\nexport type MarkBuilder = MarkAction\n\n/**\n * @internal\n */\nexport function createNodeActions(\n  schema: Schema,\n  getState: GetStateFunction,\n  createNode: CreateNodeFunction = defaultCreateNode,\n): Record<string, NodeAction> {\n  return mapValues(schema.nodes, (type) => createNodeAction(type, getState, createNode))\n}\n\nfunction createNodeAction(\n  type: NodeType,\n  getState: GetStateFunction,\n  createNode: CreateNodeFunction,\n): NodeAction {\n  const action = (\n    ...args: [Attrs | NodeChild | null | undefined, ...NodeChild[]]\n  ) => buildNode(type, args, createNode)\n  action.isActive = (attrs?: Attrs) => {\n    const state = getState()\n    return state ? isNodeActive(state, type, attrs) : false\n  }\n  return action\n}\n\n/**\n * @internal\n */\nexport function createMarkActions(\n  schema: Schema,\n  getState: GetStateFunction,\n  applyMark: ApplyMarkFunction = defaultApplyMark,\n): Record<string, MarkAction> {\n  return mapValues(schema.marks, (type) => createMarkAction(type, getState, applyMark))\n}\n\nfunction createMarkAction(\n  type: MarkType,\n  getState: GetStateFunction,\n  applyMark: ApplyMarkFunction,\n): MarkAction {\n  const action = (\n    ...args: [Attrs | NodeChild | null | undefined, ...NodeChild[]]\n  ) => buildMark(type, args, applyMark)\n  action.isActive = (attrs?: Attrs) => {\n    const state = getState()\n    return state ? isMarkActive(state, type, attrs) : false\n  }\n  return action\n}\n\nfunction buildMark(\n  type: MarkType,\n  args: [Attrs | NodeChild | null | undefined, ...NodeChild[]],\n  applyMark: ApplyMarkFunction,\n): ProseMirrorNode[] {\n  const [attrs, children] = normalizeArgs(args)\n  const mark = type.create(attrs)\n  return applyMark(mark, flattenChildren(type.schema, children))\n}\n\n/**\n * @internal\n */\nexport type ApplyMarkFunction = (\n  mark: Mark,\n  children: ProseMirrorNode[],\n) => ProseMirrorNode[]\n\nconst defaultApplyMark: ApplyMarkFunction = (\n  mark: Mark,\n  children: ProseMirrorNode[],\n): ProseMirrorNode[] => {\n  return children.map((node) => node.mark(mark.addToSet(node.marks)))\n}\n\nfunction buildNode(\n  type: NodeType,\n  args: [Attrs | NodeChild | null | undefined, ...NodeChild[]],\n  createNode: CreateNodeFunction,\n): ProseMirrorNode {\n  const [attrs, children] = normalizeArgs(args)\n  return createNode(type, attrs, flattenChildren(type.schema, children))\n}\n\n/**\n * @internal\n */\nexport type CreateNodeFunction = (\n  type: NodeType,\n  attrs: Attrs | null,\n  children: ProseMirrorNode[],\n) => ProseMirrorNode\n\ntype GetStateFunction = () => EditorState | null | undefined\n\nconst defaultCreateNode: CreateNodeFunction = (\n  type: NodeType,\n  attrs: Attrs | null,\n  children: ProseMirrorNode[],\n) => {\n  const node = type.createAndFill(attrs, children)\n  assert(node, `Failed to create node ${type.name}`)\n  return node\n}\n\nfunction flattenChildren(\n  schema: Schema,\n  children: NodeChild[],\n): Array<ProseMirrorNode> {\n  const nodes: Array<ProseMirrorNode> = []\n\n  for (const child of children) {\n    if (typeof child === 'string') {\n      if (child) {\n        nodes.push(schema.text(child, null))\n      }\n    } else if (Array.isArray(child)) {\n      nodes.push(...flattenChildren(schema, child))\n    } else if (isProseMirrorNode(child)) {\n      nodes.push(child)\n    } else {\n      throw new ProseKitError(`Invalid node child: ${typeof child}`)\n    }\n  }\n\n  return nodes\n}\n\nfunction normalizeArgs(\n  args: [Attrs | NodeChild | null | undefined, ...NodeChild[]],\n): [Attrs | null, NodeChild[]] {\n  const [attrs, ...children] = args\n  if (isNodeChild(attrs)) {\n    children.unshift(attrs)\n    return [null, children]\n  } else if (typeof attrs === 'object') {\n    return [attrs, children]\n  } else {\n    return [null, children]\n  }\n}\n\nfunction isNodeChild(\n  value: Attrs | NodeChild | null | undefined,\n): value is NodeChild {\n  if (!value) {\n    return false\n  }\n\n  return (\n    typeof value === 'string'\n    || Array.isArray(value)\n    || isProseMirrorNode(value)\n  )\n}\n","import type {\n  Extension,\n  ExtensionTyping,\n} from '../types/extension'\nimport type { Priority } from '../types/priority'\nimport { assert } from '../utils/assert'\n\nimport { BaseExtension } from './base-extension'\nimport {\n  unionFacetNode,\n  type FacetNode,\n} from './facet-node'\n\nexport class UnionExtensionImpl<T extends ExtensionTyping = ExtensionTyping> extends BaseExtension<T> implements Extension<T> {\n  /**\n   * @internal\n   */\n  constructor(public extension: BaseExtension[] = []) {\n    super()\n  }\n\n  /**\n   * @internal\n   */\n  createTree(priority: Priority): FacetNode {\n    const pri = this.priority ?? priority\n\n    const extensions = [...this.extension]\n    extensions.sort((a, b) => (a.priority ?? pri) - (b.priority ?? pri))\n\n    const children: FacetNode[] = extensions.map((ext) => ext.getTree(pri))\n\n    assert(children.length > 0)\n\n    let node = children[0]\n    for (let i = 1; i < children.length; i++) {\n      node = unionFacetNode(node, children[i])\n    }\n    return node\n  }\n}\n","import type { BaseExtension } from '../facets/base-extension'\nimport { UnionExtensionImpl } from '../facets/union-extension'\nimport type {\n  Extension,\n  Union,\n} from '../types/extension'\nimport { assert } from '../utils/assert'\n\n/**\n * Merges multiple extensions into one. You can pass multiple extensions as\n * arguments or a single array containing multiple extensions.\n *\n * @throws If no extensions are provided.\n *\n * @example\n *\n * ```ts\n * function defineFancyNodes() {\n *   return union(\n *     defineFancyParagraph(),\n *     defineFancyHeading(),\n *   )\n * }\n * ```\n *\n * @example\n *\n * ```ts\n * function defineFancyNodes() {\n *   return union([\n *     defineFancyParagraph(),\n *     defineFancyHeading(),\n *   ])\n * }\n * ```\n *\n * @public\n */\nfunction union<const E extends readonly Extension[]>(...exts: E): Union<E>\nfunction union<const E extends readonly Extension[]>(exts: E): Union<E>\nfunction union(...exts: Array<Extension | Extension[]>): Extension {\n  const extensions: Extension[] = exts.flat()\n  assert(extensions.length > 0, 'At least one extension is required')\n  return new UnionExtensionImpl(extensions as BaseExtension[]) as Extension\n}\n\nexport { union }\n","import type {\n  ProseMirrorNode,\n  Schema,\n} from '@prosekit/pm/model'\nimport {\n  EditorState,\n  type Command,\n  type Plugin,\n  type Selection,\n  type Transaction,\n} from '@prosekit/pm/state'\nimport {\n  EditorView,\n  type DirectEditorProps,\n  type EditorProps,\n} from '@prosekit/pm/view'\n\nimport { ProseKitError } from '../error'\nimport { defineDefaultState } from '../extensions/default-state'\nimport type { BaseExtension } from '../facets/base-extension'\nimport {\n  subtractFacetNode,\n  unionFacetNode,\n  type FacetNode,\n} from '../facets/facet-node'\nimport type {\n  Extension,\n  ExtractCommandActions,\n  ExtractMarkActions,\n  ExtractMarkNames,\n  ExtractNodeActions,\n  ExtractNodeNames,\n} from '../types/extension'\nimport type {\n  CommandAction,\n  CommandCreator,\n} from '../types/extension-command'\nimport type {\n  NodeJSON,\n  SelectionJSON,\n} from '../types/model'\nimport { assert } from '../utils/assert'\nimport { deepEquals } from '../utils/deep-equals'\nimport {\n  getEditorContentDoc,\n  getEditorSelection,\n} from '../utils/editor-content'\nimport {\n  htmlFromNode,\n  jsonFromNode,\n  type DOMDocumentOptions,\n} from '../utils/parse'\n\nimport {\n  createMarkActions,\n  createNodeActions,\n  type MarkAction,\n  type NodeAction,\n} from './action'\nimport { union } from './union'\n\n/**\n * @public\n */\nexport interface EditorOptions<E extends Extension> {\n  /**\n   * The extension to use when creating the editor.\n   */\n  extension: E\n\n  /**\n   * The starting document to use when creating the editor. It can be a\n   * ProseMirror node JSON object, a HTML string, or a HTML element instance.\n   */\n  defaultContent?: NodeJSON | string | HTMLElement\n\n  /**\n   * A JSON object representing the starting document to use when creating the\n   * editor.\n   *\n   * @deprecated Use `defaultContent` instead.\n   */\n  defaultDoc?: NodeJSON\n\n  /**\n   * A HTML element or a HTML string representing the starting document to use\n   * when creating the editor.\n   *\n   * @deprecated Use `defaultContent` instead.\n   */\n  defaultHTML?: string | HTMLElement\n\n  /**\n   * A JSON object representing the starting selection to use when creating the\n   * editor. It's only used when `defaultContent` is also provided.\n   */\n  defaultSelection?: SelectionJSON\n}\n\n/**\n * @public\n */\nexport interface getDocHTMLOptions extends DOMDocumentOptions {}\n\n/**\n * @internal\n */\nexport function setupEditorExtension<E extends Extension>(\n  options: EditorOptions<E>,\n): E {\n  if (options.defaultContent || options.defaultDoc || options.defaultHTML) {\n    return union(\n      options.extension,\n      defineDefaultState(options),\n    ) as Extension as E\n  }\n  return options.extension\n}\n\n/**\n * @public\n */\nexport function createEditor<E extends Extension>(\n  options: EditorOptions<E>,\n): Editor<E> {\n  const extension = setupEditorExtension(options)\n  const instance = new EditorInstance(extension)\n  return new Editor(instance)\n}\n\n/**\n * An internal class to make TypeScript generic type easier to use.\n *\n * @internal\n */\nexport class EditorInstance {\n  view: EditorView | null = null\n  schema: Schema\n  nodes: Record<string, NodeAction>\n  marks: Record<string, MarkAction>\n  commands: Record<string, CommandAction> = {}\n\n  private tree: FacetNode\n  private directEditorProps: DirectEditorProps\n  private afterMounted: Array<VoidFunction> = []\n\n  constructor(extension: Extension) {\n    this.tree = (extension as BaseExtension).getTree()\n\n    const payload = this.tree.getRootOutput()\n    const schema = payload.schema\n    const stateConfig = payload.state\n\n    assert(schema && stateConfig, 'Schema must be defined')\n\n    const state = EditorState.create(stateConfig)\n\n    if (payload.commands) {\n      for (const [name, commandCreator] of Object.entries(payload.commands)) {\n        this.defineCommand(name, commandCreator)\n      }\n    }\n\n    this.nodes = createNodeActions(state.schema, this.getState)\n    this.marks = createMarkActions(state.schema, this.getState)\n\n    this.schema = state.schema\n    this.directEditorProps = { state, ...payload.view }\n  }\n\n  public getState = (): EditorState => {\n    return this.view?.state || this.directEditorProps.state\n  }\n\n  private getDoc(): ProseMirrorNode {\n    return this.getState().doc\n  }\n\n  private getProp<PropName extends keyof EditorProps>(propName: PropName): EditorProps[PropName] | undefined {\n    return this.view?.someProp(propName) ?? this.directEditorProps[propName]\n  }\n\n  public updateState(state: EditorState): void {\n    if (this.view) {\n      this.view.updateState(state)\n    } else {\n      this.directEditorProps.state = state\n    }\n  }\n\n  private dispatch = (tr: Transaction): void => {\n    if (this.view) {\n      this.view.dispatch(tr)\n    } else {\n      this.directEditorProps.state = this.directEditorProps.state.apply(tr)\n    }\n  }\n\n  public setContent(\n    content: NodeJSON | string | HTMLElement | ProseMirrorNode,\n    selection?: SelectionJSON | Selection | 'start' | 'end',\n  ): void {\n    const doc = getEditorContentDoc(this.schema, content)\n    doc.check()\n    const sel = getEditorSelection(doc, selection || 'start')\n\n    const oldState = this.getState()\n    if (doc.eq(oldState.doc) && (!selection || sel.eq(oldState.selection))) {\n      return\n    }\n\n    const newState = EditorState.create({\n      doc,\n      selection: sel,\n      plugins: oldState.plugins,\n    })\n    this.updateState(newState)\n  }\n\n  /**\n   * Return a JSON object representing the editor's current document.\n   */\n  public getDocJSON = (): NodeJSON => {\n    const state = this.getState()\n    return jsonFromNode(state.doc)\n  }\n\n  /**\n   * Return a HTML string representing the editor's current document.\n   */\n  public getDocHTML = (options?: getDocHTMLOptions): string => {\n    const serializer = this.getProp('clipboardSerializer')\n    const DOMSerializer = serializer ? { fromSchema: () => serializer } : undefined\n    const doc = this.getDoc()\n    return htmlFromNode(doc, { ...options, DOMSerializer })\n  }\n\n  private updateExtension(extension: Extension, add: boolean): void {\n    const view = this.view\n\n    // Don't update the extension if the editor is already unmounted\n    if (!view || view.isDestroyed) {\n      return\n    }\n\n    const tree = (extension as BaseExtension).getTree()\n    const payload = tree.getRootOutput()\n\n    if (payload?.schema) {\n      throw new ProseKitError('Schema cannot be changed')\n    }\n\n    if (payload?.view) {\n      throw new ProseKitError('View cannot be changed')\n    }\n\n    const oldPayload = this.tree.getRootOutput()\n    const oldPlugins = [...(view.state?.plugins ?? [])]\n\n    this.tree = add\n      ? unionFacetNode(this.tree, tree)\n      : subtractFacetNode(this.tree, tree)\n\n    const newPayload = this.tree.getRootOutput()\n    const newPlugins = [...(newPayload?.state?.plugins ?? [])]\n\n    if (!deepEquals(oldPlugins, newPlugins)) {\n      const state = view.state.reconfigure({ plugins: newPlugins })\n      view.updateState(state)\n    }\n\n    if (\n      newPayload?.commands\n      && !deepEquals(oldPayload?.commands, newPayload?.commands)\n    ) {\n      const commands = newPayload.commands\n      const names = Object.keys(commands)\n      for (const name of names) {\n        this.defineCommand(name, commands[name])\n      }\n    }\n  }\n\n  public use(extension: Extension): VoidFunction {\n    if (!this.mounted) {\n      let canceled = false\n      let lazyRemove: VoidFunction | null = null\n\n      const lazyCreate = () => {\n        if (!canceled) {\n          lazyRemove = this.use(extension)\n        }\n      }\n\n      this.afterMounted.push(lazyCreate)\n\n      return () => {\n        canceled = true\n        lazyRemove?.()\n      }\n    }\n\n    this.updateExtension(extension, true)\n    return () => this.updateExtension(extension, false)\n  }\n\n  public mount(place: HTMLElement): void {\n    if (this.view) {\n      throw new ProseKitError('Editor is already mounted')\n    }\n    this.view = new EditorView({ mount: place }, this.directEditorProps)\n    this.afterMounted.forEach((callback) => callback())\n  }\n\n  public unmount(): void {\n    // If the editor is not mounted, do nothing\n    if (!this.view) return\n\n    this.directEditorProps.state = this.view.state\n    this.view.destroy()\n    this.view = null\n  }\n\n  get mounted(): boolean {\n    return !!this.view && !this.view.isDestroyed\n  }\n\n  public get assertView(): EditorView {\n    if (!this.view) {\n      throw new ProseKitError('Editor is not mounted')\n    }\n    return this.view\n  }\n\n  public definePlugins(plugins: readonly Plugin[]): void {\n    const view = this.assertView\n    const state = view.state\n    const newPlugins = [...plugins, ...state.plugins]\n    const newState = state.reconfigure({ plugins: newPlugins })\n    view.setProps({ state: newState })\n  }\n\n  public removePlugins(plugins: readonly Plugin[]): void {\n    const view = this.view\n    if (!view) return\n\n    const state = view.state\n    const newPlugins = state.plugins.filter((p) => !plugins.includes(p))\n    const newState = state.reconfigure({ plugins: newPlugins })\n    view.setProps({ state: newState })\n  }\n\n  exec(command: Command): boolean {\n    const state = this.getState()\n    return command(state, this.dispatch, this.view ?? undefined)\n  }\n\n  canExec(command: Command): boolean {\n    const state = this.getState()\n    return command(state, undefined, this.view ?? undefined)\n  }\n\n  public defineCommand<Args extends any[] = any[]>(\n    name: string,\n    commandCreator: CommandCreator<Args>,\n  ): void {\n    const action: CommandAction<Args> = (...args: Args) => {\n      const command = commandCreator(...args)\n      return this.exec(command)\n    }\n\n    const canExec = (...args: Args) => {\n      const command = commandCreator(...args)\n      return this.canExec(command)\n    }\n\n    action.canApply = canExec\n    action.canExec = canExec\n\n    this.commands[name] = action as CommandAction\n  }\n\n  public removeCommand(name: string): void {\n    delete this.commands[name]\n  }\n}\n\n/**\n * @public\n */\nexport class Editor<E extends Extension = any> {\n  private instance: EditorInstance\n\n  /**\n   * @internal\n   */\n  constructor(instance: EditorInstance) {\n    if (!(instance instanceof EditorInstance)) {\n      throw new TypeError('Invalid EditorInstance')\n    }\n    this.instance = instance\n  }\n\n  /**\n   * Whether the editor is mounted.\n   */\n  get mounted(): boolean {\n    return this.instance.mounted\n  }\n\n  /**\n   * The editor view.\n   */\n  get view(): EditorView {\n    return this.instance.assertView\n  }\n\n  /**\n   * The editor schema.\n   */\n  get schema(): Schema<ExtractNodeNames<E>, ExtractMarkNames<E>> {\n    return this.instance.schema\n  }\n\n  /**\n   * The editor's current state.\n   */\n  get state(): EditorState {\n    return this.instance.getState()\n  }\n\n  /**\n   * Whether the editor is focused.\n   */\n  get focused(): boolean {\n    return this.instance.view?.hasFocus() ?? false\n  }\n\n  /**\n   * Mount the editor to the given HTML element.\n   * Pass `null` or `undefined` to unmount the editor.\n   */\n  mount = (place: HTMLElement | null | undefined): void => {\n    if (place) {\n      this.instance.mount(place)\n    } else {\n      this.instance.unmount()\n    }\n  }\n\n  /**\n   * Unmount the editor. This is equivalent to `mount(null)`.\n   */\n  unmount = (): void => {\n    this.instance.unmount()\n  }\n\n  /**\n   * Focus the editor.\n   */\n  focus = (): void => {\n    this.instance.view?.focus()\n  }\n\n  /**\n   * Blur the editor.\n   */\n  blur = (): void => {\n    this.instance.view?.dom.blur()\n  }\n\n  /**\n   * Register an extension to the editor. Return a function to unregister the\n   * extension.\n   */\n  use = (extension: Extension): VoidFunction => {\n    return this.instance.use(extension)\n  }\n\n  /**\n   * Update the editor's state.\n   *\n   * @remarks\n   *\n   * This is an advanced method. Use it only if you have a specific reason to\n   * directly manipulate the editor's state.\n   */\n  updateState = (state: EditorState): void => {\n    this.instance.updateState(state)\n  }\n\n  /**\n   * Update the editor's document and selection.\n   *\n   * @param content - The new document to set. It can be one of the following:\n   *   - A ProseMirror node instance\n   *   - A ProseMirror node JSON object\n   *   - An HTML string\n   *   - An HTML element instance\n   * @param selection - Optional. Specifies the new selection. It can be one of the following:\n   *   - A ProseMirror selection instance\n   *   - A ProseMirror selection JSON object\n   *   - The string \"start\" (to set selection at the beginning, default value)\n   *   - The string \"end\" (to set selection at the end)\n   */\n  setContent = (\n    content: ProseMirrorNode | NodeJSON | string | HTMLElement,\n    selection?: SelectionJSON | Selection | 'start' | 'end',\n  ): void => {\n    return this.instance.setContent(content, selection)\n  }\n\n  /**\n   * Return a JSON object representing the editor's current document.\n   */\n  public getDocJSON = (): NodeJSON => {\n    return this.instance.getDocJSON()\n  }\n\n  /**\n   * Return a HTML string representing the editor's current document.\n   */\n  public getDocHTML = (options?: getDocHTMLOptions): string => {\n    return this.instance.getDocHTML(options)\n  }\n\n  /**\n   * Execute the given command. Return `true` if the command was successfully\n   * executed, otherwise `false`.\n   */\n  exec = (command: Command): boolean => {\n    return this.instance.exec(command)\n  }\n\n  /**\n   * Check if the given command can be executed. Return `true` if the command\n   * can be executed, otherwise `false`.\n   */\n  canExec = (command: Command): boolean => {\n    return this.instance.canExec(command)\n  }\n\n  /**\n   * All {@link CommandAction}s defined by the editor.\n   */\n  get commands(): ExtractCommandActions<E> {\n    return this.instance.commands as ExtractCommandActions<E>\n  }\n\n  /**\n   * All {@link NodeAction}s defined by the editor.\n   */\n  get nodes(): ExtractNodeActions<E> {\n    return this.instance.nodes as ExtractNodeActions<E>\n  }\n\n  /**\n   * All {@link MarkAction}s defined by the editor.\n   */\n  get marks(): ExtractMarkActions<E> {\n    return this.instance.marks as ExtractMarkActions<E>\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AAKA,IAAa,gBAAb,cAAmC,MAAM;;;;AAKzC,IAAa,sBAAb,cAAyC,cAAc;CACrD,cAAc;AACZ,QACE,mGACD;;;;;;AAOL,IAAa,2BAAb,cAA8C,cAAc;CAC1D,cAAc;AACZ,QACE,yGACD;;;;;;;;;ACfL,SAAgB,YAAY,QAAgB,MAAmC;AAC7E,KAAI,OAAO,SAAS,UAAU;EAC5B,MAAM,WAAW,OAAO,MAAM;AAC9B,MAAI,CAAC,SACH,OAAM,IAAI,cAAc,0BAA0B,KAAK,GAAG;AAE5D,SAAO;;AAET,QAAO;;;;;;;;ACbT,SAAgB,OACd,WACA,UAAU,oBACS;AACnB,KAAI,CAAC,UACH,OAAM,IAAI,cAAc,QAAQ;;;;;;;;ACApC,SAAgB,YAAY,QAAgB,MAAmC;AAC7E,KAAI,OAAO,SAAS,UAAU;EAC5B,MAAM,WAAW,OAAO,MAAM;AAC9B,MAAI,CAAC,SACH,OAAM,IAAI,cAAc,sCAAsC,KAAK,GAAG;AAExE,SAAO;;AAET,QAAO;;;;;ACZT,SAAgB,WACd,YACA,OACS;CACT,MAAM,eAAe,WAAW;AAEhC,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,MAAM,CAC9C,KAAI,aAAa,SAAS,MACxB,QAAO;AAIX,QAAO;;;;;ACTT,SAAgB,aACd,OACA,MACA,OACS;CACT,MAAM,OAAO,MAAM,UAAU;CAC7B,MAAM,WAAW,YAAY,MAAM,QAAQ,KAAK;AAEhD,MAAK,IAAI,QAAQ,KAAK,OAAO,SAAS,GAAG,SAAS;EAChD,MAAM,OAAO,KAAK,KAAK,MAAM;AAC7B,MAAI,KAAK,SAAS,aAAa,CAAC,SAAS,WAAW,MAAM,MAAM,EAC9D,QAAO;;AAGX,QAAO;;;;;;;;;;AClBT,IAAY,gDAAL;AACL;AACA;AACA;AACA;AACA;;;;;;ACNF,IAAI,aAAa;;;;AAKjB,IAAa,QAAb,MAAkC;;;;CAuBhC,YACE,QACA,WACA,AAAQA,UACR,AAAQC,SACR;EAFQ;EACA;eAvBe;AA0BvB,UAAQ,WAAW,aAAa,EAAE,WAAW,UAAU;AAEvD,OAAK,SAAS;AACd,OAAK,YAAY;AACjB,OAAK,OAAO,SAAS,CAAC,GAAG,OAAO,MAAM,KAAK,MAAM,GAAG,EAAE;;CAGxD,IAAI,UAAuC;AACzC,SAAQ,KAAK,YAAY,KAAK,WAAW;;;;;;AAO7C,SAAgB,YAA2B,SAsBlB;AACvB,QAAO,IAAI,MACT,QAAQ,QACR,QAAQ,aAAa,OACrB,QAAQ,SACR,QAAQ,OACT;;;;;AC5DH,SAAS,YAAY,QAAmC;CACtD,IAAIC;CACJ,IAAIC;CACJ,IAAIC;CACJ,IAAIC;AAEJ,MAAK,MAAM,SAAS,QAAQ;AAC1B,WAAS,MAAM,UAAU;AACzB,aAAW,MAAM,YAAY;AAC7B,cAAY,MAAM,SAAS;AAC3B,SAAO,MAAM,QAAQ;;CAGvB,MAAM,QAAQ,WAAW,YAAY,EAAE,QAAQ,CAAC,IAAI,EAAE,QAAQ;AAE9D,QAAO;EAAE;EAAQ;EAAO;EAAU;EAAM;;AAG1C,MAAaC,YAA4C,IAAI,MAG3D,MAAM,MAAM,YAAY;;;;AC3B1B,MAAaC,cAA8C,YAAY;CACrE,UAAU,UAAU;AAClB,SAAO,MAAM,UAAU,EAAE;EACzB,MAAM,OAAO,MAAM;AAEnB,SAAO,EAAE,QADM,OAAO,IAAI,OAAO,KAAK,GAAG,MACxB;;CAEnB,QAAQ;CACR,WAAW;CACZ,CAAC;;;;;;;ACTF,IAAsB,gBAAtB,MAAyG;;eAK7D;GAAC;GAAM;GAAM;GAAM;GAAM;GAAK;;;;;CAUxE,QAAQ,UAAgC;EACtC,MAAM,MAAM,YAAY,KAAK,YAAY,SAAS;AAClD,SAAQ,KAAK,MAAM,SAAS,KAAK,WAAW,IAAI;;;;;CAMlD,gBAAsB,OAA6C;EACjE,IAAIC,OAA8B,KAAK,SAAS;AAEhD,OAAK,MAAM,SAAS,MAAM,KACxB,QAAO,MAAM,SAAS,IAAI,MAAM;AAGlC,SAAO,MAAM,WAAW,IAAI;;CAG9B,IAAI,SAAwB;AAE1B,SADe,KAAK,gBAAgB,YAAY,EACjC,KAAK,QAAQ,EAAE,UAAU;;;;;;ACnD5C,SAAgB,SAAY,MAAoB,MAAyB;CACvE,MAAM,SAAS,CAAC,GAAG,KAAK;AAExB,MAAK,MAAM,QAAQ,KACjB,KAAI,CAAC,OAAO,SAAS,KAAK,CACxB,QAAO,KAAK,KAAK;AAGrB,QAAO;;;;;AAMT,SAAgB,cAAiB,GAAQ,GAAa;AACpD,QAAO,EAAE,QAAQ,MAAM,CAAC,EAAE,SAAS,EAAE,CAAC;;AAGxC,SAAgB,WAAc,KAAe;AAC3C,QAAO,IAAI,cAAc,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS;;;;;;;;ACHjD,SAAgB,kBAAkB,OAA0C;AAC1E,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,OAAO,OAA+B;AACpD,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,WAAW,OAAmC;AAC5D,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,QAAQ,OAAgC;AACtD,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,YAAY,OAAoC;AAC9D,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,gBAAgB,OAA0C;AACxE,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,gBAAgB,OAA0C;AACxE,QAAO,iBAAiB;;;;;;;AAQ1B,SAAgB,eAAe,OAAyC;AACtE,QAAO,iBAAiB;;;;;AAM1B,SAAgB,aACd,OACY;AACZ,QAAO,SAAS;;;;;AC1ElB,SAAS,KACP,GACA,GACA,QACW;AACX,QAAO;EACL,OAAO,EAAE,IAAI,EAAE,GAAG;EAClB,OAAO,EAAE,IAAI,EAAE,GAAG;EAClB,OAAO,EAAE,IAAI,EAAE,GAAG;EAClB,OAAO,EAAE,IAAI,EAAE,GAAG;EAClB,OAAO,EAAE,IAAI,EAAE,GAAG;EACnB;;AAGH,SAAS,WAAc,GAAe,GAA2B;AAC/D,KAAI,CAAC,KAAK,CAAC,EAAG,QAAO;AACrB,QAAO,SAAS,KAAK,EAAE,EAAE,KAAK,EAAE,CAAC;;AAGnC,SAAS,cAAiB,GAAe,GAA2B;AAClE,KAAI,CAAC,EAAG,QAAO;AACf,KAAI,CAAC,EAAG,QAAO,CAAC,GAAG,EAAE;AACrB,QAAO,cAAc,GAAG,EAAE;;AAG5B,SAAS,cACP,GACA,GACwB;CACxB,MAAM,SAAS,IAAI,IAAI,EAAE;AACzB,MAAK,MAAM,CAAC,KAAK,WAAW,EAAE,SAAS,EAAE;EACvC,MAAM,SAAS,EAAE,IAAI,IAAI;AACzB,SAAO,IAAI,KAAK,SAAS,eAAe,QAAQ,OAAO,GAAG,OAAO;;AAEnE,QAAO;;AAGT,SAAS,iBACP,GACA,GACwB;CACxB,MAAM,SAAS,IAAI,IAAI,EAAE;AACzB,MAAK,MAAM,CAAC,KAAK,WAAW,EAAE,SAAS,EAAE;EACvC,MAAM,SAAS,EAAE,IAAI,IAAI;AACzB,MAAI,OACF,QAAO,IAAI,KAAK,kBAAkB,QAAQ,OAAO,CAAC;;AAGtD,QAAO;;;;;;;;;;AAWT,SAAgB,eACd,GACA,GACiB;AACjB,QAAO,EAAE,UAAU,EAAE,MAAM;AAC3B,QAAO,IAAI,UACT,EAAE,OACF,KAAK,EAAE,QAAQ,EAAE,QAAQ,WAAW,EACpC,cAAc,EAAE,UAAU,EAAE,SAAS,EACrC,EAAE,SACH;;;;;;;;;;AAWH,SAAgB,kBACd,GACA,GACiB;AACjB,QAAO,EAAE,UAAU,EAAE,MAAM;AAC3B,QAAO,IAAI,UACT,EAAE,OACF,KAAK,EAAE,QAAQ,EAAE,QAAQ,cAAc,EACvC,iBAAiB,EAAE,UAAU,EAAE,SAAS,EACxC,EAAE,SACH;;AAGH,IAAa,YAAb,MAAyC;CAGvC,YACE,AAASC,OACT,AAASC,SAA6B;EAAC;EAAM;EAAM;EAAM;EAAM;EAAK,EACpE,AAASC,2BAAmC,IAAI,KAAK,EACrD,AAASC,WAA8C;EACrD;EACA;EACA;EACA;EACA;EACD,EACD;EAVS;EACA;EACA;EACA;gBANuB;;CAelC,AAAQ,aAA+B;EACrC,MAAMF,SAA6B;GAAC;GAAM;GAAM;GAAM;GAAM;GAAK;EACjE,MAAMG,SAA2B;GAAC;GAAM;GAAM;GAAM;GAAM;GAAK;AAE/D,OAAK,IAAI,MAAM,GAAG,MAAM,GAAG,OAAO;GAChC,MAAM,QAAQ,KAAK,OAAO;AAC1B,OAAI,MACF,QAAO,OAAO,CAAC,GAAG,MAAM;;AAI5B,OAAK,MAAM,SAAS,KAAK,SAAS,QAAQ,EAAE;GAC1C,MAAM,cAAc,MAAM,WAAW;AACrC,QAAK,IAAI,MAAM,GAAG,MAAM,GAAG,MACzB,KAAI,YAAY,KAEd,EADe,OAAO,SAAS,EAAE,EAC3B,KAAK,YAAY,KAAU;;AAKvC,MAAI,KAAK,MAAM,WAAW;GACxB,MAAM,UAAW,KAAK,SAAS,SAAS,aAAa,KAAK,MAAM;GAChE,MAAMC,QAAa,OAAO,OAAO,aAAa,CAAC,MAAM;AACrD,UAAO,SAAS,WAAW,QAAQ,MAAM;QAEzC,MAAK,IAAI,MAAM,GAAG,MAAM,GAAG,OAAO;GAChC,MAAM,QAAQ,OAAO;AACrB,OAAI,MAEF,QAAO,QADU,KAAK,SAAS,SAAS,KAAK,MAAM,SAC7B,MAAM;;AAKlC,SAAO;;CAGT,YAA8B;AAC5B,MAAI,CAAC,KAAK,OACR,MAAK,SAAS,KAAK,YAAY;AAEjC,SAAO,KAAK;;CAGd,qBAA+B;AAC7B,SAAO,KAAK,MAAM,UAAU;AAC5B,SAAO,KAAK,WAAW,CAAC,SAAS;;CAGnC,gBAA4B;AAC1B,SAAO,KAAK,QAAQ,CAAC;EACrB,MAAM,SAAS,KAAK,oBAAoB;AACxC,SAAO,OAAO;AACd,SAAO;;CAGT,SAAkB;AAChB,SAAO,CAAC,KAAK,MAAM;;;;;;;;;AC3KvB,IAAa,qBAAb,cAAuD,cAAc;;;;CAMnE,YACE,AAASC,OACT,AAASC,UACT;AACA,SAAO;EAHE;EACA;;;;;CAQX,WAAW,UAA+B;EACxC,MAAM,MAAM,KAAK,YAAY;EAE7B,MAAMC,SAAiC;GAAC;GAAM;GAAM;GAAM;GAAM;GAAK;AACrE,SAAO,OAAO,CAAC,GAAG,KAAK,SAAS;EAEhC,IAAIC,OAAkB,IAAI,UAAU,KAAK,OAAO,OAAO;AAEvD,SAAO,KAAK,MAAM,QAAQ;GACxB,MAAM,WAAW,IAAI,IAAI,CAAC,CAAC,KAAK,MAAM,OAAO,KAAK,CAAC,CAAC;AACpD,UAAO,IAAI,UAAU,KAAK,MAAM,QAAQ,QAAW,SAAS;;AAG9D,SAAO;;;;;;AAOX,SAAgB,mBACd,OACA,UACW;AACX,QAAO,IAAI,mBAAmB,OAAO,SAAS;;;;;AClChD,MAAaC,aAA+C,YAAY;CACtE,cAAc;EACZ,IAAIC,YAA4B,EAAE;EAElC,MAAMC,SAAuB,QAAQ;GACnC,MAAM,UAAU,UAAU,KAAK,OAAO,GAAG,IAAI,CAAC;GAC9C,MAAMC,SAA4B;IAChC,QAAQ,IAAI;IACZ,aAAa,EAAE;IACf,SAAS,EAAE;IACZ;AAED,QAAK,MAAM,KAAK,SAAS;AACvB,WAAO,SAAS,OAAO,UAAU,EAAE;AACnC,WAAO,MAAM,OAAO,OAAO,EAAE;AAC7B,WAAO,YAAY,OAAO,aAAa,EAAE;AACzC,WAAO,cAAc,CAAC,GAAG,OAAO,aAAc,GAAI,EAAE,eAAe,EAAE,CAAE;AACvE,WAAO,UAAU,SAAS,OAAO,WAAW,EAAE,EAAE,EAAE,WAAW,EAAE,CAAC;;AAGlE,UACE,OAAO,OAAO,OAAO,QACrB,qDACD;AAED,OAAI,OAAO,IACT,QAAO,SAAS;AAGlB,UAAO;;AAGT,SAAO,SAAS,QAAQ,QAAQ;AAC9B,eAAY;AACZ,UAAO,EAAE,OAAO;;;CAGpB,WAAW;CACX,QAAQ;CACT,CAAC;;;;ACtDF,SAAS,4BAA4B;AACnC,KAAI,OAAO,aAAa,YACtB,QAAO;AAGT,KAAI,OAAO,eAAe,eAAe,WAAW,SAClD,QAAO,WAAW;;AAItB,SAAS,0BAA0B;AACjC,KAAI,OAAO,WAAW,YACpB,QAAO;AAGT,KAAI,OAAO,eAAe,eAAe,WAAW,OAClD,QAAO,WAAW;;AAItB,SAAS,oBAAoB,SAAyD;AACpF,QACE,SAAS,YACJ,2BAA2B,IAC3B,yBAAyB,EAAE;;AAIpC,SAAS,kBAAkB,SAEkB;AAC3C,QACE,SAAS,UAAU,eACd,yBAAyB,IACzB,oBAAoB,QAAQ,EAAE,eAC9B;;AAIT,SAAgB,mBAAmB,SAEtB;CACX,MAAM,MAAM,oBAAoB,QAAQ;AACxC,KAAI,IAAK,QAAO;AAChB,OAAM,IAAI,0BAA0B;;AAGtC,SAAgB,iBAAiB,SAEF;CAC7B,MAAM,MAAM,kBAAkB,QAAQ;AACtC,KAAI,IAAK,QAAO;AAChB,OAAM,IAAI,0BAA0B;;;;;;;;;;;;;;;;;ACQtC,SAAgB,cAAc,OAA+B;AAC3D,QAAO,MAAM,QAAQ;;;;;;;;;;;;;;AAevB,SAAgB,cACd,MACA,SACa;AACb,QAAO,YAAY,SAAS,EAAE,QAAQ,QAAQ,QAAQ,EAAE,KAAK;;;;;;;;;;;;;;AAiB/D,SAAgB,aAAa,MAAiC;AAC5D,QAAO,KAAK,QAAQ;;;;;;;;;;;;;;AAetB,SAAgB,aACd,MACA,SACiB;AACjB,QAAO,QAAQ,OAAO,aAAa,KAAK;;;;;;;;;;;;;;AAiB1C,SAAgB,gBACd,SACA,SACiB;CACjB,MAAM,EAAE,WAAW,iBAAiB,OAAQ,GAAG,iBAAiB;AAChE,SAAQ,mBAAmB,WACxB,WAAW,OAAO,CAClB,MAAM,SAAS,aAAa;;;;;;;;;;;;;;AAejC,SAAgB,gBACd,MACA,SACa;CACb,MAAM,aAAa,SAAS,iBAAiB;CAC7C,MAAMC,aAAW,mBAAmB,QAAQ;CAC5C,MAAM,SAAS,KAAK,KAAK;CACzB,MAAM,aAAa,WAAW,WAAW,OAAO;AAEhD,KAAI,OAAO,gBAAgB,KAAK,KAC9B,QAAO,WAAW,cAAc,MAAM,EAAE,sBAAU,CAAC;KAEnD,QAAO,WAAW,kBAChB,KAAK,SACL,EAAE,sBAAU,EACZA,WAAS,cAAc,MAAM,CAC9B;;;;;;;AAWL,SAAgB,gBACd,MACA,SACa;AAGb,QADe,KADH,iBAAiB,QAAQ,EACd,WAAW,CACpB,gBAAgB,cAAc,KAAK,gBAAgB,YAAY,CAC1E,KAAK;;;;;AAMV,SAAS,gBAAgB,SAA8B;AACrD,QAAO,QAAQ;;;;;;;;;;;;;;AAiBjB,SAAgB,aACd,MACA,SACiB;AACjB,QAAO,gBAAgB,gBAAgB,MAAM,QAAQ,EAAE,QAAQ;;;;;;;;;;;;;;AAejE,SAAgB,aACd,MACA,SACQ;AACR,QAAO,gBAAgB,MAAM,QAAQ,CAAC;;;;;;;;;;;;;;AAiBxC,SAAgB,gBACd,SACA,SACU;AACV,QAAO,aAAa,gBAAgB,SAAS,QAAQ,CAAC;;;;;;;;;;;;;;AAexD,SAAgB,gBACd,MACA,SACa;AACb,QAAO,gBAAgB,aAAa,MAAM,QAAQ,EAAE,QAAQ;;;;;;;;;;;;;;AAiB9D,SAAgB,aACd,MACA,SACU;AACV,QAAO,gBAAgB,gBAAgB,MAAM,QAAQ,EAAE,QAAQ;;;;;;;;;;;;;;AAejE,SAAgB,aACd,MACA,SACQ;AACR,QAAO,gBAAgB,gBAAgB,MAAM,QAAQ,CAAC;;;;;ACzSxD,SAAgB,qBACd,QACA,SACU;AACV,KAAI,OAAO,YAAY,SACrB,QAAO,aAAa,SAAS,EAAE,QAAQ,CAAC;UAC/B,cAAc,QAAQ,CAC/B,QAAO,gBAAgB,SAAS,EAAE,QAAQ,CAAC;KAE3C,QAAO;;AAIX,SAAS,qBACP,QACA,SACiB;AACjB,KAAI,kBAAkB,QAAQ,CAC5B,QAAO;AAET,QAAO,OAAO,aAAa,qBAAqB,QAAQ,QAAQ,CAAC;;AAGnE,SAAgB,oBACd,QACA,SACiB;CACjB,MAAM,MAAM,qBAAqB,QAAQ,QAAQ;AACjD,QACE,IAAI,KAAK,WAAW,QACpB,+CACD;AACD,QACE,IAAI,SAAS,OAAO,aACpB,+DAA+D,OAAO,YAAY,KAAK,QAAQ,IAAI,KAAK,OACzG;AACD,QAAO;;AAGT,SAAgB,mBACd,KACA,WACW;AACX,KAAI,YAAY,UAAU,EAAE;AAC1B,SAAO,UAAU,MAAM,QAAQ,KAAK,iCAAiC;AACrE,SAAO;;AAET,KAAI,cAAc,QAChB,QAAO,UAAU,QAAQ,IAAI;AAE/B,KAAI,cAAc,MAChB,QAAO,UAAU,MAAM,IAAI;AAE7B,QAAO,UAAU,SAAS,KAAK,UAAU;;;;;;;;;;;;ACrB3C,SAAgB,mBAAmB,EACjC,kBACA,gBACA,YACA,eACsC;CACtC,MAAM,oBAAoB,kBAAkB,cAAc;AAE1D,QAAO,mBAAmB,YAAY,EACnC,EAAE,aAAa;EACd,MAAMC,SAA4B,EAAE;AACpC,MAAI,mBAAmB;GACrB,MAAM,OAAO,qBAAqB,QAAQ,kBAAkB;AAC5D,UAAO,MAAM,OAAO,aAAa,KAAK;AACtC,OAAI,iBACF,QAAO,YAAY,UAAU,SAAS,OAAO,KAAK,iBAAiB;;AAGvE,SAAO;GAEV,CAAC;;;;;ACxEJ,SAAgB,WAAc,GAAM,GAAe;AACjD,KAAI,MAAM,EACR,QAAO;AAGT,KAAI,CAAC,KAAK,CAAC,EACT,QAAO;AAGT,KAAI,MAAM,QAAQ,EAAE,IAAI,MAAM,QAAQ,EAAE,CACtC,QAAO,EAAE,WAAW,EAAE,UAAU,EAAE,OAAO,GAAG,MAAM,WAAW,GAAG,EAAE,GAAG,CAAC;AAGxE,KAAI,aAAa,cAAc,aAAa,WAC1C,QAAO,EAAE,SAAS,EAAE,QAAQ,WAAW,EAAE,UAAU,EAAE,EAAE,UAAU,CAAC;AAGpE,KAAI,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;EAClD,MAAM,QAAQ,OAAO,KAAK,EAAE;EAC5B,MAAM,QAAQ,OAAO,KAAK,EAAE;AAC5B,SACE,MAAM,WAAW,MAAM,UACpB,MAAM,OAAO,QAAQ,WAAW,EAAE,MAAiB,EAAE,KAAgB,CAAC;;AAG7E,QAAO;;;;;;;;;;ACtBT,SAAgB,SACd,QACA,UACS;AACT,QAAO,OAAO,KAAK,OAAO,CAAC,OAAO,QAAQ,OAAO,SAAS,SAAS,KAAK;;;;;ACD1E,SAAgB,aACd,OACA,UACA,OACS;AACT,SAAQ,SAAS,EAAE;AACnB,QAAO,MAAM,MAAM,SAAS;AAC1B,SAAO,KAAK,SAAS,YAAY,SAAS,OAAO,KAAK,MAAM;GAC5D;;;;;;;;;;;;ACDJ,SAAgB,aACd,MACA,MACA,IACA,UACA,OACS;CACT,IAAI,UAAU;CACd,IAAI,YAAY;AAEhB,MAAK,aAAa,MAAM,KAAK,QAAM,KAAK,WAAW;AACjD,MAAI,QACF,QAAO;AAMT,MAHgB,QAAQ,KAAK,eAAe,SAAS,IAChD,CAACC,OAAK,MAAM,MAAM,MAAM,EAAE,SAAS,YAAY,EAAE,KAAK,SAAS,SAAS,CAAC,EAEjE;AACX,eAAY;AACZ,OAAI,CAAC,aAAaA,OAAK,OAAO,UAAU,MAAM,CAC5C,WAAU;;GAGd;AACF,QAAO,YAAY,UAAU;;;;;;;;AC3B/B,SAAgB,aACd,OACA,MACA,OACS;CACT,MAAM,EAAE,MAAM,OAAO,IAAI,UAAU,MAAM;CACzC,MAAM,WAAW,YAAY,MAAM,QAAQ,KAAK;AAChD,KAAI,OAAO;EACT,MAAM,QAAQ,MAAM,eAAe,MAAM,OAAO;AAChD,SAAO,aAAa,OAAO,UAAU,MAAM;OAE3C,QAAO,CAAC,aAAa,MAAM,KAAK,MAAM,IAAI,UAAU,MAAM;;;;;;;;ACsE9D,SAAgB,kBACd,QACA,UACA,aAAiC,mBACL;AAC5B,QAAO,UAAU,OAAO,QAAQ,SAAS,iBAAiB,MAAM,UAAU,WAAW,CAAC;;AAGxF,SAAS,iBACP,MACA,UACA,YACY;CACZ,MAAM,UACJ,GAAG,SACA,UAAU,MAAM,MAAM,WAAW;AACtC,QAAO,YAAY,UAAkB;EACnC,MAAM,QAAQ,UAAU;AACxB,SAAO,QAAQ,aAAa,OAAO,MAAM,MAAM,GAAG;;AAEpD,QAAO;;;;;AAMT,SAAgB,kBACd,QACA,UACA,YAA+B,kBACH;AAC5B,QAAO,UAAU,OAAO,QAAQ,SAAS,iBAAiB,MAAM,UAAU,UAAU,CAAC;;AAGvF,SAAS,iBACP,MACA,UACA,WACY;CACZ,MAAM,UACJ,GAAG,SACA,UAAU,MAAM,MAAM,UAAU;AACrC,QAAO,YAAY,UAAkB;EACnC,MAAM,QAAQ,UAAU;AACxB,SAAO,QAAQ,aAAa,OAAO,MAAM,MAAM,GAAG;;AAEpD,QAAO;;AAGT,SAAS,UACP,MACA,MACA,WACmB;CACnB,MAAM,CAAC,OAAO,YAAY,cAAc,KAAK;CAC7C,MAAM,OAAO,KAAK,OAAO,MAAM;AAC/B,QAAO,UAAU,MAAM,gBAAgB,KAAK,QAAQ,SAAS,CAAC;;AAWhE,MAAMC,oBACJ,MACA,aACsB;AACtB,QAAO,SAAS,KAAK,SAAS,KAAK,KAAK,KAAK,SAAS,KAAK,MAAM,CAAC,CAAC;;AAGrE,SAAS,UACP,MACA,MACA,YACiB;CACjB,MAAM,CAAC,OAAO,YAAY,cAAc,KAAK;AAC7C,QAAO,WAAW,MAAM,OAAO,gBAAgB,KAAK,QAAQ,SAAS,CAAC;;AAcxE,MAAMC,qBACJ,MACA,OACA,aACG;CACH,MAAM,OAAO,KAAK,cAAc,OAAO,SAAS;AAChD,QAAO,MAAM,yBAAyB,KAAK,OAAO;AAClD,QAAO;;AAGT,SAAS,gBACP,QACA,UACwB;CACxB,MAAMC,QAAgC,EAAE;AAExC,MAAK,MAAM,SAAS,SAClB,KAAI,OAAO,UAAU,UACnB;MAAI,MACF,OAAM,KAAK,OAAO,KAAK,OAAO,KAAK,CAAC;YAE7B,MAAM,QAAQ,MAAM,CAC7B,OAAM,KAAK,GAAG,gBAAgB,QAAQ,MAAM,CAAC;UACpC,kBAAkB,MAAM,CACjC,OAAM,KAAK,MAAM;KAEjB,OAAM,IAAI,cAAc,uBAAuB,OAAO,QAAQ;AAIlE,QAAO;;AAGT,SAAS,cACP,MAC6B;CAC7B,MAAM,CAAC,OAAO,GAAG,YAAY;AAC7B,KAAI,YAAY,MAAM,EAAE;AACtB,WAAS,QAAQ,MAAM;AACvB,SAAO,CAAC,MAAM,SAAS;YACd,OAAO,UAAU,SAC1B,QAAO,CAAC,OAAO,SAAS;KAExB,QAAO,CAAC,MAAM,SAAS;;AAI3B,SAAS,YACP,OACoB;AACpB,KAAI,CAAC,MACH,QAAO;AAGT,QACE,OAAO,UAAU,YACd,MAAM,QAAQ,MAAM,IACpB,kBAAkB,MAAM;;;;;ACxO/B,IAAa,qBAAb,cAAqF,cAAyC;;;;CAI5H,YAAY,AAAOC,YAA6B,EAAE,EAAE;AAClD,SAAO;EADU;;;;;CAOnB,WAAW,UAA+B;EACxC,MAAM,MAAM,KAAK,YAAY;EAE7B,MAAM,aAAa,CAAC,GAAG,KAAK,UAAU;AACtC,aAAW,MAAM,GAAG,OAAO,EAAE,YAAY,QAAQ,EAAE,YAAY,KAAK;EAEpE,MAAMC,WAAwB,WAAW,KAAK,QAAQ,IAAI,QAAQ,IAAI,CAAC;AAEvE,SAAO,SAAS,SAAS,EAAE;EAE3B,IAAI,OAAO,SAAS;AACpB,OAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,IACnC,QAAO,eAAe,MAAM,SAAS,GAAG;AAE1C,SAAO;;;;;;ACEX,SAAS,MAAM,GAAG,MAAiD;CACjE,MAAMC,aAA0B,KAAK,MAAM;AAC3C,QAAO,WAAW,SAAS,GAAG,qCAAqC;AACnE,QAAO,IAAI,mBAAmB,WAA8B;;;;;;;;ACgE9D,SAAgB,qBACd,SACG;AACH,KAAI,QAAQ,kBAAkB,QAAQ,cAAc,QAAQ,YAC1D,QAAO,MACL,QAAQ,WACR,mBAAmB,QAAQ,CAC5B;AAEH,QAAO,QAAQ;;;;;AAMjB,SAAgB,aACd,SACW;CACX,MAAM,YAAY,qBAAqB,QAAQ;CAC/C,MAAM,WAAW,IAAI,eAAe,UAAU;AAC9C,QAAO,IAAI,OAAO,SAAS;;;;;;;AAQ7B,IAAa,iBAAb,MAA4B;CAW1B,YAAY,WAAsB;cAVR;kBAIgB,EAAE;sBAIA,EAAE;wBA0BT;AACnC,UAAO,KAAK,MAAM,SAAS,KAAK,kBAAkB;;mBAmBhC,OAA0B;AAC5C,OAAI,KAAK,KACP,MAAK,KAAK,SAAS,GAAG;OAEtB,MAAK,kBAAkB,QAAQ,KAAK,kBAAkB,MAAM,MAAM,GAAG;;0BA4BrC;GAClC,MAAMC,UAAQ,KAAK,UAAU;AAC7B,UAAO,aAAaA,QAAM,IAAI;;qBAMX,YAAwC;GAC3D,MAAM,aAAa,KAAK,QAAQ,sBAAsB;GACtD,MAAMC,kBAAgB,aAAa,EAAE,kBAAkB,YAAY,GAAG;GACtE,MAAM,MAAM,KAAK,QAAQ;AACzB,UAAO,aAAa,KAAK;IAAE,GAAG;IAAS;IAAe,CAAC;;AAvFvD,OAAK,OAAQ,UAA4B,SAAS;EAElD,MAAM,UAAU,KAAK,KAAK,eAAe;EACzC,MAAM,SAAS,QAAQ;EACvB,MAAM,cAAc,QAAQ;AAE5B,SAAO,UAAU,aAAa,yBAAyB;EAEvD,MAAM,QAAQ,YAAY,OAAO,YAAY;AAE7C,MAAI,QAAQ,SACV,MAAK,MAAM,CAAC,MAAM,mBAAmB,OAAO,QAAQ,QAAQ,SAAS,CACnE,MAAK,cAAc,MAAM,eAAe;AAI5C,OAAK,QAAQ,kBAAkB,MAAM,QAAQ,KAAK,SAAS;AAC3D,OAAK,QAAQ,kBAAkB,MAAM,QAAQ,KAAK,SAAS;AAE3D,OAAK,SAAS,MAAM;AACpB,OAAK,oBAAoB;GAAE;GAAO,GAAG,QAAQ;GAAM;;CAOrD,AAAQ,SAA0B;AAChC,SAAO,KAAK,UAAU,CAAC;;CAGzB,AAAQ,QAA4C,UAAuD;AACzG,SAAO,KAAK,MAAM,SAAS,SAAS,IAAI,KAAK,kBAAkB;;CAGjE,AAAO,YAAY,OAA0B;AAC3C,MAAI,KAAK,KACP,MAAK,KAAK,YAAY,MAAM;MAE5B,MAAK,kBAAkB,QAAQ;;CAYnC,AAAO,WACL,SACA,WACM;EACN,MAAM,MAAM,oBAAoB,KAAK,QAAQ,QAAQ;AACrD,MAAI,OAAO;EACX,MAAM,MAAM,mBAAmB,KAAK,aAAa,QAAQ;EAEzD,MAAM,WAAW,KAAK,UAAU;AAChC,MAAI,IAAI,GAAG,SAAS,IAAI,KAAK,CAAC,aAAa,IAAI,GAAG,SAAS,UAAU,EACnE;EAGF,MAAM,WAAW,YAAY,OAAO;GAClC;GACA,WAAW;GACX,SAAS,SAAS;GACnB,CAAC;AACF,OAAK,YAAY,SAAS;;CAqB5B,AAAQ,gBAAgB,WAAsB,KAAoB;EAChE,MAAM,OAAO,KAAK;AAGlB,MAAI,CAAC,QAAQ,KAAK,YAChB;EAGF,MAAM,OAAQ,UAA4B,SAAS;EACnD,MAAM,UAAU,KAAK,eAAe;AAEpC,MAAI,SAAS,OACX,OAAM,IAAI,cAAc,2BAA2B;AAGrD,MAAI,SAAS,KACX,OAAM,IAAI,cAAc,yBAAyB;EAGnD,MAAM,aAAa,KAAK,KAAK,eAAe;EAC5C,MAAM,aAAa,CAAC,GAAI,KAAK,OAAO,WAAW,EAAE,CAAE;AAEnD,OAAK,OAAO,MACR,eAAe,KAAK,MAAM,KAAK,GAC/B,kBAAkB,KAAK,MAAM,KAAK;EAEtC,MAAM,aAAa,KAAK,KAAK,eAAe;EAC5C,MAAM,aAAa,CAAC,GAAI,YAAY,OAAO,WAAW,EAAE,CAAE;AAE1D,MAAI,CAAC,WAAW,YAAY,WAAW,EAAE;GACvC,MAAM,QAAQ,KAAK,MAAM,YAAY,EAAE,SAAS,YAAY,CAAC;AAC7D,QAAK,YAAY,MAAM;;AAGzB,MACE,YAAY,YACT,CAAC,WAAW,YAAY,UAAU,YAAY,SAAS,EAC1D;GACA,MAAM,WAAW,WAAW;GAC5B,MAAM,QAAQ,OAAO,KAAK,SAAS;AACnC,QAAK,MAAM,QAAQ,MACjB,MAAK,cAAc,MAAM,SAAS,MAAM;;;CAK9C,AAAO,IAAI,WAAoC;AAC7C,MAAI,CAAC,KAAK,SAAS;GACjB,IAAI,WAAW;GACf,IAAIC,aAAkC;GAEtC,MAAM,mBAAmB;AACvB,QAAI,CAAC,SACH,cAAa,KAAK,IAAI,UAAU;;AAIpC,QAAK,aAAa,KAAK,WAAW;AAElC,gBAAa;AACX,eAAW;AACX,kBAAc;;;AAIlB,OAAK,gBAAgB,WAAW,KAAK;AACrC,eAAa,KAAK,gBAAgB,WAAW,MAAM;;CAGrD,AAAO,MAAM,OAA0B;AACrC,MAAI,KAAK,KACP,OAAM,IAAI,cAAc,4BAA4B;AAEtD,OAAK,OAAO,IAAI,WAAW,EAAE,OAAO,OAAO,EAAE,KAAK,kBAAkB;AACpE,OAAK,aAAa,SAAS,aAAa,UAAU,CAAC;;CAGrD,AAAO,UAAgB;AAErB,MAAI,CAAC,KAAK,KAAM;AAEhB,OAAK,kBAAkB,QAAQ,KAAK,KAAK;AACzC,OAAK,KAAK,SAAS;AACnB,OAAK,OAAO;;CAGd,IAAI,UAAmB;AACrB,SAAO,CAAC,CAAC,KAAK,QAAQ,CAAC,KAAK,KAAK;;CAGnC,IAAW,aAAyB;AAClC,MAAI,CAAC,KAAK,KACR,OAAM,IAAI,cAAc,wBAAwB;AAElD,SAAO,KAAK;;CAGd,AAAO,cAAc,SAAkC;EACrD,MAAM,OAAO,KAAK;EAClB,MAAM,QAAQ,KAAK;EACnB,MAAM,aAAa,CAAC,GAAG,SAAS,GAAG,MAAM,QAAQ;EACjD,MAAM,WAAW,MAAM,YAAY,EAAE,SAAS,YAAY,CAAC;AAC3D,OAAK,SAAS,EAAE,OAAO,UAAU,CAAC;;CAGpC,AAAO,cAAc,SAAkC;EACrD,MAAM,OAAO,KAAK;AAClB,MAAI,CAAC,KAAM;EAEX,MAAM,QAAQ,KAAK;EACnB,MAAM,aAAa,MAAM,QAAQ,QAAQ,MAAM,CAAC,QAAQ,SAAS,EAAE,CAAC;EACpE,MAAM,WAAW,MAAM,YAAY,EAAE,SAAS,YAAY,CAAC;AAC3D,OAAK,SAAS,EAAE,OAAO,UAAU,CAAC;;CAGpC,KAAK,SAA2B;EAC9B,MAAM,QAAQ,KAAK,UAAU;AAC7B,SAAO,QAAQ,OAAO,KAAK,UAAU,KAAK,QAAQ,OAAU;;CAG9D,QAAQ,SAA2B;EACjC,MAAM,QAAQ,KAAK,UAAU;AAC7B,SAAO,QAAQ,OAAO,QAAW,KAAK,QAAQ,OAAU;;CAG1D,AAAO,cACL,MACA,gBACM;EACN,MAAMC,UAA+B,GAAG,SAAe;GACrD,MAAM,UAAU,eAAe,GAAG,KAAK;AACvC,UAAO,KAAK,KAAK,QAAQ;;EAG3B,MAAM,WAAW,GAAG,SAAe;GACjC,MAAM,UAAU,eAAe,GAAG,KAAK;AACvC,UAAO,KAAK,QAAQ,QAAQ;;AAG9B,SAAO,WAAW;AAClB,SAAO,UAAU;AAEjB,OAAK,SAAS,QAAQ;;CAGxB,AAAO,cAAc,MAAoB;AACvC,SAAO,KAAK,SAAS;;;;;;AAOzB,IAAa,SAAb,MAA+C;;;;CAM7C,YAAY,UAA0B;gBA8C7B,UAAgD;AACvD,OAAI,MACF,MAAK,SAAS,MAAM,MAAM;OAE1B,MAAK,SAAS,SAAS;;uBAOL;AACpB,QAAK,SAAS,SAAS;;qBAML;AAClB,QAAK,SAAS,MAAM,OAAO;;oBAMV;AACjB,QAAK,SAAS,MAAM,IAAI,MAAM;;cAOzB,cAAuC;AAC5C,UAAO,KAAK,SAAS,IAAI,UAAU;;sBAWtB,UAA6B;AAC1C,QAAK,SAAS,YAAY,MAAM;;qBAkBhC,SACA,cACS;AACT,UAAO,KAAK,SAAS,WAAW,SAAS,UAAU;;0BAMjB;AAClC,UAAO,KAAK,SAAS,YAAY;;qBAMd,YAAwC;AAC3D,UAAO,KAAK,SAAS,WAAW,QAAQ;;eAOlC,YAA8B;AACpC,UAAO,KAAK,SAAS,KAAK,QAAQ;;kBAOzB,YAA8B;AACvC,UAAO,KAAK,SAAS,QAAQ,QAAQ;;AA9IrC,MAAI,EAAE,oBAAoB,gBACxB,OAAM,IAAI,UAAU,yBAAyB;AAE/C,OAAK,WAAW;;;;;CAMlB,IAAI,UAAmB;AACrB,SAAO,KAAK,SAAS;;;;;CAMvB,IAAI,OAAmB;AACrB,SAAO,KAAK,SAAS;;;;;CAMvB,IAAI,SAA2D;AAC7D,SAAO,KAAK,SAAS;;;;;CAMvB,IAAI,QAAqB;AACvB,SAAO,KAAK,SAAS,UAAU;;;;;CAMjC,IAAI,UAAmB;AACrB,SAAO,KAAK,SAAS,MAAM,UAAU,IAAI;;;;;CA8G3C,IAAI,WAAqC;AACvC,SAAO,KAAK,SAAS;;;;;CAMvB,IAAI,QAA+B;AACjC,SAAO,KAAK,SAAS;;;;;CAMvB,IAAI,QAA+B;AACjC,SAAO,KAAK,SAAS"}